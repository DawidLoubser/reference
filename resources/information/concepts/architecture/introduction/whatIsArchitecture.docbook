<?xml version="1.0" encoding="UTF-8"?><?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?><section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:id="resources.information.concepts.architecture.introduction.whatIsArchitecture" xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">

  <title>What is architecture?</title>
  <para>
    Architecture is a relatively new fields which focuses on providing a high-level
    and often more abstract solution to a problem. It provides a framework within which 
    the detailed system design is done.
    In general we can say 
    <programlisting>
Architecture = Infrastructure      
      </programlisting>
  </para>
  <para>
    More specifically we define architecture as follows:
    <blockquote><para><emphasis>
      Architecture provides the infrastructure addressing the quality requirements
      to be realized across use cases deployed within the architecture. In addition to the above,
      architecture often includes a high-level responsibility distribution across core components,
      the contracts (interface specification plus non-functional requirements) for these components as
      well as the integration infrastructure between these components.
    </emphasis></para></blockquote>
  </para>
   <para>
     We shall see that architecture is largely <emphasis>driven by the core non-functional 
     requirements</emphasis> like modifiability, performance, availability and only to a 
     much lesser extend by the direct functional requirements, <abbrev>i.e.</abbrev> 
     by the details of the use cases. These non-function requirements manifest themselves 
     in <emphasis>quality attributes</emphasis> of an architecture.
   </para>
   
   <section>
     <title>Difference between architecture and design</title>
     <para>
       For each use case one designs a solution and deploys that solution within the architecture.
       As such the design realizes the functional requirements provided with the use case
       specification while the architecture realizes the quality requirements like
       reliability, performance, scaleability and integrability. 
     </para>  
     <para>
        The architect and the designers typically work at different levels of abstraction. The
        architect designs the infrastructure whithin which the use case are deployed, while
       designers design solutions which iteratively realize the client's functional requirements.
     </para>
   </section>
  
  
  <section>
    <title>MDA and the orthogonality of architecture and design</title>
    <para>
      Preferably architecture and the core design (up to the Platform Independent Model (PIM) of the
      Model Driven Architecture (MDA)) should be viewed as being orthogonal. Either should be able
      to change without affecting the other. 
    </para>
    <figure xml:id="resources.information.concepts.architecture.introduction.mdaBasedApproach">
      <title>MDA based approach</title>
      <mediaobject><imageobject><imagedata fileref="mdaBasedApproach.jpg"/></imageobject></mediaobject>
    </figure>
    
    <para>
      A design team should thus be able to design the PIM for a use case without having to know the
      deployment architecture or the technologies which will be used. Similarly, an architecture
      team should be able to put an architecture in place before understanding all details of the
      use case requirements for a system.
    </para>
    
    <para>
      The PIM as generated by a design methodology like URDAD (the Use-Case/Responsibility
      Driven Analysis and Design) should thus survive changes in architecture and changes in
      technology.
    </para>
    
    <section>
      <title>Example</title>
      <para>
        A company whose core business is to provide a medical aid claims switch through to medical
        aid administrators, experienced stability and maintainability problems
        with their core claims processing system. In addition, the company wanted to ensure that the
        system can address growing demands on other quality requirements like scaleability
        and performance.
      </para>
      <para>
        We were called in as consultants to assess the current state of their systems and make
        recommendations on how the current problems and future demands could be addressed
        effectively. The result of the assessment was a recommendation that the entire architecture
        should be changed without touching the design. 
      </para>
      <section>
        <title>outline of the original architecture</title>
        <para>
          The original architecture had the following core features:
          <itemizedlist>
            <listitem><para>
              The system core was realized via a <emphasis>multi-layered clustered environment with
                different software layers deployed on different hardware layers</emphasis>.
              There were 4 layers with
              <itemizedlist>
                <listitem><para>
                  two machines load balancing incoming requests across 
                </para></listitem>
                <listitem><para>
                  a cluster of 5 front-end machines demarshaling the request and persisting the
                  incoming claims which load balance the calls onto        
                </para></listitem>
                <listitem><para>
                  a rules processing cluster which, in turn, load balances the preprocessed
                  requests
                </para></listitem>
                <listitem><para>
                  across a third cluster of machines which marshaled the preprocessed medical aid
                  claims onto messages for the individual medical aid administrators.
                </para></listitem>
              </itemizedlist>
            </para></listitem>
            <listitem><para>
              <emphasis>Intra-layer communication</emphasis> was done via asynchronous XML messages.
              The original synchronous request was thus internally mapped onto asynchronous messages
              between the software layers, forwarded synchronously to the medical aid administrator,
              and returned through the layers asynchronously. For the return the asynchronous message
              was matched with the original synchronous request in order top provide a synchronous
              response.
            </para></listitem>
            <listitem><para>
              Persistence was realized through a XML-Castor based database mapping onto local
              databases which were synchronized across all local databases within the 4 layers of
              clusters as well as a master database.
            </para></listitem>
            <listitem><para>
              Connectivity to the medical aid administrators was done by having proprietary connector
              components open separate sessions for the the individual requests.
            </para></listitem>
            <listitem><para>
              Load balancing was done through home-grown load balancers requesting threads from
              home-grown thread pools. Object pools where otherwise not used.
            </para></listitem>
          </itemizedlist>
          </para>
      </section>
      
      <section>
        <title>The replacement architecture</title>
        <para>
          The core thrust of the replacement architecture was an overall simplification resulting in
          the following architectural elements:
          <itemizedlist>
            <listitem><para>
              The different software layers were deployed onto the same hardware layer, removing
              the XML-based intra-layer communication.
            </para></listitem>
            <listitem><para>
              The local databases and the synchronization process between them was replaced by
              2 synchronized Postgres database servers accessed via a fail-over safe JCA
              database connector provided by JBoss.
            </para></listitem>
            <listitem><para>
              The request processing workflows where realized within EJB-3 session beans deployed on
              the JBoss J2EE application server.
            </para></listitem>
            <listitem><para>
              Persistent objects where realized through EJB-3 entity beans using hibernate as
              light-weight persistence mechnism.
            </para></listitem>
            <listitem><para>
              Integration to the medical aid administrators was done using JCA adapters. This allows
              for good responsibility allocation and enables the application server to optimize
              the connection pool.
              <note><para>
               The idea behind application servers is that they should manage  all resources
                including CPU resources (threads), memory resources (object pools) and connection
                resources.
              </para></note>
            </para></listitem>
          </itemizedlist>
        </para>
        
        <para>
          Even though the architecture was completely changed and even though some of the
          realization technologies were changed (using an application server and removing internal XML based
          communication and persistence), the design realizing the use cases was not touched. The
          internal objects were the same, the respnsibilities they addressed and the algorithms they
          used to realizethe functional reqirements remained unchanged throughout the project.
        </para>
      </section>
    </section>
  </section>
  
</section>