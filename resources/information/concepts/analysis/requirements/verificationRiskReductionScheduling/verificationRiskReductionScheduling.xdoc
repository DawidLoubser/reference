<?xml version="1.0" encoding="UTF-8"?>
<!--
<!DOCTYPE chapter SYSTEM "file:/opt/share/xml/Oxygen/docbook/dtd/docbookx.dtd">
-->
<chapter id="resources.information.concepts.analysis.requirements.verificationRiskReductionScheduling.verificationRiskReductionScheduling"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:noNamespaceSchemaLocation="http://www.solms.co.za/schemas/doc/solmsDoc/solmsDoc.xsd" 
         xmlns:xi="http://www.w3.org/2001/XInclude">

      <title>Verification, Validation, Risk Reduction and Scheduling</title>
      <section role="section">
        <title>Requirements Inspection</title>
        <para> 
            Let different people inspect the requirements which falls within their area of
          expertise and ask them to write a little report on what they think. This forces them to
          put something in writing without necessarily feeling that their head is on the line.
        </para>
      </section>

      <section>
        <title>Walking Use Cases</title>
        <para> 
            A common technique for validating a use case is that of em walking the use case. Each
          actor is represented is represented by a person who says what messages he/she sends to the
          system. The system itself is also represented by a person who says what the system does in
          response to the messages and what deliverables are supplied.
        </para>
        <para> 
            The roles the different persons play can be exchanged to increase the likelihood of
          identifying omissions in the use case model. This ensures that different people with
          different backgrounds focus on the same aspects of a use case.
        </para>
        <para> 
            The group used to play the roles should typically include domain experts, product
          champions, analysts and perhaps a representative from the developer group.
        </para>
        <para> 
            Note that each walking of a use case is equivalent to stepping through a particular
          sequence diagram. Hence the sequence diagrams can be used to identify the different paths
          followed when walking the use case and of course new paths identified in the process map
          directly onto new sequence diagrams.
        </para>
      </section>
      
      <section>
        <title>Comparing with Existing Products</title>
        <para> 
            Compare the way the system provides certain functionalities available also in other
          systems with the way in which they are provided there. Convince yourself that the
          differences do not represent problems or errors.
        </para>
      </section>
      
      <section>
        <title>Test Cases</title>
        <para> 
            Often problems with system requirements are exposed by writing test cases. Since test
          cases aim to mimic how the system is used. They enforce a user's perspective and require
          from the analyst to think about details which might otherwise be omitted.
        </para>
        <para> 
            I have never seen system requirements which did not undergo substantial changes when
          the test cases were written. Hence the development of test cases is a process which in
          itself is very useful. The resultant tests can then be used to verify the system
          requirements and ultimately to validate the built system.
        </para>
      </section>

      <section>
        <title>Risk Reduction through Prototyping</title>
        <para> 
            Frequently details in the requirements specification which would otherwise have been
          omitted pop up when prototypes are demonstrated or used. Prototypes are also a valuable
          part of a requirements workshop encouraging the different role players to participate more actively.
        </para>
        <para> 
            It is, however, important that the participants do not obtain the opinion that the
          prototype is already part of the working system and that the system is already cast in
          stone. Another danger of prototypes is that management or other role players of the client
          company may get the impression that most of the work is already done. If such perceptions
          persist it may be worth-while to revert to simple hand-drawn diagrams to illustrate the
          user-interface or application dynamics.
        </para>
        <para> 
            The prototypes may be throw-away prototypes or evolutionary prototypes. The former
          should be developed rapidly and at very low cost. Throw-away prototypes do not require
          deeper architectural or design insights when they are developed. A prototype which may be
          as primitive as a user-interface shell with only very little logic behind it is a great
          way of stimulating feedback from users and domain experts. Furthermore, do not invest time
          (and money) in trying to perfect the user interface for the prototype. It should simply
          show the contents of the screens in rudimentary form. Nevertheless, the prototypes should
          display realistic and intuitively plausible information on the screens. Otherwise the
          focus of the discussion can easily be lost.
        </para>
        <para> 
            Evolutionary prototypes, on the other hand, have the advantage that they evolve to
          become tested parts of the final system. This may speed up product delivery, particularly
          for simpler systems where the overall architecture and design of the system is relatively
          simple. Since evolutionary prototypes become part of the final system they must be
          developed using production code criteria.
        </para>
        <para> 
            For more complex systems it may be good to start off with a few throw-away prototypes
          before developing an evolutionary prototype iteratively around use cases.
        </para>
      </section>

      <section>
        <title>Inspection Check List for Requirements Specification</title>
        <para>
            <orderedlist>
              <listitem>
                <para>Are the requirements correct? 
                <orderedlist>
                  <listitem>
                    <para>Is each use case a stand-alone, discrete task? </para>
                  </listitem>
                  <listitem>
                    <para>Are the requirements mutually consistent? </para>
                  </listitem>
                  <listitem>
                    <para>Is each requirement within the scope of the problem? </para>
                  </listitem>
                  <listitem>
                    <para>Are the requirements non-ambiguous? </para>
                  </listitem>
                  <listitem>
                    <para>Are the requirements implementable? </para>
                  </listitem>
                  <listitem>
                    <para>Do the requirements describe a usable system.</para>
                  </listitem>
                </orderedlist></para>
              </listitem>
              <listitem>
                <para>Are the requirements complete, yet minimal? 
                <orderedlist>
                  <listitem>
                    <para>Have all the use cases been identified? </para>
                  </listitem>
                  <listitem>
                    <para>For each use case check that 
                    <orderedlist>
                      <listitem>
                        <para>Is the use case a stand-alone, discrete task? </para>
                      </listitem>
                      <listitem>
                        <para>Is the role of each actor in the use case clearly defined. </para>
                      </listitem>
                      <listitem>
                        <para>Is the objective for the main actor clearly stated? </para>
                      </listitem>
                      <listitem>
                        <para>Are all the actors required for the use case? </para>
                      </listitem>
                      <listitem>
                        <para>Have the success and minimal guarantees been defined? </para>
                      </listitem>
                      <listitem>
                        <para>Have the scenarios for success and alternative paths been specified?</para>
                      </listitem>
                    </orderedlist></para>
                  </listitem>
                  <listitem>
                    <para>Are all external software, hardware and communication interfaces defined? </para>
                  </listitem>
                  <listitem>
                    <para>Have all performance, security, safety and legal requirements been specified? </para>
                  </listitem>
                  <listitem>
                    <para>Are the documentation requirements complete? </para>
                  </listitem>
                  <listitem>
                    <para>Have the supportability requirements been specified? </para>
                  </listitem>
                  <listitem>
                    <para>Are the requirements free from design and implementation details? </para>
                  </listitem>
                  <listitem>
                    <para>Have all duplicate requirements been removed?</para>
                  </listitem>
                </orderedlist></para>
              </listitem>
              <listitem>
                <para>Are the requirements verifiable, testable and maintainable 
                <orderedlist>
                  <listitem>
                    <para>Are the requirements specific enough to be verifiable. </para>
                  </listitem>
                  <listitem>
                    <para>Have test cases been developed for different scenarios of the use cases? </para>
                  </listitem>
                  <listitem>
                    <para>Are the requirements structured and modular such that additional requirements
                      can easily be added without excessive inconsistency risk?</para>
                  </listitem>
                </orderedlist></para>
              </listitem>
            </orderedlist>
        </para>
      </section>
  
</chapter>
