<?xml version="1.0" encoding="UTF-8"?>
<section id="resources.information.concepts.objectOrientation.introduction.ooModeling"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:noNamespaceSchemaLocation="http://www.solms.co.za/schemas/doc/solmsDoc/solmsDoc.xsd" 
         xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Introduction to Object-Oriented Modeling</title>
  <para>
    Object-oriented modeling is used in more and more disparate fields. Let
    us first look at what object-oriented modeling is and then at some benefits
    provided by object-oriented modeling.
  </para>
  
  <!-- ================================================================== -->
  
  <section><title>What is Object-Oriented Modeling?</title>
    <para>
      Object-Oriented Modeling is a way of modeling systems in a
      language natural to the system. The system, which itself is an object,
      is iteratively decomposed into objects (components) each with its own
      attributes and services.
      These components collaborate to provide the required functionality
      of the system.
    </para>
    <para>
      Object-oriented modeling thus aims to structurally and functionally
      decompose a system into smaller units with less complexity and
      less responsibilities. These units should be as independent as possible
      and should preferable be testable outside the system. The system is
      then iteratively assembled from these tested components.
    </para>
    <para>
      There is an overhead associated with developing and maintaining the
      models. In fact, in many projects the model has not been kept at the
      same maintenance level as the code, often because developers find it
      a burden to do that. But even in these projects the benefits from 
      having based the system on an initial analysis and design usually
      justify the extra effort incurred.
    </para>  
  </section>
  
  <!-- ================================================================== -->

  <section><title>What is Object-Oriented Analysis and Design?</title>
    <para>
      Object-Oriented Analysis and Design (OOAD) refers to the application
      of object-oriented modeling to the analysis of systems or system requirements
      and to designing object-oriented systems fulfilling these requirements.
    </para>
    <para>
      The system may be virtually anything including an organization 
      (<abbrev>e.g.</abbrev> a company), a business unit, a software
      system which exists or one for which the requirements specification
      are written, a data warehouse or even a hardware system.
    </para>
  </section>

  
  <!-- ================================================================== -->

  <section><title>Why use Object-Oriented Modeling?</title>

    <para>
      Object-Orientation (OO) has been the buzz word for more than a decade now. The
      initial expectations where perhaps inflated and many of the initial OO
      projects where either much more expensive than anticipated or failed
      completely. The OO technologies have, however, matured a lot and the
      delivery of good quality, cost-efficient products are today largely in the 
      OO paradigm.
    </para>
    
    <section>
      <title>Clean conceptual modeling of domains</title>
      <para>
        Object oriented models provide a farmework within which one can formalize clean, 
        intuitive conceptualizations of domains. 
      </para>
    </section>
    
    
    <section><title>Reducing Realization Costs</title>
      <para>
        One of the main attractions of object-oriented methodologies 
        is the promise of reduced realization costs. This is facilitated
        by
        <itemizedlist>
          <listitem><para>
            improved communication between role players,
          </para></listitem>
          <listitem><para>
            complexity reduction for complex domains, and
          </para></listitem>
          <listitem><para>
            contract and component based approach to service providers.
          </para></listitem>
        </itemizedlist>
      </para>
    </section>

    <section><title>Improved Communication between Role Players</title>
      <para>
        Because OOAD languages (<abbrev>e.g.</abbrev> UML)
        <itemizedlist>
          <listitem><para>aim to remain close to the problem domain</para></listitem>
          <listitem><para>
            allow for direct mapping onto various programming languages, 
            particularly onto OO programming languages
          </para></listitem>
        </itemizedlist>
        they provide an ideal communication medium between the various role 
        players in the system analysis and development process, from domain
        expert to analysts, designer, implementor and maintainer. 
      </para>
      <para>
        Graphical languages like the Unified Modeling Language (UML) allow for 
        diagrammatic designs which provide selective views, focusing only on 
        those elements which are relevant to those points one currently wants 
        to illustrate.
      </para>
      
      <section><title>Communication with Domain Experts</title>
        <para>
          Of particular importance is the communication with domain experts
          who are in the best position to understand the system requirements.
          A domain expert is one who is an expert of the problem domain. 
          Typically domain experts are found within the client company. They
          should be included formally or informally in the development team, 
          at least during the requirements analysis stage.
        </para>
        <para>
          Many studies have shown that typically around
          half of the system bugs are due to errors in understanding
          the system requirements and that these errors contribute more than 80% of
          the cost of system errors. It is thus critical that one obtains a complete
          and precise (unambiguous) understanding of the client's requirements
          and there is no better source for information regarding these than
          the domain experts.
        </para>
        <para>
          Good object-oriented models are usually easily accessible to domain experts
          and they facilitate communication between domain experts, system analysts
          and developers.
        </para>
      </section>
    </section>

    <section><title>Reducing Complexity</title>
      <para>
        Systems are generally complex and a large part of the effort should be
        directed at reducing the intrinsic complexity. This is not only true
        for software systems but for systems in general. A modern motor car, for 
        example, is in its entirety a very complex system. However, by viewing
        the car not as a single monolithic apparatus, but as a collection of
        components which interact with one another in standardized ways the
        perception of the system is a lot less complex. One can understand
        the functioning of the car at a higher, more abstract level by talking
        abstractly about the components without zooming into the design and
        implementation details of these components. These components can 
        then be designed and developed by separate development teams residing
        very often in separate companies. 
      </para>
      <para>
        In a similar way complexity reduction in software systems can be achieved
        via a component based approach. Furthermore, object-oriented analysis
        and design techniques allow for selective viewing of system features.
        These selective views are incomplete views which only present those
        features of the system relevant to the current view.
      </para>
    </section>

    <section><title>Component Based Approach</title>
      <para>
        In the previous section we touched upon how system complexity reduction
        has been achieved in the manufacturing world using a component based
        approach. A car manufacturer does not have to understand the implementation
        complexities of the electronic ignition or gearbox. He has to understand
        the specifications and the interface. Understanding is sufficient for
        judicious component selection and interfacing/assembling of components
        to produce the product.
      </para>
      <para>
        In a similar way we are moving towards a component based approach in
        software development. This is facilitated by object orientation and
        various system integration methodologies (particularly CORBA) as well
        as business and presentation logic containers like servlet and EJB
        containers or the containers provided by .Net.
      </para>
      <para>
        Each component deployed on a machine or in a component container
        complies to some specifications and has a well defined
        interface. The components themselves can be produced by component
        vendors. Such components may be bought from these component vendors.
        A component-based approach aims for increases in
          <itemizedlist>
            <listitem><para>productivity,</para></listitem>
            <listitem><para>quality and</para></listitem>
            <listitem><para>re-use.</para></listitem>
          </itemizedlist>
      </para>
    </section>
    
    <section><title>Increasing Productivity and System Quality</title>
      <para>
        The industrial revolution of the 19'th century has shifted the production
        process from single producers developing entire systems from scratch to
        a component-based approach where systems are largely assembled from tested
        components. This has resulted in an increase in quality as well as in
        productivity. These are driven by specialization of manufacturers and by
        component reuse.
      </para>    
      <para>
        The component-based approach in software production is starting to result
        in a similar increase in quality and productivity. The components interface
        via predefined interfaces and comply to manufacturer specifications. They
        are tested thoroughly and software systems are, to a large extend, assembled
        from these tested components.
      </para>
    </section>
    
    <section><title>Reducing Risk of Failures</title>
      <para>
        Traditionally a large proportion of system development projects simply failed.
        They did not deliver what the client really needed, were often error prone
        and hugely over budget.
      </para>
      <para>
        The focus on communication with domain experts in order to understand the
        system requirements together with the component-based approach of assembling
        systems from tested components should significantly reduce the risk of failure.
      </para>
      <para>
        The biggest risk is perhaps that of building the wrong system. This can be due 
        to not understanding what the clients requested. It is, however, not uncommon
        that the client themselves do not understand what they actually need. OOAD can
        help to prevent both problems. It facilitates communication with clients and
        domain experts and it can help clients to understand their own needs.
      </para>  
      <para>
        Other factors which should help to reduce the risk of failure are
        <itemizedlist>
          <listitem><formalpara>
            <title>Incremental delivery</title>
            <para>
              The required functionality (all the use cases)
              are not delivered all at once but incrementally. This gives clients
              the chance to evaluate the completed modules and give early feedback.
            </para>
          </formalpara></listitem>
          <listitem><formalpara>
            <title>Solving difficult problems first</title>
            <para>
              The difficult elements of a system should be
               attacked early. This makes certain that problems are identified early 
               and allows more time to think about these issues. Furthermore, should a
               problem be unsurmountable, this will be apparent early in the process
               where the project cost is still relatively low. Also, once these have
               been completed the scheduling of delivery should be a lot more certain.
            </para>
          </formalpara></listitem>
          <listitem><formalpara>
            <title>Testing</title>
            <para>
              Testing should be an integral part of the process starting with
              <itemizedlist>
                <listitem><para>
                  testing of the business model and continuing with                  
                </para></listitem>
                <listitem><para>
                  testing of the requirements,
                </para></listitem>
                <listitem><para>
                  testing of the architecture and high-level design,
                </para></listitem>
                <listitem><para>
                  testing of the logical units at various levels of granularity
                  and finally 
                </para></listitem>
                <listitem><para>
                  high-level system testing in a deployment environment.
                </para></listitem>
              </itemizedlist>
            </para>
          </formalpara></listitem>
        </itemizedlist>
      </para>
    </section>
    
    <section><title>Reduced Maintenance Costs</title>
      <para>
        The reduced system complexity and a component-based approach should result
        in significant lower maintenance costs. The systems should be much more
        accessible to persons who were not part of the original development team
        and even for those who were, the model should help to understand the system
        once again. 
      </para>
      <para>
        Furthermore, often maintenance can be localized to within single components
        and sometimes these components can be simply exchanged for more modern
        components which may even be supplied by different suppliers.
      </para>
    </section>

    <section><title>Facilitating Dynamic Systems</title>
      <para>
        Successful software systems generally live longer than anticipated as is
        seen by the large number of legacy systems in use.
        Over such long periods the environment can change substantially. The result
        is that the requirements for systems may change frequently. Often companies
        which can change their systems more rapidly and can hence deliver new 
        products faster have the edge over those companies not in the position to 
        do that.
      </para>  
      <para>
        Object-oriented modeling and in particular a component based approach where
        newer components can be plugged in to replace the older components can
        increase the flexibility of systems considerably. Also, the ability to
        understand a system from the design and to test the system after modification
        can increase the speed with which systems can be modified.
      </para>
      <para>
        Furthermore, aspects of legacy systems can be re-used in a clean object-oriented 
        way and integrated cleanly into modern systems via integration technologies like
        CORBA and SOAP.
      </para>
    </section>

    <section><title>Availability of Analysis and Design Tools</title>
      <para>
        Finally, object orientation lends itself to developing  
        powerful analysis and design tools. Many of these support the full
        software development cycle, including analysis, design, implementation, 
        documentation generation and verification. They often support automatic 
        code generation from designs and automatic design generation from code. 
        Some of these support round-trip engineering which allows the user to 
        make changes either on the code or on the design with the rest of the 
        system being automatically updated. This ensures that design and code 
        are always on the same maintenance level.
      </para>
    </section>
  </section>
</section>
