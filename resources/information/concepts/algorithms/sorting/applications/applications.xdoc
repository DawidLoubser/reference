<?xml version="1.0" encoding="UTF-8"?>

<section id="resources.information.concepts.algorithms.sorting.applications.applications"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:noNamespaceSchemaLocation="http://www.solms.co.za/schemas/doc/solmsDoc/solmsDoc.xsd" 
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Applications of sorting algorithms</title>
  <para>
    
  </para>
  <para>
    <itemizedlist>
      <listitem><formalpara>
        <title>Searching</title>
        <para>
          <itemizedlist>
            <listitem><para>
              Search pre-processing = most common application of sorting.  
            </para></listitem>
          </itemizedlist>
          <itemizedlist>
            <listitem><para>
              Reduces searching to <emphasis>O(log n)</emphasis>.
            </para></listitem>
          </itemizedlist>
        </para>
      </formalpara></listitem>
      
      <listitem><formalpara>
        <title>Determine element uniqueness</title>
        <para>
          Sort first, then linearly scan to check for duplicates.
        </para>
      </formalpara></listitem>
      
      <listitem><formalpara>
        <title>Closest pair</title>
        <para>
          Sort first, then check distances between neighbours.
        </para>
      </formalpara></listitem>
      
      <listitem><formalpara>
        <title>Determine frequency distributions</title>
        <para>
          Sort and determine how many elements have values within buckets (could be single value or range buckets).
        </para>
      </formalpara></listitem>
      
      <listitem><formalpara>
        <title>Selecting n'th largest/smallest element in collection</title>
        <para>
          Use <literal>java.util.TreeSet</literal> to remove duplicates and have sorted.
        </para>
      </formalpara>
      </listitem>
      
      <listitem><formalpara>
        <title>Removing duplicates</title>
        <para>
          Sort and remove duplicate neighbours.
          <note><para>
            Alternativly use set data structure (<abbrev>e.g.</abbrev> <literal>java.util.HashSet</literal>
            or <literal>java.util.TreeSet</literal>).
          </para></note>
        </para>
      </formalpara>
      </listitem>
      
      <listitem><formalpara>
        <title>Priority queues</title>
        <para>
          Sort on criterion detrrmining priority and process in sort order. For example, want to process jobs
          in order of their dead-lines (sort on dates, if not naturally supported, use milliseconds representation).
          <note><para>
            JDK 1.5 supports priority queues directly. Can use <literal>java.util.TreeMap</literal>
          </para></note>
          
        </para>
        <para></para>
      </formalpara>
      </listitem>
    </itemizedlist>
  </para>

</section> 
 