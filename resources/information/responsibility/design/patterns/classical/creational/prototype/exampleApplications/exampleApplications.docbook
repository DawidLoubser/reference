<?xml version="1.0" encoding="utf-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<!--Authored by mailto:fritz@solms.co.za -->
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude">
    
    <title>Example applications</title>
    <para>
        Prototypes enable clients to select at run-time what objects they want to create. The
        prototype pattern provides a simple solution for facilitating dynamic object creation
        and run-time management of a registry of objects.
    </para>
    
    <section>
        <title>Graphical design applications</title>
        <para>
            Prototypes are widely used in graphical editors like general drawing applications, UML editors, 
            applications for electronic circuit design and so forth. 
            Clients select which objects they want to create from a panel of icons. Each icon acts as a 
            proxy for a prototype object which is clones upon selection.
        </para>
    </section>  
    
    <section>
        <title>Prototype-based, dynamic programming languages</title>
        <para>
            Static programming languages like Java, C++, C# and Delphi are quite rigid. The behavior
            of an object is defined by a class and  that behavior can only be changed by subclassing.
            Certain patterns aim to break the static nature of these languages. For example,
            <itemizedlist>
                <listitem><para>
                    the <emphasis>decorator</emphasis>
                    pattern enables you to add extra respnsibilities to an existing service,
                </para></listitem>
                <listitem><para>
                    the <emphasis>state</emphasis> pattern enables you to specify different service
                    realizations for different object states,
                </para></listitem>
                <listitem><para>
                    the <emphasis>exposed state</emphasis>  pattern 
                    enables you to add aditional services which become available when an object is in a 
                    specific state,
                </para></listitem>
                <listitem><para>
                    and the <emphasis>Visitor</emphasis> pattern enables you to
                    add additional functionalities across a class hierarchy, even at run-time.
                </para></listitem>
            </itemizedlist>
        </para>
        <para>
            Prototype-based programming languages like <emphasis>Self</emphasis> do not introduce
            the concept of a class. Instead they only supply objects, but enable you to add services and
            attributes on the fly. New objects are created solely from cloning. Thus, the root object is cloned
            and that clone can evolve over time, generating further clones with different services and
            attributes.
            <note>
                <para>
                    <emphasis>Self</emphasis> was designed by David Ungar and Randall Smith in 1986.
                    A paper describing the language appeared at OOPSLA '87. An
                    initial implementation was undertaken at Stanford University in
                    1987. After that, Self was used as a vehicle for language,
                    environment, user interface and implementation research (as we
                    shall see, some of the features of Self pose challenging
                    implementation problems). A public releases of Self from
                    Stanford took place in 1990. In 1991 the Self project moved to
                    Sun Microsystems Labs. Further public releases took place in
                    1992 and 1993, and the latest release, 4.0, emerged in July 1995.
                </para>
            </note>
        </para>
    </section>
    
</section>
