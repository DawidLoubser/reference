<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<!-- author Fritz Solms -->
<section xmlns="http://docbook.org/ns/docbook"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Implementation mapping of the domain objects layer</title>
    <para>
        Classes in the domain/entity model are mapped onto either Java entities or onto
        embedded classes, i.e. classes whose state is embedded within the persistence unit (e.g. table)
        of the owning entity - embedded classes should only be used for the component side of
        UML composition relationships. Note that all entity classes have been declared serilizable
        and hence that the entities can be detached and used as value objects. At a later stage 
        they can be merged back into a managed state 
    </para>
    
    <section>
        <title>Geographic coordinates</title>
        <para>
            The geographic coordinates can be mapped onto either 
            <itemizedlist>
                <listitem><para>
                    an entity which is persisted in a separate table, or onto
                </para></listitem>
                <listitem><para>
                    an embedded class whose fields are embedded as columns in the table of the owner class.
                </para></listitem>
            </itemizedlist>
            We chose to model Geographic Coordinates as a separate entity (one can make a strong argument for
            using an embedded class instead). The class is annotated as an entity. A domain-neutral object identifier, id,
            has been added and annotated as an <literal><![CDATA[@Id]]></literal> 
            which should be auto-generated by the application server:
            <programlisting>
<xi:include href="../../weatherBuro/businessLogic/src/main/java/za/co/solms/location/GeographicCoordinates.java" parse="text"/>                
            </programlisting>
        </para>
    </section>
    
    <section>
        <title>Locations</title>
        <para>
            Locations are entities which contain geographic coordinates via composition. We chose to map this onto a one-to-one 
            uni-directional entity relationship (which can be queried from only the owner, i.e. the location side) and have requested
            all-cascading which includes cascading merges and deletes. This ensures that when a Location is deleted or updated, its
            geographic location is deleted or updated as well (in composition the component may not survive the owner). This has been
            done via the <literal><![CDATA[@OneToOne]]></literal> annotation on the getter for the geographic coordinates.
        </para>
        <programlisting>
<xi:include href="../../weatherBuro/businessLogic/src/main/java/za/co/solms/location/Location.java" parse="text"/>                
        </programlisting>
        <para>
            We did not want to make a domain attribute like the location name the primary key, even though business required that
            location names need to be unique - after all, this business rule could change. So we added a domain-neutral object identifier
            and assigned <literal>unique=true</literal> and <literal>nullable=false</literal> constraints to the name column.
        </para>
        <para>
            In addition this class defines some pre-compiled JPA queries for this entity. These queries are available to the services layer
            (e.g. session beans) to find appropriate objects using the entity manager to create and execute the queries. Here we have two
            simple queries finding all locations and the locations with a specified name respectively. We could add queries to find all locations
            within a particular geographic area or within a certain radius from certain other locations.            
        </para>
    </section>
    
    <section>
        <title>Weather readings</title>
        <para>
            Weather readings are associated via a many-to-one relationship to locations. However, since this is an association and not a
            composition relationship, we do not specify and cascading.
        </para>
        <programlisting>
<xi:include href="../../weatherBuro/businessLogic/src/main/java/za/co/solms/weather/WeatherReading.java" parse="text"/>                
        </programlisting>
        <para>
            Each weather reading has a date. The date could be persisted onto a SQL date which has no time information or the full
            date/time could be persisted. We require the latter and specify this via
            <literal><![CDATA[@Temporal(TemporalType.TIMESTAMP)]]></literal> annotation. In addition, each reading requires a date/time
            stamp and hence we specify that the corresponding column may not be null via a
            <literal><![CDATA[@Column(nullable=false)]]></literal> annotation.
        </para>    
        <para>
            Each reading has an ambiance which is an enumeration:
            <programlisting>
<xi:include href="../../weatherBuro/businessLogic/src/main/java/za/co/solms/weather/Ambiance.java" parse="text"/>                
        </programlisting>
            The enumeration is embedded by the object relational mapper.
        </para>            
        <para>
            Finally we define some pre-compiled queries for the entity which will be used by the services layer. For example
            <programlisting><![CDATA[
@NamedQuery(name="findAllWeatherReadingsForLocationAndPeriod", 
		query="select wr from WeatherReading wr where wr.location = :location" 
			+ " and wr.dateTime > :after and wr.dateTime <= :onOrBefore")                
			]]></programlisting>
            finds all weather readings for a specified location which are after some provided <literal>after</literal> date
            and on or before some provided <literal>onOrBefore</literal> date. 
            <note>
                <para>
                    These queries are object-oriented queries which traverse the object graph. They are mapped by the chosen
                    object-relational mapper onto the appropriate query for the chosen database (e.g. onto the appropriate
                    flavour of SQL).
                </para>
            </note>
        </para>
    </section>    
</section>    