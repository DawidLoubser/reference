\section{Introduction}
\label{sec:introduction}

Formal methods aim to provide non-ambiguous requirements and a design
which can be proven to be correct and reliable \cite{Monin:understandingFormalMethods}.
These methods, however, are typically perceived as difficult and expensive: their
use has historically largely been confined to a relatively small class of problems
where safety and reliability are paramount (such as the aviation \cite{hall:formalMethodsInRealAirTraffic}
and defense industries, where testing and debugging costs can contribute more
than 50\% of the development costs
\cite{platzer:verificationOfCyberphysicalTransportationSystems}.)

Agile methods \cite{agileManifesto, martin:agileSoftwareDevelopment},
on the other hand, accept that the initial requirements are potentially
incomplete, partially incorrect and volatile. They aim to provide a process which
can operate successfully within such an environment. Modeling is seen
largely as a tool used to facilitate domain exploration and simplification
of the solution whilst the primary output of the process is working code.

Model-driven development (MDD)
\cite{stahl:mdsd, france:mddUsingUml2} has been
influenced by both, formal \cite{oquendo:modelDrivenFormalMethod}
and agile \cite{lazar:agileMdaForSoa, solms:generatingMdasPimUsingUrdad}
methods. The formal approach is
required for model transformation and code generation. The agile aspect
is important for business and system agility, i.e.\ to cost effectively
address requirements evolution. 

The OMG's vision of MDD is MDA \cite{siegel:developingInMDA}.
It is supported by an elaborate technology suite including support for modeling
via the Unified Modeling Language (UML), meta language specification via the
Meta-Object Facility (MOF), object constraint language (OCL) and
the Query-View Transformations (QVT) specification for querying and
transforming models. MDA aims to provide a level of agility whilst being
sufficiently formal to be able to automate large parts of the implementation 
mapping \cite{***TODO***}
by enabling domain experts to perform a semi-formal analysis and design
in UML which can then be incrementally formalized through model refinement
and the use of OCL.


The value obtained from MDA based projects has been limited by
\cite{solms:generatingMdasPimUsingUrdad}
\begin{itemize}
  \item the lack of standards for specifying the implementation architecture and technologies,
  \item the lack of an well-defined analysis and design methodology used to generate
the platform independent model (PIM), and thirdly by
  \item the wide variation in model structure and content permitted by the UML, increasing
the complexity of the implementation mapping.
\end{itemize}

***TODO*** Various attempts have been made to both simplify and increase the formality of UML models by
restricting the number of diagrams and UML elements used 
\cite{Cheng:integratingInformalAndFormalApproachesToRequirementsModelingAndAnalysis}

URDAD aims to address the latter two by providing
\begin{itemize}
  \item a step-for-step algorithm for performing technology-neutral analysis and design, with defined inputs and outputs for each
step, and
  \item restricting the use of UML constructs to a small but sufficient subset of UML, and enforcing a specific model structure with specified model elements (via a set of OCL-based model validation suites.)
\end{itemize}


In this paper we point out the semi-formal aspects of URDAD facilitating model validation,
automated generation of functional testing, documentation generation and simplified implementation mapping as well as aspects of an URDAD model and approach which improve agility.
