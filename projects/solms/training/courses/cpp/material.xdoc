<?xml version="1.0" encoding="UTF-8"?>

 <article id="projects.solms.training.courses.cpp.material"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:noNamespaceSchemaLocation="http://www.solms.co.za/schemas/doc/solmsDoc/solmsDoc.xsd" 
         xmlns:xi="http://www.w3.org/2001/XInclude">

    <section role="chapter">
      <title> Introduction to Object-Oriented Programming in C++</title>
      <section>
        <title> Objects and Classes</title>
        <para> In object-oriented programming the central concept is obviously an object. Let us
          first clarify the concepts of objects and classes, before going into the C++ language
          syntax for defining classes adn creating and using objects.</para>
        <para/>
        <section>
          <title> What is an Object?</title>
          <para> The central concept of object-oriented programming is an object. An object is a
            unit which </para>
          <itemizedlist>
            <listitem>
              <para>has identity, </para>
            </listitem>
            <listitem>
              <para>has attributes and </para>
            </listitem>
            <listitem>
              <para>can perform operations.</para>
            </listitem>
          </itemizedlist>
          <para> We think object-oriented. When we use a nouns in a sentence structure we generally
            refer to objects. For example, </para>
          <blockquote role="centerline">
            <title/> "The green car drives along the lane." </blockquote>
          <para> Here the nouns, car and lane, are objects. The objects have attributes, i.e. the
            car is green, and can perform operations, &#x0131;.e. the car drives. Hence, object
            orientation is not an unfamiliar concept in human thought -- it is our natural way of thinking.</para>
          <para/>
        </section>
        <section>
          <title> Identifying Objects</title>
          <para> We have already mentioned one way to identify objects. That is by extracting the
            nouns from a linguistic description of the system we are modeling. Otherwise we can try
            and identify units which have a clear conceptual meaning and which can be assigned an
            identity which makes them unique. Typically these units would have attributes and
            typically they can conceptually perform certain operations, i.e. it is natural to give
            thjem responsibilities for certain tasks.</para>
          <para> Another approach is to think of a system and identify its components. Each of the
            components would be an object in their own right. In this way you can go on to deeper
            and deeper levels of components.</para>
          <para> Alternatively you can look at an object and identify any messages it sends in order
            to request certain services (i.e. identify the recipients of the function calls). The
            recipients of these messages would themselves be objects.</para>
          <para/>
        </section>
        <section>
          <title> Classes as Abstractions of Objects</title>
          <para> A class is a template from which objects are created. It encapsulates the
            commonalities of all instances (objects) of that class. Objects are instances of classes.</para>
          <para> A class defines the attribute types as well as the operations (services) which its
            instances have. For example, an account may have an account number, a reference to an
            owner, a balance and may offer services for crediting, debiting and querying the
            balance. A particular account is an instance of the class. The class itself is a more
            abstract concept. One can discuss features of the class of accounts which apply to all
            account instances.</para>
          <para/>
        </section>
      </section>
      <section>
        <title> Defining Classes</title>
        <para> A class is a template from which objects are generated. Conceptually one defines in a
          class the commonalities (common attributes and services) of the instances of the class.</para>
        <para/>
        <section>
          <title> A Simple Account Class </title>
          <para> Below we show a simple account class which specifies that instances of that class
            can be credited and debited and that the balance can be queried:</para>
          <para/><![CDATA[
 class Account
 {
   public:
     void credit(double amount) {_balance += amount;}
     void debit(double amount) {_balance -= amount;}
     double balance() {return _balance;}
 
   private:
     double _balance;
 };
 
 #include <iostream>
 
 using namespace std;
 
 int main()
 {
   Account acc1;
   cout << "balance = " << acc1.balance() << endl;
 
   acc1.credit(10000);
   cout << "balance = " << acc1.balance() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para/>
        </section>
        <section>
          <title> Methods/Services</title>
          <para> A Method interface or header specifies how users can interface with the method,
            i.e. how to call the method. The interface of a method is defined by the name of the
            method, the argument types and the type of the return value if any. The syntax for a
            method interface definition is</para>
          <para/><![CDATA[
 <ReturnType> <methodName>(Argument1Type arg1Name, Argumet2Type arg2Name, ...)
]]><para/>
          <section>
            <title> Method names</title>
            <para> The method name should start with a lower case letter with word boundaries
              capitalized. Otherwise the same rules hold as those for all other identifier names
              (see section ??).</para>
            <para/>
          </section>
        </section>
        <section>
          <title> Access levels</title>
          <para> For the time being we shall look at only two access levels,
            <literal>public</literal> and <literal>private</literal>. The former specifies that a
            class member is publically accessible from anywhere. The latter specifies that a member
            can only be accessed from within the class itself. We shall return to the issue of
            access levels in section ??.</para>
          <para> In C++ an access level is specified for a blocks. The access level applies for all
            consecutive elements until it is changed.</para>
          <para/><![CDATA[
 class Account
 {
   public:
      void debit(double amount);
      void credit(double amount);
      ...
 
   private:
     double balance;
 };
]]><para/>
          <section>
            <title> Encapsulation</title>
            <para> The <literal>public</literal> elements of a class are those which are meant for
              general use. They typically include the public services offered by instances of the class.</para>
            <para> All the implementation details should be encapsulated within the class, i.e.
              should not be visible from outside the class. This ensures that users of the class
              don't develop dependencies on these implementation details.</para>
            <para> Consider the following scenario: Assume you wrote a <literal>Date</literal> class
              with 3 public data fields:
              </para><![CDATA[
 class Date
 {
   public:
     increment();
     addDays(int numDays);
     ...
 
   public:
     int day, month, year;
 };
]]><para>
              Of course, the <literal>increment()</literal> and <literal>addDays(numDays)</literal>
              methods are non-trivial, having to check for end-of-year, end-of-month and potentially
              for leap years and after using significant amounts of code of the form</para>
            <para/><![CDATA[
 for (Date d = d1; d<d2; d.increment())
    ...;
]]><para>it may seem
              an excessive burden to do all this work for every increment. At some stage you might
              come to the conclusion that your for-father's idea of using the earth's rotation
              around its own axis, the moon and the earth's rotation around the sun as reference was
              not such a good idea after all and you may decide to work with days in some new units.
              Keeping still the earth's rotation around it's own axis, you may decide to store a
              date as an absolute date, choosing your favourite date (e.g. the first time you came
              home after midnight and youre parents actually accepted it) as day number 1 and
              counting days sequentially. After 2 years you'll reach day 730 and you were born on
              day -5475. Now, incrementing and decrementing dates or adding a number of days to a
              date and many other functions become trivial and the only time you are faced with any
              of the old complexity is when you have to convert between your snazy internal units
              and the archaic day, month, year units of your for-fathers.</para>
            <para> If your data fields (day, month, year) had been declared private to start off
              with, you could simply make the implementation changes to your class and that would be
              it. If, on the other hand, they were declared public, they may be accessed from any
              other code distributed throughout your organization and you would have to search for
              sny such code and make the corresponding changes there.</para>
            <para> Furthermore, you cannot guarantee the integrity of instances of your class if you
              give public access to your data fields. Anybody could go ahead and set the month to
              27, bypassing any form of sanity checking you may havein your set-methods.</para>
            <para/>
          </section>
        </section>
        <section>
          <title> Constructors </title>
          <para> Constructors are used to construct (create) instances of classes -- i.e. objects. A
            constructor has the name of the class and no return value -- not even
            <literal>void</literal>. You can give a constructor as many arguments as you like and
            you can write multiple constructors, each with different arguments. Below we added two
            constructors to our account class. The first one takes no arguments (the default
            constructor) and the second one takes the initial balance as argument.</para>
          <para/><![CDATA[
 class Account
 {
   public:
     Account(): _balance(50) {}
 
     Account(double balance)
     {
       _balance = balance;
     }
 
     void credit(double amount) {_balance += amount;}
     void debit(double amount) {_balance -= amount;}
     double balance() {return _balance;}
 
   private:
     double _balance;
 };
 
 #include <iostream>
 
 using namespace std;
 
 int main()
 {
   Account acc1;
   Account acc2(200);
 
   cout << "acc1 balance = " << acc1.balance() << endl;
   cout << "acc2 balance = " << acc2.balance() << endl;
 
   acc1.credit(400);
   acc1.debit(123.45);
 
   acc2.debit(456);
 
   cout << "balance = " << acc1.balance() << endl;
   cout << "acc2 balance = " << acc2.balance() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para/>
          <section>
            <title> Member Initialization via the Constructor's Parameter List</title>
            <para> In the second constructor the private data field, <literal>_balance</literal>,
              was initialized within the body of the constructor. Alternatively we could have
              initioalized the private data field from the argument in the parameter list like this:</para>

            <para/><![CDATA[
 class Account
 {
   public:
     ...
 
     Account(double balance): _balance(balance) {}
     ...
 }
]]><para>
              This is effectively done in the first, the default constructor. If a new account is
              created it is automatically credited by 50 whatevers.</para>
            <para/>
          </section>
          <section>
            <title> Compiler-Generated Default Constructor</title>
            <para> Recall that in our earlier <literal>Account</literal> class example (see section
              ??) we did not define a constructor at all. Yest, we were able to create accounts via</para>
            <para/><![CDATA[
 Account acc1;
]]><para> How was this possible? The compiler wrote a
              default constructor -- one which takes no arguments and has an empty body -- for us.
              However, if we had added a constructor which takes arguments (e.g. the one which takes
              the initial balance as argument) without adding a default constructor, we can no
              longer create an account in this way:</para>

            <para/><![CDATA[
 class Account
 {
   public:
     Account(double balance)
     {
       _balance = balance;
     }
 
     void credit(double amount) {_balance += amount;}
     void debit(double amount) {_balance -= amount;}
     double balance() {return _balance;}
 
   private:
     double _balance;
 };
 
 #include <iostream>
 
 using namespace std;
 
 int main()
 {
   Account acc1;  // CAUSES COMPILER ERROR:
                  // Could not find Account::Account()
   return 0;
 }
]]><para>
              The reason for this is that C++ (like Java) creates a default constructor for you if
              and only if you did not define any constructor whatsoever for your class. In general
              you should write your own default constructor if you want a default constructor and
              disable it if you don't. If you want a class without any constructor whatsoever, you
              can define a <literal>private</literal> default constructor.</para>
            <para/>
          </section>
        </section>
        <section>
          <title> The OO Naming Convention</title>
          <para> We have adhered to the OO naming convention which is very simple, clean and
            effective. It is used throughout the C++ community (except in the Microsoft community),
            in Java, Smalltalk and UML (the Unified Modeling Language) and simply states: </para>
          <itemizedlist>
            <listitem>
              <para>Class names start with capital letter. Word boundaries are capitalized. </para>
            </listitem>
            <listitem>
              <para>Everything else (variable names, method names, function names and object names)
                start with lower case letter. Word boundaries are still capitalized.</para>
            </listitem>
          </itemizedlist>
          <para/>
        </section>
      </section>
      <section>
        <title> Requesting services from objects</title>
        <para> In section ?? we requested several services from different accpount instances
          (objects). In object-orientation one requests a service from an object by sending a
          message to it. One does not call a function -- we shall see later that the client often
          does not know which actual function is called.</para>
        <para> To send a message to an object one uses the member selection operator, the dot. For
          example, if we want to send a message to an account asking for the balance we can do it as follows:</para>
        <para/><![CDATA[
 double bal = acc1.balance();
]]><para> Similarly, if we want to debit that
          same account, we can send a debit message:</para>
        <para/><![CDATA[
 double bal = acc1.debit(500);
]]><para/>
      </section>
      <section>
        <title> The Life-Span of an Object on the Stack</title>
        <para> So far we have created objects on the stack, i.e. they life in the same stack frame
          as other local variables. An object on the stack then also has a life span similar to that
          of local variables. It exists from where it is declared until the end of the block (the
          closing curly bracket) in which it is declared.</para>
        <para/>
        <section>
          <title> Destructors</title>
          <para> Destructors are called when the object is deleted. Destructors are responsible for
            releasing any memory which the class grabbed from the heap as well as releasing other
            resources like closing files or network sockets. We shall see that when objects are
            created on the heap, the destructor has to be called manually. However, for objects
            which have been created on the stack, the destructor is called automatically.</para>
          <para> Like constructors, the destructor also carries the name of the class, but it is
            preceded by a tilda and it may not have any arguments. The following example shows a
            destructor which simply laments the death of an object and illustrates how the
            destructor is called automatically as the object leaves its scope.</para>

          <para/><![CDATA[
 #include <iostream>
 
 using namespace std;
 
 class Account
 {
   public:
     Account(): _balance(50) {}
 
     Account(double balance)
     {
       _balance = balance;
     }
 
     ~Account()
     {
       cout << "I, " << this << ", am destroyed." << endl;
     }
 
     void credit(double amount) {_balance += amount;}
     void debit(double amount) {_balance -= amount;}
     double balance() {return _balance;}
 
   private:
     double _balance;
 };
 
 void f()
 {
   cout << "Entered f()." << endl;
   Account account;
   account.credit(1e6);
   cout << "About to leave f()" << endl;
 }
 
 int main()
 {
   f();
 
   Account acc1;
   cout << "Created acc1, entering block." << endl;
   {
     Account acc2;
     cout << "Created acc2 in block,leaving block." << endl;
   }
 

   char c; cin >> c;
 
   return 0;
 }
]]><para>
            The output of the application looks something like this:</para>
          <para/><![CDATA[
 Entered f().
 About to leave f()
 I, 0012FF44, am destroyed.
 Created acc1, entering block.
 Created acc2 in block,leaving block.
 I, 0012FF7C, am destroyed.
]]><para/>
        </section>
      </section>
      <section>
        <title> Splitting Headers and Implementation</title>
        <para> Naturally one does not want to define all code (classes and functions) within a
          single source file. Furthermore, one does not want to recompile the entire source if one
          makes a modification to a specific area of the source.</para>
        <para> To this end C++ enables you to define the header of a class which contains the method
          headers and the data fields of a class separate from the implementation code of these
          methods. For example, we can define the header of the verb+Account+ class in a
          file<literal>Account.h</literal> and its method implementations in a file called <literal>Account.cpp</literal>.</para>
        <para/>
        <section>
          <title> The Header File</title>
          <para> The header file defines the method headers without the method bodies. Below we list
            a C++ header file for our account class:</para>

          <para/><![CDATA[
 #ifndef AccountH
 #define AccountH
 
 class Account
 {
   public:
     Account();
     Account(double initialBalance);
 
     ~Account();
 
     void credit(double amount);
     void debit(double amount);
 
     double balance();
 
   private:
     double _balance;
 };
 
 #endif
]]><para>
            Note that macros are used to avoid duplicate inclusion of the header file. A macro
            variable, <literal>ACCOUNT_H</literal> is defined the first time the file is read. The
            contents of the header file is only included if the variable has not yet been defined
            within the compilation process.</para>
          <para/>
        </section>
        <section>
          <title> The Implementation File</title>
          <para> The implementation file defines the method bodies of the methods whose header is
            specified in the header file. Since header and implementation files may contain multiple
            classes, the scope of the function must be specified. For example</para>
          <para/><![CDATA[
 Account::debit(double amount) {_balance -= amount;}
]]><para>defines the
            body of the <literal>debit</literal> method of the <literal>Account</literal> class. Similarly,</para>
          <para/><![CDATA[
 Account::Account(): _balance(50) {}
]]><para>defines the implementation
            of the default constructor. The complete implementation file is listed below:</para>
          <para/><![CDATA[
 #include "Account.h"
 #include <iostream>
 
 using namespace std;
 
 Account::Account() : _balance(50) {}
 
 Account::Account(double initialBalance)
   : _balance(initialBalance) {}
 
 Account::~Account()
 {
   cout << "I, " << this << ", am destroyed." << endl;
 }
 
 void Account::credit(double amount)
 {
   _balance += amount;
 }
 
 void Account::debit(double amount)
 {
   _balance -= amount;
 }
 
 double Account::balance() {return _balance;}
]]><para/>
        </section>
        <section>
          <title> Including Header Files</title>
          <para> C++ supports tw notations for including header files -- they may be either
            specified within tag delimiters or within quotes. The former refers to header files
            which can be located along the system path while the latter notation is used for files
            which are located relative to the current directory (using relative paths) or at
            specified locations (using absolute paths).</para>
          <para> Our main program includes the <literal>Account.h</literal> header file as well as
            some system header files:</para>
          <para/><![CDATA[
 #include <iostream>
 #include "Account.h"
 
 using namespace std;
 
 int main()
 {
   Account acc1;
   Account acc2(1000);
 
   acc1.credit(250);
   acc2.debit(100);
 
   cout << "balance of acc1: " << acc1.balance() << endl;
   cout << "balance of acc2: " << acc2.balance() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
 
]]><para/>
        </section>
      </section>
      <section>
        <title> Creating Objects on the Heap</title>
        <para> So far we created objects on the stack. The objects were scoped to within a block,
          often a function body (e.g. <literal>main</literal>) and are stored within the stack frame
          of that object. Objects which have been declared on the stack are automatically deleted
          when they go out of scope.</para>
        <para> However, the stack is a limited resource. Furthermore, one often requires objects to
          survive the scope in which they have been created. More often than not, one would want to
          create objects on the heap. This requires, however, that the developer has to control the
          memory management of the object and that introduces considerable risks in terms of
          potential memory losses as well as dangling pointers. The latter happens if an object is
          deleted while another part of the application still has a pointer to it. At a later stage
          this pointer could be used resulting in system corruption or system crash.</para>
        <para> This problem is non-trivial -- so much so that many commercial C++ applications end
          up with memory leaks. In fact, there is a market for C++ memory leak detector tools. From
          a more purist perspective the memory management is best tackled through a solid design
          (perhaps using UML) whereeach object has ultimately one owner who takes over the memory
          and pointer management for that object.</para>
        <para> Objects are created on the heap via the new operator. They are deleted via the delete
          operator which ultimately calls the destructor. Below is an application which creates a
          collection of accounts on the heap, sends them through to a function and finally deletes them:</para>
        <para/><![CDATA[
 #include <iostream>
 #include "Account.h"
 
 using namespace std;
 
 void debitServiceFees(Account* acc)
 {
   acc->debit(45);
 }
 
 void run()
 {
   int numAccounts = 5;
   Account** accounts = new Account*[numAccounts];
 
   for(int i=0; i<numAccounts; ++i)
     accounts[i] = new Account();
 
   for(int i=0; i<numAccounts; ++i)
     debitServiceFees(accounts[i]);
 
   // Because the accounts were created on the heap,
   // they have to be deleted manually:
   for(int i=0; i<numAccounts; ++i)
     delete accounts[i];
   delete[] accounts;
 }
 
 int main()
 {
   run();
 
   char c; cin >> c;
 
   return 0;
 }
]]><para/>
      </section>
      <section>
        <title> Class Members</title>
        <para> So far most of the members we added to our classes (methods and data fields) were
          instance members. For example, each instance of the account class had its own
          <literal>_balance</literal> and when we requested the <literal>debit(double)</literal>,
          <literal>credit(double)</literal> or the <literal>balance()</literal> query service, we
          sent the message to a specific instance (object):</para>
        <para/><![CDATA[
 account1.credit(550);
 
 cout << account1.balance();
]]><para> The only
          members which were class members thus far were the constructors. They had the name of the
          class and where implicitely class services. When we create an account we requested the
          service from the <literal>Account</literal> class and not a specific instance of the class
          -- a particular account.</para>
        <para> At times one wants to assign also other responsibilities to the class itself. For
          example, we may want to keep track of the number of instances of the account class. This
          responsibility does not fit naturally within a specific instance of the class. Instead, we
          might want to assign this responsibility to the class itself -- after all, the class is
          responsible for creating instances (if one uses a factory pattern, the responsibility is
          naturally hosted by the factory).</para>
        <para> In C++, as in Java, one uses the keyword <literal>static</literal> to specify that a
          specific element is a class member. For example, we may want to assign a datafield
          <literal>_numInstances</literal> to the class as well as a query service,
          <literal>numInstances()</literal>. We would declare both these members
          <literal>static</literal>, i.e. class members. Below we show the header file of a
          <literal>Client</literal> class which keeps track of the number of instances of that class:</para>

        <para/><![CDATA[
 // Client.h
 //
 #ifndef Client_H
 #define Client_H
 class Client
 {
   public:
     Client(char* name);
 
     ~Client();
 
     static int numInstances();
 
   private:
     char* _name;
     static int _numInstances;
 };
 #endif
]]><para>
          Nte that the class itself hosts a data field, <literal>_numInstances</literal>, which can
          be accessed from within the class scope or from the within the scope of any particular
          instance of the <literal>Cient</literal> class.</para>
        <para/>
        <section>
          <title> Constructors are Class Services</title>
          <para> One uses the keyword <literal>static</literal> to specify class services and
            datafields of the class. However, constructors themselves are also class services -- one
            asks the <literal>Client</literal> class for an instance, not a particular account
            (there may not even be an account instance around yet). So constructors are implicitly
            static methods.</para>
          <para> In our constructor we added a line which increments the instance counter:</para>
          <para/><![CDATA[
 Client::Client(char* name)
 {
   ++_numInstances;
   _name = name;
 }
]]><para/>
        </section>
        <section>
          <title> Destructors are Instance Services</title>
          <para> Destructors are not class services. Their resposibility is to provide some
            finalization code (e.g. clean-up code) when an object (a particular instance) is
            deleted. The message is sent to a specific <literal>Client</literal>. Still, the
            instance counter should be decremented:</para>
          <para/><![CDATA[
 Client::~Client()
 {
   --_numInstances;
 }
]]><para> Note that class
            members can be directly accessed from within instance members (like the destructor), but
            not vice versa.</para>
          <para/>
        </section>
        <section>
          <title> Specifying Implementation Details of Class Members</title>
          <para> The body of a static method is defined in the same way as the body of an instance
            method. Naturally, one cannot access instance members from a class service. After all
            the scope is the class itself -- which instance should it refer to. Below we show the
            trivial implementation of the <literal>numInstances()</literal> query method:</para>
          <para/><![CDATA[
 Client::numInstances()
 {
   return _numInstances;
 }
]]><para> We still
            have to initialize the class member, <literal>_numInstances</literal> to zero. But were
            should we do that? We cannot initialize the data field in the constructor because then
            the field would be initialized every time an instance is created. We want to do once off
            initialization when the application is loaded. This initializtion statement is done at
            global scope via:</para>
          <para/><![CDATA[
 int Client::_numInstances = 0;
]]><para> The full implementation file,
            <literal>Client.cpp</literal> is listed below:</para>
          <para/><![CDATA[
 // Client.cpp
 //
 #include "Client.h"
 
 Client::Client(char* name)
 {
   ++_numInstances;
   _name = name;
 }
 
 Client::~Client()
 {
   --_numInstances;
 }
 
 int Client::numInstances()
 {
   return _numInstances;
 }
 
 int Client::_numInstances = 0;
]]><para/>
        </section>
        <section>
          <title> Using Class Members</title>
          <para> Off course, we have used some of them already -- the cnstructors. Below we show an
            example application which creates a few accounts, uses them and then deletes them. In
            between we ask the class now and then to report the number of instances which currently
            exist for the class:</para>
          <para/><![CDATA[
 // ClientTest.cpp.h
 //
 #include <iostream>
 #include "Client.h"
 
 using namespace std;
 
 int main()
 {
   Client* c1 = new Client("Peter");
   Client* c2 = new Client("Jill");
 
   cout << "numClients = " << Client::numInstances() << endl;
 
   delete c1;
 
   cout << "numClients = " << Client::numInstances() << endl;
 
   delete c2;
 
   cout << "numClients = " << Client::numInstances() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Exercises</title>
        <para/>
        <orderedlist>
          <listitem>
            <para>Write a Parabola class whose instances have specific values for the 2'nd, 1'st and
              0'th order coeffcients, <informalequation>
                <graphic fileref="cpp69x.gif"/>
              </informalequation>, <informalequation>
                <graphic fileref="cpp70x.gif"/>
              </informalequation> and <informalequation>
                <graphic fileref="cpp71x.gif"/>
              </informalequation>. The parabola should offer services for calculating the turning
              point and roots of the class as well as for calculating the function value for any
              given <informalequation>
                <graphic fileref="cpp72x.gif"/>
              </informalequation>-value. Separate the header from the implementation file. </para>
          </listitem>
          <listitem>
            <para>Write a simple stack class (you may want to use a singly-linked list as underlying
              collection algorithm) which holds a collection of Parabolas. You should be able to
              push Parabolas onto the stack and be able to pop the off the stack. All objects should
              be created n the heap and you shuld take care that the application is save from memory leaks.</para>
          </listitem>
        </orderedlist>
        <para/>
        <para/>
      </section>
    </section>
    <!--end chapter-->
    <section role="chapter">
      <title> Abstract Data Types: Rational Numbers </title>
      <para> In this chapter we going to use C++ classes to build a complete abstract data type for
        rational numbers. An abstract data type (a class in C++) defines not only the data
        representation (e.g. that a rational number consists of two integral numbers, one of which
        is the numerator, the other the denominator), but also the operations which can be performed
        on this data type (e.g. how to add two rational numbers, how a rational number is to be
        displayed on an output stream or how it is incremented). By defining a class
        <literal>Rational</literal> we want to be able to extend the C++ programming environment in
        such a way that rational numbers can be used seemlessly -- as if they were built in data
        types like <literal>int</literal> or <literal>double</literal>. We want to be able to write
        programs like
        </para><![CDATA[
 #include <iostream>
 #include "Rational.h"
 
 using namespace std;
 
 int main()
 {
   Rational r1, r2;
 
   cout << "Enter rational number (numerator denominator): r1 = ";
   cin  >> r1;
   cout << "r1 = ";
   cin  >> r2;
 
   Rational r3 = r1 + r2;
   Rational r4 = r1 * r2;
 
   cout << "r1 + r2 = " << r3 << endl;
   cout << "r1 * r2 = " << r4 << endl;
 
   return 0;
 }
]]><para>
        Adding two rational numbers is of course quite different from adding two integers or two
        floating point variables. For example, <informalequation>
          <graphic fileref="cpp73x.gif"/>
        </informalequation> should yield <informalequation>
          <graphic fileref="cpp74x.gif"/>
        </informalequation>.</para>
      <para> To achieve the above we must define a class with its data members (the numerator and
        the denominator). We must be able to create instances of the class
        <literal>Rational</literal> -- i.e. to define variables of type <literal>Rational</literal>.
        This is achieved by the constructors of the class. Furthermore, we have to define the
        various operators like <literal>+</literal> or <literal>*</literal> as well as the output
        stream operator <literal><![CDATA[<<]]></literal> and the stream extraction operator
        <literal>&gt;&gt;</literal>. We can even define what the assignment operator
        <literal>=</literal> should do and how type conversion between rational numbers and say
        floating point numbers should be done. </para>
      <section>
        <title> Private and public data members</title>
        <para> A class defines both, the data members of an abstract data type and the operations
          (methods) which can be performed on the data type. Following the encapsulation objective
          of object-oriented programming, we want to hide the underlying data structures from the
          user. This has several advantages. Firstly, the data fields are protected from direct
          manipulation by restricting the access to the predefined methods (and operators) of the
          class. This can ensure, among other things, data integrity. For example, if a user could
          manipulate the data fields of rational numbers directly, he would be able to set the
          denominator equal to zero, creating an invalid rational number. Data hiding is achieved by
          declaring the relevant data elements as private members of the class:
          </para><![CDATA[
 class Rational
 {
     ...
   private:
     int _numer, _denom;
 }
]]><para>
          This ensures that the variables, <literal>_numer</literal> and <literal>_denom</literal>,
          can only be accessed from within the class -- from within one of the methods (functions)
          of the class (we use the convention of trailing the variable name with an underscore for
          private data members of a class). Note that a class is defined by the keyword
          <literal>class</literal> followed by the name of the class and then, within curly
          brackets, we define the data elements and the functionality (class methods). In the above
          example we only defined the two data elements.</para>
        <para> The second advantage of data hiding (encapsulation) is that at any stage the
          underlying data structures can be altered without affecting the program which use the
          class. For example, we would soon realize that the above definition would often result in
          the denominator overflowing. You might then want to change <literal>int</literal> to
          <literal>long</literal> or possibly even to a user-defined data type
          <literal>VeryLongInt</literal>. We can make these changes without altering the
          user-interface and hence the programs which use this class will not be affected (avoiding
          the traditional maintenance nightmare of searching through huge amount of code for
          occurrences of numerators and denominators and changing their data type).</para>
        <para> Public data members can be accessed directly by the user and should hardly ever be
          used. If we had declared the numerator and the denominator public data members
          </para><![CDATA[
 class Rational
 {
     ...
   public:
     int _numer, _denom;
 }
]]><para>
          then the user could manipulate them directly. He could, for example, set the denominator
          equal to zero: </para><![CDATA[
 void main()
 {
   Rational<int> r(1,3);
   ...
   r._denom = 0;
 }
]]><para/>
      </section>
      <section>
        <title> Template classes</title>
        <para> In chapter ?? we used function templates (generic or parametrized functions) to
          define a whole family of related functions (one corresponding to each required template type).</para>
        <para> Analogously we can define classes on a template to create parametrized or generic
          data types. Vectors and matrices would typically be defined on a template so that we can
          use the same code to define a vector of integers, double precision numbers or even of a
          user defined type like a vector of rational numbers.
          </para><![CDATA[
 void main()
 {
   Vector<double> vd1, vd2;
   Vector<Rational> vr1, vr2, vr3;
   ...
   Vector<double> vd3 = vd1 - vd2;
   ...
   vr1 = vr2 + vr3;
 }
]]><para>
          Similarly, we define rational numbers themselves on a template so that the user can create
          rational numbers where the numerators and denominators are stored as say either
          <literal>long</literal> or as the user-defined data type <literal>VeryLongInt</literal>.
          This is done as follows: </para><![CDATA[
 template <class T> class Rational
 {
     ...
   private:
     T _numer, _denom;
 }
 ...
 void main()
 {
   Rational<long> r1;
   Rational<VeryLongInt> r2;
   ...
 }
]]><para/>
      </section>
      <section>
        <title> Constructors </title>
        <para> Constructors enable the user to create objects (instances) of a certain class.
          Constructors are methods (functions) which carry the name of the class and have no return
          value. They can be overloaded like any other function, i.e. we can have several
          constructors with the same function name, but with different number and/or types of arguments.</para>
        <para/>
        <section>
          <title> Specifying Constructors</title>
          <para> Consider the following extract of the definition of the <literal>Rational</literal>
            class:
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     Rational ();
     Rational (const Rational<T>&amp; r);
     Rational (const T&amp; numer, const T&amp; denom);
     ...
   private:
     T _numer, _denom;
 }
]]><para>
            Note that all three constructors are defined in the public declaration block of the
            class. This ensures that they are all accessible from outside the class. The three
            constructors would be used in the following code:
            </para><![CDATA[
 void main()
 {
   Rational<int>  r1, r2;     // using default constructor
   Rational<int>  r3(r1);     // using copy constructor
   Rational<long> r4(17,23);  // creating and initializing a rational number
   ...
 }
]]><para>
            The first of the three constructors has no arguments. It is called the default
            constructor. Should you omit to define any constructor, your friendly C++ compiler will
            write one for you. The compiler-supplied version will have an empty function body (it
            will do nothing except reserve space for the data members of the class). As soon as you
            do define any constructor, the compiler will no longer write a default constructor for
            you. If you want one (and, as we shall see later, you will need one if you want to allow
            the user to define arrays of your class) you will have to write it yourself.</para>
          <para/>
        </section>
        <section>
          <title> Copy Constructors</title>
          <para> The second constructor is called the copy constructor. It takes an instance of the
            same class (in our case a rational number) as argument and creates a copy of it. Should
            you omit to define a copy constructor, the compiler will write one for you. The compiler
            version creates a byte for byte copy of all the data members of the class. In our case
            that would achieve what we want to achieve and we could simply use the compiler supplied
            version (instead of defining our own). This is, however, not always the case. As soon as
            the class uses dynamic memory allocations we are forced to write our own version for the
            copy constructor (or face disaster). The vector and matrix classes will use dynamic
            memory allocation and will illustrate this point.</para>
          <para> One should, however, be aware that the copy constructor is not only used in
            explicit variable declarations as above. Every time we pass a rational number by value
            (or when a function returns a rational number) the copy constructor is called
            implicitly. Consider, for example, the following function:
            </para><![CDATA[
 template<class T>
 Rational<T> Square (const Rational<T> r)
 {
   Rational<T> result = r*r;
   return result;
 }
]]><para>
            Here the copy constructor is used firstly to make a local copy of the variable,
            <literal>r</literal> and secondly, when the local variable <literal>result</literal> is
            returned by value (Note: never return a local variable by reference -- you are returning
            a handle to an object which no longer exists outside the function).</para>
          <para/>
        </section>
        <section>
          <title> Other Constructors</title>
          <para> The third constructor takes two arguments, the numerator and the denominator for
            the rational number to be created. It allows us to create and initialize a rational
            number to a certain value with a single function call.</para>
          <para> In the class definition given above we have only defined the function headers for
            the constructors. This part would typically be stored in a header file (e.g.
            RATIONAL.H). The implementation details (the function bodies) would then be stored in
            the accompanying CPP-file (RATIONAL.CPP). In this file we would define what the
            constructors (and the other member functions) actually do. Below we give the
            implementation details of the default constructor:
            </para><![CDATA[
 template<class T>
 Rational<T>::Rational ()
 {
   _numer = 0;
   _denom = 1;
 }
]]><para>
            Here the name of the function is <literal>Rational()</literal> and it has no arguments
            and no return value. The first line specifies that this function is defined on a
            template. We still have to specify that the function <literal>Rational()</literal>
            belongs to the class <literal><![CDATA[Rational<T>]]></literal>. This is done by
            preceding the function name with the class name followed by 2 colons. The function body
            is no different to any other function body. In this case it initializes the numerator
            and denominator to certain values. Note that the class variables are accessible by all
            class methods (functions).</para>
          <para/>
        </section>
        <section>
          <title> Implementing Constructors</title>
          <para> Instead of initializing class variables via assignment statements it is usually a
            good idea to initialize them via a parameter list. This is done as follows:
            </para><![CDATA[
 template<class T>
 Rational<T>::Rational(): _numer(0), _denom(1) {}
]]><para>
            After the function header we have a semicolon followed by the class member
            initializations. In this case both, the numerator and the denominator are initialized.
            The function body (between the curly brackets) is now empty. The advantage of this
            method is that if the numerator and denominator are objects (instances of other classes)
            then the objects are created and initialized with a single function call to the copy
            constructor. If we look at the implementation of the previous paragraph (where the class
            variables were initialized via assignment statements), we see that we have two function
            calls, one to the default constructor (before the body of the function is executed) and
            a second to the assignment operator. This of course is less effcient then the
            parameter-list initialization. Furthermore, as we shall see later, class constants and
            reference variables have to be initialized in the parameter list.</para>
          <para> The copy constructor should be defined such that it creates an exact copy of an
            object:
            </para><![CDATA[
 template<class T>
 Rational<T>::Rational (const Rational&amp; r):
     _numer(r._numer), _denom(r._denom) {}
]]><para>
            Recall that should you omit to define a copy constructor, the compiler will write one
            for you which makes a byte-for-byte copy of the data members. In rare cases one wants to
            prevent the user from making a copy of instances of a certain class. An example could be
            a task scheduler. At any moment there should only exist a single task scheduler. In this
            case one can define a function header for the copy constructor, without supplying any
            implementation details (function body). This will cause a compile-time error if the user
            attempts to make a copy of an object of that particular class (e.g. task scheduler).
            Note that it is always desirable to have compile-time errors rather than run-time errors.</para>
          <para> The implementation details of the third constructor are given below:
            </para><![CDATA[
 template <class T>
 Rational<T>::Rational (const T&amp; numer, const T&amp; denom)
                  : _numer(numer), _denom(denom)
 {
   #if EXCEPTIONHANDLING
     if (denom == 0)
       throw DivideByZero("Rational(numer,denom) => denom=0");
   #endif
   if (_denom < 0)
     {_numer = -_numer;  _denom = -_denom;}
   T common = gcd(_numer, _denom);
   if (common > 1)
     {_numer /= common;  _denom /= common;}
 };
]]><para>
            We first check that the user does not try to create a rational number with zero
            denominator. If that is the case we throw a <literal>DivideByZero</literal> exception.
            In chapter ?? we develop a unified exception-handling class hierarchy which is used
            throughout the entire C++ class library supplied with this book. We use a compiler
            directive to control conditional compilation. In the exception-handling library defined
            in the file<literal>ErrHandl.h</literal>, we define a global constant
            <literal>EXCEPTIONHANDLING</literal> which is set by the user to either 1 or 0 depending
            on whether he wants to use exception handling or not. Using exception-handling is of
            course safer, but it is also slower. Typically one would use exception handling during
            the development and debugging stages of software development and one would switch it off
            once the code is known to be error-free. We use this exception handling mechanism here
            and the reader is not expected to understand it at this stage. It will be covered in
            detail in chapter ??.</para>
          <para> We make certain that the denominator is always positive and we check whether the
            numerator and denominator have a common divisor which is greater than 1. If this is the
            case, both are divided by this common divisor. Hence, if we create a rational number <informalequation>
              <graphic fileref="cpp75x.gif"/>
            </informalequation>, then it will be immediately simplified to <informalequation>
              <graphic fileref="cpp76x.gif"/>
            </informalequation>. The common divisor is calculated by a private member function
            <literal>gcd()</literal> which is discussed in the following section.</para>
          <para/>
        </section>
      </section>
      <section>
        <title> Member functions</title>
        <para> Class methods (member functions) describe the activities which can be performed by
          instances (objects) of that class. Furthermore, usually they allow controlled access to
          the data fields of the object. In C++ one usually distinguishes between member functions
          and class operators.</para>
        <para> One further distinguishes between constant member functions which leave the members
          of an object unaltered, and non-constant member functions which alter members of an
          object. For constant member functions one appends the keyword <literal>const</literal> to
          the function header. This tells the compiler (and the user) that this particular member
          function leaves the state of the object unaltered and any attempt to change its state
          (change one of its data members) results in a compile-time error. Consider the following
          extract of the definition for the class<literal>Rational</literal>

        </para><![CDATA[
 template <class T> class Rational
 {
   public:
     Rational ();
     Rational (const Rational<T>&amp; r);
     Rational (const T&amp; numer, const T&amp; denom);
 
     T numerator   () const;
     T denominator () const;
 
     Rational<T>   power (const long)   const;
     double power (const double) const;
     ...
   private:
     T _numer, _denom;
 }
]]><para>
          Here we defined four constant member functions, two of which are query functions (they
          query the state of the object). The implementation section for the two query functions is
          trivial. For example
          </para><![CDATA[
 template <class T>
 inline T Rational<T>::numerator () const {return _numer;};
]]><para>
          The private data member is simply returned by value. Note that if we would return a
          private data member by reference we would give the user a handle to directly manipulate
          it, thereby destroying encapsulation. The function is very short and it would be wasteful
          to incur the overheads of a function call. Hence we declare the function
          <literal>inline</literal>. Note that the <literal>inline</literal> specification trails
          the function header in the implementation section -- this implementation detail is not
          specified in the class interface.</para>
        <para> The implementation of the member function power taking a <literal>double</literal> as
          an argument is given below
          </para><![CDATA[
 template <class T>
 inline double Rational<T>::power (const double y) const
 {
   double x = (double)_numer/(double)_denom;
   return pow(x,y);
 }
]]><para>
          Note that this function leaves the data members of the class, <literal>_numer</literal>
          and <literal>_denom</literal>, unaltered. It converts the rational number into a
          <literal>double</literal> and then uses the <literal>pow(double, double)</literal>
          function of the C++ math library.</para>
        <para> The implementation of the power method taking a <literal>long</literal> as an
          argument is a lot more involved and will be discussed in section ??.</para>
        <para/>
        <section>
          <title> Public versus private member functions</title>
          <para> Analogous to data members, one can define member functions (and for that matter
            class operators) as either public or private. Those member functions which the user
            should be able to use to manipulate an object or to prompt an object to perform a
            certain action should be declared <literal>public</literal>. Those member functions
            which are only for internal usage should be defined in the private block. The member
            functions we have defined so far were all public member functions.</para>
          <para> For internal usage we need a member function, <literal>gcd</literal>, which
            calculates the greatest common divisor between two integral numbers of the template type
            <literal>T</literal>. We declare this member function private:
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
   private:
     T _numer, _denom;
     T gcd (T a, T b) const;
 }
]]><para>
            The implementation details for this private class method are given below </para><![CDATA[
 template <class T>
 T Rational<T>::gcd (T a, T b) const
 {
   if (a < 0) a = -a;
   if (b < 0) b = -b;
 
   while (b > 0)
   {
     T m = a % b;
     a = b;
     b = m;
   }
   return a;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Class operators</title>
        <para> In order to mimic the behavior of the built in data types like <literal>int</literal>
          or <literal>double</literal>, C++ allows one to define (overload) the built in operators
          for ones own data types. For example, if we have two rational numbers we would like to be
          able to use them in statements like </para><![CDATA[
   r3 = r2 + r1;
]]><para> where
          <literal>r1</literal>, <literal>r2</literal> and <literal>r3</literal> are all of type
          <literal><![CDATA[Rational<T>]]></literal> where <literal>T</literal> could be, for
          example, <literal>long</literal>. Of course we have to define what both, the addition
          operator and the assignment operator do.</para>
        <para> There are, however, some quite severe restrictions on operator overloading. Consider
            table<ulink url="#x1-150031">
            <!--ref: basiccppCppops-->
          </ulink> which lists the C++ operators in order of decreasing precedence. The precedence
          levels remains unaltered for the overloaded operators. Hence <literal>*</literal> always
          has precedence above <literal>+</literal>, irrespective of the data type (built-in or
          user-defined class). Table <ulink url="#x1-150031">
            <!--ref: basiccppCppops-->
          </ulink> also shows the syntax of the C++ operators. One cannot alter the syntax for
          overloaded operators.</para>
        <para/>
        <section>
          <title> Arithmetic operators</title>
          <para> The result of the addition of two rational numbers is obtained by</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp77x.gif" role="math-display"/>
            </informalequation> followed by a division by the greatest common divisor of the
            numerator and the denominator of the result.</para>
          <para> Operators can be overloaded like any other function -- we can define various
            versions of an operator, each taking different types and/or different numbers of
            arguments. Below we define two addition operators for the class of rational numbers:
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     Rational<T>  operator+  (const Rational<T>&amp; r) const;
     Rational<T>  operator+  (const T&amp; k)           const;
     ...
 }
]]><para>
            Note that the operators are really defined as functions with function name
            (<literal>operator+</literal>), arguments and a return value. From this one can see that
            C++ translates operators to function calls, i.e. <literal>r1+r2</literal> is implemented
            as the function call <literal>r1.operator+(r2)</literal>, i.e. the addition operator for
            object <literal>r1</literal> is called with argument <literal>r2</literal>. An analysis
            like this is very important if the objects on the two sides of a binary operator (e.g.
            assignment operator) are not of the same type. Consider for example
            </para><![CDATA[
 void main()
 {
   int m=17;
   Rational<int> r1(1,3), r2;
 
   r2 = r1 + m;
   r2 = m + r1;
 }
]]><para>
            In the first of the two addition statements is interpreted as
            <literal>r1.operator+(m)</literal> and since <literal>r1</literal> is an instance of the
            class <literal>Rational</literal>, the function
            </para><![CDATA[
 Rational<int>::operator+(const T&amp;)
]]><para>is called. In the
            second addition statements the compiler searches for
            </para><![CDATA[
 int::operator+(Rational<int>)
]]><para> But <literal>int</literal> is
            a built in data type (not even really a class) and no such operator is defined. In order
            to allow the user to form statements of the form of the second addition statement we
            have to define a global operator which takes as first argument a template type (say
            <literal>T</literal>) and as second argument a rational number
            <literal><![CDATA[Rational<T>]]></literal>. We discuss globally defined operators in the
            following section.</para>
          <para> The function body of the two addition operator defined above is given by
            </para><![CDATA[
 template <class T>
 inline Rational<T> Rational<T>::operator +
              (const Rational<T>&amp; r) const
 {
   return Rational<T>(_numer*r._denom
            + r._numer*_denom, _denom*r._denom);
 }
 
 template <class T>
 inline Rational<T> Rational<T>::operator +
              (const T&amp; k) const
 {
   return Rational<T>(_numer+k*_denom,_denom);
 }
]]><para>
            Note that we make an explicit call to the constructor which takes the numerator and the
            denominator as an argument, creates a new rational number accordingly. The constructor,
            which is discussed in section ?? simplifies the resultant rational number (by dividing
            numerator and denominator with a greatest common divisor). The rational number created
            with this constructor call is returned by value.</para>
          <para/>
        </section>
        <section>
          <title> Friends of a class and globally defined operators</title>
          <para> In order to allow the user to use constructs like
            </para><![CDATA[
 r2 = 17 + r1;
]]><para>we either have to define the addition operator
            </para><![CDATA[
 Rational<int> int::operator+(Rational<int>);
]]><para> (which we
            cannot do because <literal>int</literal> is a built-in data type) or we have to define a
            global addition operator which takes as first argument an integer and as second argument
            a rational number. Again we define the operator on a template so that the user can use
            either <literal>int</literal>,<literal>long</literal>, or a user-defined type like
            <literal>verylong</literal>. C++ has built in automatic type conversion between
            <literal>int</literal> and <literal>long</literal> and the developer of the class
            <literal>verylong</literal> should supply automatic conversion between his class and the
            built-in data types, <literal>int</literal> and <literal>long</literal>. We shall show
            in section ?? how this is done.</para>
          <para> Consider the following code extract
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     friend Rational<T> operator+ (const T&amp; k, const Rational<T>&amp; r);
     friend Rational<T> operator/ (const T&amp; k, const Rational<T>&amp; r);
     ...
 }
 
 template <class T>
 Rational<T> operator/ (const T&amp; k, const Rational<T>&amp; r)
 {return Rational<T>(r._denom*k,r._numer);}
 
 inline Rational<T> operator+ (const T&amp; k, const Rational<T>&amp; r)
 {return r+k;}
]]><para>
            Your friends know your private matters. Similarly friends of a class are functions or
            other classes which are not members of the class, but which have access to the private
            (and as we shall see later protected) members of the class.</para>
          <para> In the above example we define two global operators as a friends of the class. Note
            that the operators are not members of the class and hence they cannot be declared class constants.</para>
          <para> Consider now the implementations of the two operators. Since they are global
            functions -- not members of the class -- we do not have the class name followed by the
            scope resolution operator <literal>::</literal> in front of the operator name. The
            division operator uses directly the private data members <literal>_numer</literal> and
            <literal>_denom</literal> -- he can do so since he is a friend of the class. Again we
            call the constructor to create a local rational number which is initialized to the
            inverse of <literal>r</literal> multiplied with <literal>k</literal> and we return this
            locally defined rational number (which has no name) by value.</para>
          <para> Since addition is commutative, we simply reverse the statement and call the
            addition operator of the class which takes a variable of the template type as argument
            (see previous section). Both operators functions are declared <literal>inline</literal>
            so that we do not incur the overheads of a function call.</para>
          <para> The addition operator does not use any of the private members of the class -- we
            need not have defined it a friend of the class. We do so in order to have a neat
            interface for the<literal>Rational</literal> class, i.e. that the user who studies the
            class interface is aware of all operators relevant to the class.</para>
          <para/>
        </section>
        <section>
          <title> Unary Operators and the this pointer</title>
          <para> Unary operators are usually defined as class members without arguments -- acting
            directly on the particular instance of the class. Consider for example the pre- and
            post-increment operators. Again, one should take care that the incrementing operators
            for the class <literal>Rational</literal> mimic the corresponding operators for the
            built-in data types. This is achieved as follows:
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     Rational<T>&amp; operator++ ();
     Rational<T>  operator++ (int);
     ...
 }
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator++ ()
 {*this+=1;  return *this;}
 
 template <class T>
 inline Rational<T> Rational<T>::operator++ (int)
 {Rational<T> old(*this); *this+=1;  return old;}
]]><para>
            Note that we have used a new keyword, <literal>this</literal>, which is a self-reference
            pointer -- a pointer to the object itself. Note that although there is a unique copy of
            member variables for each instance of a class, all instances (objects) of that class
            share a single set of member functions. To indicate the specific instance whose
            variables should be used for a call to one of the member functions, the compiler adds an
            additional argument named<literal>this</literal> to the argument list of each member
            function. The second alteration made by the C++ compiler is to a
            <literal>this-&gt;</literal> prefix to all member variables and member functions. where
            the operator <literal>-&gt;</literal> is the member selection operator. Consequently the
            statement </para><![CDATA[
 _numer = r._numer;
]]><para> in the code above is written as
            </para><![CDATA[
 this->_numer = r._numer;
]]><para> Recall further that the unary
            operator <literal>*</literal> is the dereferencing operator. Since
            <literal>this</literal> is a pointer to the object itself, dereferencing this pointer
            via <literal>*this</literal> results in the object itself.</para>
          <para> Now consider again the body of the pre-incrementing operator and in particular the
            statement <literal>*this+=1;</literal>. Here we add one to the object (the rational
            number) itself. Then we return the object itself by reference. This is perfectly legal
            since it is of the return type<literal><![CDATA[Rational<T>]]></literal> and it is not a
            local object. Note that we have to return the object itself in order to allow statements
            like <literal>r2 = ++r1;</literal>.</para>
          <para> The post-increment operator makes a local copy of the number to be incremented,
            increments the number and returns the original rational number by value. If <literal>r1</literal>
            <informalequation>
              <graphic fileref="cpp78x.gif"/>
            </informalequation> and we perform <literal>r2=++r1</literal> then both
            <literal>r1</literal> and <literal>r2</literal> are equal to <informalequation>
              <graphic fileref="cpp79x.gif"/>
            </informalequation>. On the other hand, if <literal>r1</literal>
            <informalequation>
              <graphic fileref="cpp80x.gif"/>
            </informalequation> and we perform <literal>r2=r1++</literal> then <literal>r1</literal>
            is equal to <informalequation>
              <graphic fileref="cpp81x.gif"/>
            </informalequation>, but <literal>r2</literal> is equal to <informalequation>
              <graphic fileref="cpp82x.gif"/>
            </informalequation>.</para>
          <para> The decrementing operators are defined analogously. We have also defined the unary
            <literal>+</literal> and unary <literal>-</literal> operators. These are very simple and
            the implementation details can be found in the class listing at the end of this chapter.</para>
          <para/>
        </section>
        <section>
          <title> Type-Conversion Operators </title>
          <para> We also want to be able to explicit and implicit type conversion between rational
            numbers and built-in types like <literal>double</literal>. For example, we would like to
            allow the user to make constructs like
            </para><![CDATA[
 void main()
 {
   Rational<long> r(234,167);
 
   double x = r;
 
   y = sqrt((double)r);
 }
]]><para>
            In the assignment statement we make an implicit type conversion from
            <literal><![CDATA[Rational<long>]]></literal> to <literal>double</literal>. When calling
            the sqrt we made this type conversion explicitly. In both cases the following
            type-conversion operator was used:
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     operator double() const;
 }
 
 template <class T>
 inline Rational<T>::operator double () const
 { return (double)_numer/(double)_denom; }
]]><para>
            We can define type-conversion operators to both, built-in data types and to other
            user-defined data types.</para>
          <para/>
        </section>
        <section>
          <title> Relational Operators</title>
          <para> In order to mimic the built in data types as closely as possible we also have to
            define the relational operators. All these operators leave the members of the class
            unaltered and hence they are all declared class constants.
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     int operator== (const Rational<T>&amp; r) const;
     int operator<  (const Rational<T>&amp; r) const;
 
     int operator<  (const T&amp; k) const;
 }
 
 template <class T>
 inline int Rational<T>::operator==
         (const Rational<T>&amp; r) const
 { return ((_numer == r._numer) &amp;&amp; (_denom == r._denom));}
 
 template <class T>
 inline int Rational<T>::operator>
         (const Rational<T>&amp; r) const
 { return ((double)*this > (double)r);}
]]><para>
            The implementation of the <literal>==</literal> operator is pretty standard. For the
            <literal>&gt;</literal> operator we first typecast the object itself to a
            <literal>double</literal> using our own type-conversion operator defined in the previous
            section and then we compare it to the argument -- again type-converted to a double.</para>
          <para/>
        </section>
        <section>
          <title> The Assignment Operator</title>
          <para> As for the copy constructor, should you omit to define an assignment operator, your
            obliging C++ compiler will write one for you which, once again, makes a byte for byte
            copy of the data fields. This might or might not be what you want for your class.
            Usually, if you use dynamic memory allocation in your class you will be forced to write
            your own assignment operator. We shall use dynamic memory allocation for our vector and
            matrix classes.</para>
          <para> Consider the following extract of the class interface where we define two
            assignment operators:
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     Rational<T>&amp; operator= (const Rational<T>&amp; r);
     Rational<T>&amp; operator= (const T&amp; k);
     ...
 }
]]><para>
            The first of these operators takes a rational number as argument. It would be used in
            statements like </para><![CDATA[
 r1 = r2;
]]><para>The implementation details are given
            below:
            </para><![CDATA[
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator =
                (const Rational<T> r)
 {
   _numer = r._numer; _denom = r._denom;
   return *this;
 }
]]><para>The
            function <literal>operator=</literal> returns the object itself by reference, not by
            value. Why would we want to do this. In the statement
            </para><![CDATA[
 r1 = r2;
]]><para> we perform the function call
            <literal>r1.operator=(r2)</literal>, but we do not use the return value. Recall,
            however, that it is legal in C++ to concatenate assignments like
            <literal>r1=r2=r3;</literal> and that the assignment operator is the only binary
            operator which is right-associative. Hence the above statement is performed as
            <literal>r1=(r2=r3)</literal>. Now, if our assignment operator returned
            <literal>void</literal> (or anything else except the object itself), then we would
            assign<literal>r1=void</literal>. Returning the object itself solves this problem. It is
            of course more effcient to return the object by reference instead of by value (saving
            the overhead of making a copy) and it is also perfectly legal since we are not returning
            a reference to a local object.</para>
          <para> The implementation of the second assignment operator is very similar and can be
            found in the class listing (see section ??).</para>
          <para/>
        </section>
        <section>
          <title> The Power Method </title>
          <para> One of the more interesting implementations is that of the <literal>power</literal>
            methods::
            </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     Rational<T>   power (const long)   const;
     double power (const double) const;
 }
 
 template <class T>
 Rational<T> Rational<T>::power (const long n) const
 {
   if (n==0)
     return Rational<T>(1,1);
   else
     {
       Rational<T> result(*this);
       for (int i=2; i<=labs(n); i++)
         result *= *this;
       if (n<0)
       {
         T dummy = result._denom;
         result._denom = result._numer;
         result._numer = dummy;
       }
       return result;
     }
 }
 
 template <class T>
 inline double Rational<T>::power (const double y) const
 {return pow(*this,y);}
]]><para>
            The first method which allows the user to evaluate an integral power (<informalequation>
              <graphic fileref="cpp83x.gif"/>
            </informalequation>'th power) of a rational number. For the case where <informalequation>
              <graphic fileref="cpp84x.gif"/>
            </informalequation> we simply return the rational number <informalequation>
              <graphic fileref="cpp85x.gif"/>
            </informalequation>. Otherwise we use the copy constructor to create a local copy called
            <literal>result</literal> and multiply the result <informalequation>
              <graphic fileref="cpp86x.gif"/>
            </informalequation> times by the object itself. Finally, if <informalequation>
              <graphic fileref="cpp87x.gif"/>
            </informalequation> is negative we simply invert the result.</para>
          <para> The second method calculates the real-valued power of a rational number. Here we
            use the <literal>pow</literal> function from the <literal>math</literal> library which
            takes two variables of type <literal>double</literal> as arguments. Hence, implicitly
            the type-conversion operator (which we defined in section ??) is used. The result is a
            local dummy variable which is returned by value.</para>
          <para/>
        </section>
      </section>
      <section>
        <title> Input/Output Stream Access</title>
        <para> We want to define stream access for our abstract data type. This is achieved by
          overloading the stream-extraction and stream-output operators for our class. The stream
          classes are built in classes in C++ and we have to define these operators as global
          operators. In order that these methods have direct access to the private data members of
          our class (avoiding the overheads of calling the query functions of the class) we declare
          both operators as <literal>friend</literal>s of the class:
          </para><![CDATA[
 template <class T> class Rational
 {
   public:
     ...
     friend ostream&amp; operator<< (ostream&amp; os,
                                const Rational<T>&amp; r);
     friend istream&amp; operator>> (istream&amp; is,
                                      Rational<T>&amp; r);
 }
 
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Rational<T>&amp; r)
 {
   T non_frac = r._numer/r._denom;
   T frac_numer = r._numer - non_frac*r._denom;
   if (non_frac != 0) os << non_frac;
   if (frac_numer != 0)
     os << " " << frac_numer << "/" << r._denom;
   return os;
 }
 
 template <class T>
 istream&amp; operator>> (istream&amp; is, Rational<T>&amp; r)
 {
   T numer, denom;
   is >> numer >> denom;
   r = Rational<T>(numer,denom);
   return is;
 }
]]><para>
          The stream extraction operator is very simple. The user enters a rational number by
          entering the numerator and the denominator separated by standard C white spaces (blank,
          tab, newline, formfeed and carriage return). A rational numer is created accordingly
          (using the constructor) and <literal>r</literal> is set equal to this rational number.
          Note that we return the stream by reference in order to allow for concatenation of stream
          extractions: </para><![CDATA[
 cin >> r1 >> r2 >> r3;
]]><para> For the stream output
          operator we first simplify the rational number by extracting the highest possible integral
          factor (e.g. <informalequation>
            <graphic fileref="cpp88x.gif"/>
          </informalequation>).</para>
        <para/>
      </section>
      <section>
        <title> User's Guide to the Rational Class </title>
        <para> In the following section we give a listing of the header file
          <literal>RATIONAL.H</literal> which defines the class interface. One should always consult
          the header file in order to see which operations are available to the user. You will find
          that all the standard mathematical operators (e.g. addition, multiplication, incrementing,
          assignment, ...) which are defined for built in data types (e.g. <literal>float</literal>)
          are also defined for rational numbers. In addition we support mixed-type arithmetic. For
          example, we allow the user to add an integer or a floating point number to a rational
          number, yielding a rational number or a floating point number respectively.</para>
        <para> Furthermore, all the relational operators like <literal>==</literal> or
          <literal>&gt;=</literal> are defined for rational numbers. Again we mode mixed-type
          comparisons, i.e. we can check whether a rational number is less than or equal to a
          floating point number.</para>
        <para> Finally we supply two power methods. The one allows the user to evaluate an integral
          power of a rational number, yielding a rational number. The second allows the user t take
          a floating point power of a rational number, yielding a floating point number.</para>
        <para> On the accompanying disk there is the following small demonstration
          program,<literal>TRATIONL.CPP</literal>, which illustrates the usage of the class
          <literal>Rational</literal>:
          </para><![CDATA[
 // FILE: TestRationl.CPP
 
 #include <iostream>
 
 #include "ErrHandl.h"
 
 #include "Rational.h"
 #include "Rational.cpp"
 
 using namespace std;
 
 int main()
 {
   Rational<long> r1(3,9);      cout << "r1 = " << r1 << endl;
   Rational<long> r2(13,2);     cout << "r2 = " << r2 << endl;
 
   // Now using default constructor, addition and assigment operators
   Rational<long> r3 = r1 + r2;
   cout << "r3 = r1+r2 = " << r3 << endl; // output stream operator
   cout << "r1*r2 = " << r1*r2 << endl; // multiplying 2 rational nos
   cout << "r1/r2 = " << r1/r2 << endl;
 
   cout << "-r1 = " << -r1 << endl;               // unary minus
   cout << "r1>r2  -> " << (r1>r2)  << endl;      // relational operators
   cout << "r1<=r2 -> " << (r1<=r2) << endl;
 
   double x = r1;     // using type conversion operator (implicitely)
   cout.precision(15);
   cout << "x = " << x << endl;
 
   cout << "r1 + 2 = " << (r1 + 2.1) << endl; // using member operator
   cout << "2 + r1 = " << ((long)2 + r1) << endl; // using global operator
   cout << "r1++ = " << (r1++) << endl;     // post-incrementing
   cout << "r1 = " << r1 << endl;
   cout << "++r1 = " << (++r1) << endl;     // pre-incrementing
   cout << "r1&#x02C6;5  = " << r1.power((long)3) << endl;  // power method
   cout << "r1&#x02C6;-0.5 = " << r1.power((double)-0.5) << endl;
 
   cout << "r1 < 2.3 = " << (r1<2.3) << endl;
 

   Rational<long> r4 = -17;
   cout << "fabs(" << r4 << ") = " << fabs(r4) << endl;
 
   cout << "Type in rational number r=n/m: n m = ";
   try
   {
     cin >> r1;
     cout << "Read in rational number, r1 = " << r1 << endl;
   }
   catch (DivideByZero error)
   {
     cout << "*** ERROR ***: " << error.source << endl;
   }
   char k; cin >> k;
 
   return 0;
 }
]]><para>
          In the first two lines of the body of <literal>main</literal> we create, initialize and
          send to the standard output stream 2 rational numbers <literal>r1</literal>
          <informalequation>
            <graphic fileref="cpp89x.gif"/>
          </informalequation> and <literal>r2</literal>
          <informalequation>
            <graphic fileref="cpp90x.gif"/>
          </informalequation>.</para>
        <para> In the following statement we create a rational number <literal>r3</literal> (via the
          default constructor), use the addition operator to add two rational numbers and the
          assignment operator to assign<literal>r3</literal> to the result of the addition. We then
          demonstrate multiplication and division of two rational numbers, followed by the
          demonstration of the unary minus and some relational operators.</para>
        <para> The statement </para><![CDATA[
 double x = r1;
]]><para> makes implicitly use of the
          type conversion operator discussed in section ??.</para>
        <para> We continue to show when the member operator for addition and when the global
          operator is used. The difference between the post- and pre-incrementing operators is
          demonstrated in the following few statements followed by a demonstration of the two
          <literal>power</literal> methods. Finally we read in a rational number from the keyboard.</para>
        <para> We recommend that you run this program in order to have a look at its output.</para>
        <para/>
      </section>
      <section>
        <title> Listing of the Rational Class </title>
        <para> In this section we give a complete listing of the class <literal>Rational</literal>.
          The header file<literal>RATIONAL.H</literal> defines the class interface. This is often
          the only readable file available to the user of your class.
          </para><![CDATA[
 // FILE: RATIONAL.H
 
 #ifndef __RATIONAL_H
 #define __RATIONAL_H
 
 #include <math.h>
 #include <stdexcept>
 #include <iostream>
 
 #include "ErrHandl.h"
 
 using namespace std;
 
 template <class T>
 class Rational
 {
   public:
     Rational ();
     Rational (const T&amp; numer, const T&amp; denom);
     Rational (const Rational<T>&amp; r);
     Rational (const T&amp; k);
 
     inline T numerator   () const;
     inline T denominator () const;
 
     Rational<T>   power (const long)   const;
     double power (const double) const;
 
     Rational<T>&amp; operator= (const Rational<T> r);
     Rational<T>&amp; operator= (const T&amp; k);
 
     Rational<T>  operator+  (const Rational<T>&amp; r) const;
     Rational<T>  operator-  (const Rational<T>&amp; r) const;
     Rational<T>  operator*  (const Rational<T>&amp; r) const;
     Rational<T>  operator/  (const Rational<T>&amp; r) const;
     Rational<T>&amp; operator+= (const Rational<T>&amp; r);
     Rational<T>&amp; operator-= (const Rational<T>&amp; r);
     Rational<T>&amp; operator*= (const Rational<T>&amp; r);
     Rational<T>&amp; operator/= (const Rational<T>&amp; r);
 
     Rational<T>  operator+  (const T&amp; k) const;
     Rational<T>  operator-  (const T&amp; k) const;
     Rational<T>  operator*  (const T&amp; k) const;
     Rational<T>  operator/  (const T&amp; k) const;
     double       operator+  (const double&amp; x) const;
     double       operator-  (const double&amp; x) const;
     double       operator*  (const double&amp; x) const;
     double       operator/  (const double&amp; x) const;
     Rational<T>&amp; operator+= (const T&amp; k);
     Rational<T>&amp; operator-= (const T&amp; k);

     Rational<T>&amp; operator*= (const T&amp; k);
     Rational<T>&amp; operator/= (const T&amp; k);
 
     int operator== (const Rational<T>&amp; r) const;
     int operator!= (const Rational<T>&amp; r) const;
     int operator<  (const Rational<T>&amp; r) const;
     int operator>  (const Rational<T>&amp; r) const;
     int operator<= (const Rational<T>&amp; r) const;
     int operator>= (const Rational<T>&amp; r) const;
 
     int operator== (const double&amp; x) const;
     int operator!= (const double&amp; x) const;
     int operator<  (const double&amp; x) const;
     int operator>  (const double&amp; x) const;
     int operator<= (const double&amp; x) const;
     int operator>= (const double&amp; x) const;
 
     int operator== (const T&amp; k) const;
     int operator!= (const T&amp; k) const;
     int operator<  (const T&amp; k) const;
     int operator>  (const T&amp; k) const;
     int operator<= (const T&amp; k) const;
     int operator>= (const T&amp; k) const;
 
     Rational<T> operator+ () const;
     Rational<T> operator- () const;
 
     Rational<T>&amp; operator++ ();
     Rational<T>&amp; operator-- ();
     Rational<T>  operator++ (int);
     Rational<T>  operator-- (int); // decrement
 
     operator double () const;      // type conversion to double
 
   private:
     T _numer, _denom;
 
     T gcd (T a, T b) const;
 };
 
 
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Rational<T>&amp; r)
 {
   T numer = r.numerator();
   T denom = r.denominator();
   T non_frac = numer/denom;
   T frac_numer = numer - non_frac*denom;
   if (non_frac != 0) os << non_frac;
   if (frac_numer != 0)
     if (frac_numer > 0)
       os << " " << frac_numer << "/" << denom;
     else
       os << " " << -frac_numer << "/" << denom;

   return os;
 }
 
 template <class T>
 istream&amp; operator>> (istream&amp; is, Rational<T>&amp; r)
 {
   T numer, denom;
   is >> numer >> denom;
   r = Rational<T>(numer,denom);
   return is;
 }
 
 template <class T>
 Rational<T> operator+ (const T&amp; k, const Rational<T>&amp; r)
 {return r+k;}
 
 template <class T>
 Rational<T> operator- (const T&amp; k, const Rational<T>&amp; r)
 {return (-r)+k;}
 
 template <class T>
 Rational<T> operator* (const T&amp; k, const Rational<T>&amp; r)
 {return r*k;}
 
 template <class T>
 Rational<T> operator/ (const T&amp; k, const Rational<T>&amp; r)
 {return Rational<T>(r.denominator()*k,r.numerator());}
 
 template <class T>
 Rational<T> fabs (const Rational<T>&amp; r)
 {return Rational<T>(abs(r.numerator()),r.denominator());}
 
 #endif
]]><para>
          The implementation details are defined in a separate file <literal>RATIONAL.CPP</literal>
          which is generally not available to users of your class. </para><![CDATA[
 // FILE: Rational.CPP
 #include "Rational.h"
 // CONSTRUCTORS
 // ============
 
 template <class T>
 Rational<T>::Rational (): _numer(0), _denom(1) {};
 
 template <class T>
 Rational<T>::Rational (const T&amp; numer,
                        const T&amp; denom)
   : _numer(numer), _denom(denom)
 {
 #if EXCEPTIONHANDLING
   if (denom == 0)
     throw DivideByZero("Rational(numer,denom) => denom=0");
 #endif
   if (_denom < 0)
     {_numer = -_numer;  _denom = -_denom;}
 
   T common = gcd(_numer, _denom);
 
   if (common > 1)
     {_numer /= common;  _denom /= common;}
 };
 
 template <class T>
 Rational<T>::Rational (const Rational<T>&amp; r)
   : _numer(r._numer), _denom(r._denom) {};
 
 template <class T>
 Rational<T>::Rational (const T&amp; k)
   : _numer(k), _denom(1) {};
 
 // QUERY FUNCTIONS
 // ===============
 
 template <class T>
 inline T Rational<T>::numerator   () const
   {return _numer;};
 
 template <class T>
 inline T Rational<T>::denominator () const
   {return _denom;};
 
 // OTHER CONSTANT MEMBER FUNCTIONS
 // ===============================
 
 template <class T>
 Rational<T> Rational<T>::power (const long n) const

 {
   if (n==0)
     return Rational<T>(1,1);
   else
     {
       Rational<T> result(*this);
       for (int i=2; i<=labs(n); i++)
         result *= *this;
       if (n<0)
       {
         T dummy = result._denom;
         result._denom = result._numer;
         result._numer = dummy;
       }
       return result;
     }
 }
 
 template <class T>
 inline double Rational<T>::power (const double y) const
 {return pow(*this,y);}
 
 // ASSIGNMENT OPERATORS
 // ====================
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator=  (const Rational<T> r)
 {
   _numer = r._numer; _denom = r._denom;
   return *this;
 }
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator= (const T&amp; k)
 {
   _numer = k; _denom = (T)1;
   return *this;
 }
 
 // ARITHMETIC OPERATORS
 // ====================
 
 template <class T>
 inline Rational<T> Rational<T>::operator+
              (const Rational<T>&amp; r) const
 {
   return Rational<T>(_numer*r._denom
            + r._numer*_denom, _denom*r._denom);
 }
 
 template <class T>
 inline Rational<T> Rational<T>::operator+
              (const T&amp; k) const
 {

   return Rational<T>(_numer+k*_denom,_denom);
 }
 
 template <class T>
 inline Rational<T> Rational<T>::operator-
              (const Rational<T>&amp; r) const
 { return *this + (-r); }
 
 template <class T>
 inline Rational<T> Rational<T>::operator-
              (const T&amp; k) const
 {
   return Rational<T>(_numer-k*_denom,_denom);
 }
 
 template <class T>
 inline Rational<T> Rational<T>::operator*
         (const Rational<T>&amp; r) const
 { return Rational<T>(_numer*r._numer, _denom*r._denom);}
 
 template <class T>
 inline Rational<T> Rational<T>::operator*
              (const T&amp; k) const
 {
   return Rational<T>(_numer*k,_denom);
 }
 
 template <class T>
 inline Rational<T> Rational<T>::operator/
         (const Rational<T>&amp; r) const
 { return Rational<T>(_numer*r._denom, _denom*r._numer);}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator+=
      (const Rational<T>&amp; r)
        {*this = *this + r; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator-=
      (const Rational<T>&amp; r)
        {*this = *this - r; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator*=
      (const Rational<T>&amp; r)
        {*this = *this * r; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator/=
      (const Rational<T>&amp; r)
        {*this = *this / r; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator+=

      (const T&amp; k)
        {*this = *this + k; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator-=
      (const T&amp; k)
        {*this = *this - k; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator*=
      (const T&amp; k)
        {*this = *this * k; return *this;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator/=
      (const T&amp; k)
        {*this = *this / k; return *this;}
 
 template <class T>
 inline double Rational<T>::operator+  (const double&amp; x) const
 {return (double)*this+x;}
 
 template <class T>
 inline double Rational<T>::operator-  (const double&amp; x) const
 {return (double)*this-x;}
 template <class T>
 
 inline double Rational<T>::operator*  (const double&amp; x) const
 {return (double)*this * x;}
 template <class T>
 
 inline double Rational<T>::operator/  (const double&amp; x) const
 {return (double)*this/x;}
 
 
 // UNARY OPERATORS
 // ===============
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator++ ()
 {*this+=1;  return *this;}
 
 template <class T>
 inline Rational<T> Rational<T>::operator++ (int)
 {Rational<T> old(*this); *this+=1;  return old;}
 
 template <class T>
 inline Rational<T>&amp; Rational<T>::operator-- ()
 {*this-=1;  return *this;}
 
 template <class T>
 inline Rational<T> Rational<T>::operator-- (int)
 {Rational<T> old(*this); *this-=1;  return old;}
 

 template <class T>
 inline Rational<T> Rational<T>::operator- () const
 {
   Rational<T> r(*this);
   r._numer = -r._numer;
   return r;
 }
 
 template <class T>
 inline Rational<T> Rational<T>::operator+ () const
 { return *this; }
 
 // RELATIONAL OPERATORS
 // =====================
 
 template <class T>
 inline int Rational<T>::operator==
         (const Rational<T>&amp; r) const
 { return ((_numer == r._numer) &amp;&amp; (_denom == r._denom));}
 
 template <class T>
 inline int Rational<T>::operator!=
         (const Rational<T>&amp; r) const
 { return (!(*this == r)); }
 
 template <class T>
 inline int Rational<T>::operator>
         (const Rational<T>&amp; r) const
 { return ((double)*this > (double)r);}
 
 template <class T>
 inline int Rational<T>::operator<
         (const Rational<T>&amp; r) const
 { return ((double)*this < (double)r);}
 
 template <class T>
 inline int Rational<T>::operator>=
         (const Rational<T>&amp; r) const
 { return ((double)*this >= (double)r);}
 
 template <class T>
 inline int Rational<T>::operator<=
         (const Rational<T>&amp; r) const
 { return ((double)*this <= (double)r);}
 
 template <class T>
 inline int Rational<T>::operator==
         (const T&amp; k) const
 { return (_numer == k);}
 
 template <class T>
 inline int Rational<T>::operator!=
         (const T&amp; k) const
 { return (_numer != k);}

 
 template <class T>
 inline int Rational<T>::operator>
         (const T&amp; k) const
 { return ((double)*this > k);}
 
 template <class T>
 inline int Rational<T>::operator<
         (const T&amp; k) const
 { return ((double)*this < k);}
 
 template <class T>
 inline int Rational<T>::operator>=
         (const T&amp; k) const
 { return ((double)*this >= k);}
 
 template <class T>
 inline int Rational<T>::operator<=
         (const T&amp; k) const
 { return ((double)*this <= k);}
 
 template <class T>
 inline int Rational<T>::operator==
         (const double&amp; x) const
 { return ((double)*this == x);}
 
 template <class T>
 inline int Rational<T>::operator!=
         (const double&amp; x) const
 { return ((double)*this != x);}
 
 template <class T>
 inline int Rational<T>::operator>
         (const double&amp; x) const
 { return ((double)*this > x);}
 
 template <class T>
 inline int Rational<T>::operator<
         (const double&amp; x) const
 { return ((double)*this < x);}
 
 template <class T>
 inline int Rational<T>::operator>=
         (const double&amp; x) const
 { return ((double)*this >= x);}
 
 template <class T>
 inline int Rational<T>::operator<=
         (const double&amp; x) const
 { return ((double)*this <= x);}
 
 // TYPE CONVERSIONS
 // ================
 template <class T>

 inline Rational<T>::operator double () const
 { return (double)_numer/(double)_denom; }
 
 // PRIVATE METHODS
 // ===============
 
 template <class T>
 T Rational<T>::gcd (T a, T b) const
 {
   if (a < 0) a = -a;
   if (b < 0) b = -b;
 
   while (b > 0)
   {
     T m = a % b;
     a = b;
     b = m;
   }
   return a;
 }
]]><para/>
      </section>
      <section>
        <title> Listing of the Exception Classes </title><![CDATA[
 #ifndef __ERRHANDL_H
 #define __ERRHANDL_H
 
 #define EXCEPTIONHANDLING 1
 
 #include <stdexcept>
 
 using namespace std;
 
 // BASE CLASS FOR ALL EXCEPTION HANDLING
 // =====================================
 class Exception
 {
   public:
     const char* source;
     Exception(): source(NULL) {};
     Exception(const char* src): source(src) {};
 };
 
 // BASE CLASS FOR ALL MATH ERRORS
 // ==============================
 class MathError: public Exception
 {
   public:
     MathError() {};
     MathError(const char* src): Exception(src) {};
 };
 
 // NOW ALL THE SPECIAL INSTANCES OF MATH ERRORS
 // ============================================
 class DivideByZero: public MathError
 {
   public:
     DivideByZero() {};
     DivideByZero(const char* src)
       : MathError(src) {};
 };
 
 class Overflow: public MathError
 {
   public:
     Overflow() {};
     Overflow(const char* src)
       : MathError(src) {};
 };
 
 class IllegalOperation: public MathError
 {
   public:
     IllegalOperation() {};

     IllegalOperation(const char* src)
       : MathError(src) {};
 };
 
 // BASE CLASS FOR ALL MEMORY ERRORS
 // ================================
 class MemoryError: public Exception
 {
   public:
     MemoryError() {};
     MemoryError(const char* src): Exception(src) {};
 };
 
 // NOW ALL THE SPECIAL INSTANCES OF MEMORY ERRORS
 // ==============================================
 class OutOfMemory: public MemoryError
 {
   public:
     OutOfMemory() {};
     OutOfMemory(const char* src)
       : MemoryError(src) {};
 };
 
 class Range: public MemoryError
 {
   public:
     Range() {};
     Range(const char* src)
       : MemoryError(src) {};
 };
 
 // SOME OTHER EXCEPTIONS
 // =====================
 class IllegalArguments: public Exception
 {
   public:
     IllegalArguments() {};
     IllegalArguments(const char* src): Exception(src) {};
 };
 
 class IllegalCall: public Exception
 {
   public:
     IllegalCall() {};
     IllegalCall(const char* src): Exception(src) {};
 };
 
 #endif
]]><para/>
      </section>
      <section>
        <title> Exercises</title>
        <para/>
        <orderedlist>
          <listitem>
            <para>Write a function <literal>mean</literal> which uses the class
              <literal>Rational</literal> and which calculates the arithmetic mean of two rational
              numbers. </para>
          </listitem>
          <listitem>
            <para>Write a complete class for complex numbers supporting the same functionality as
              the Rational class discussed in this chapter. </para>
          </listitem>
        </orderedlist>
        <para/>
      </section>
    </section>
    <!--end chapter-->
    <section role="chapter">
      <title> Working at Different Levels of Abstraction </title>
      <section>
        <title> Introduction</title>
        <para> In many ways the power of object-orientation comes from the support for abstraction,
          enabling developers to work at very abstract and general levels and facilitating the
          development of very generic solutions. Of course, at times one has to work at a very
          specific level and that too is cleanly facilitated through object-orientation.</para>
        <para> There are mainly two mechanisms through which abstraction is achieved, superclasses
          and interfaces. The former has more an implementation focus while the latter is driven
          more by client needs.</para>
        <para/>
      </section>
      <section>
        <title> Abstraction via Super-Classes</title>
        <para/>
        <section>
          <title> Thinking at Different Levels of Abstraction (Part 1)</title>
          <para> We think quite naturally at different levels of abstraction. Consider the sentence
            Consider the following statements which become more and more concrete: </para>
          <blockquote role="centerline">
            <title/> A person deposited money into the account. </blockquote>
          <blockquote role="centerline">
            <title/> A client deposited money into the account. </blockquote>
          <blockquote role="centerline">
            <title/> Mr P.J. Smith deposited money into the account. </blockquote>
          <para> It might be suffcient for you to know that somebody deposited money in the account.
            Alternatvely, you might want to know whether it is a cient or a friend who deposited the
            money and for bookkeeping purposes you would want to know which client deposited the
            money into the account. Here client is a special type of person, and P.J. Smith may be a
            special kind of client.</para>
          <para> So we naturally introduce abstractions into our everyday language and it is really
            in the same spirit that object-oriented languages support abstraction too.</para>
          <para/>
        </section>
        <section>
          <title> Specialization through Subclassing </title>
          <para> Java allows you to define objects at various levels of abstraction. For example,
            You might view a particular manager as a <literal>Manager</literal>, an
            <literal>Employee</literal>, a <literal>Person</literal> or simply as an
            <literal>Object</literal>. This is a process from very concrete to more and more abstract.</para>
          <para> The reverse direction can be viewed as specialization. A <literal>Manager</literal>
            is a special type of<literal>Employee</literal> which is a special type of
            <literal>Person</literal> which is a special type of <literal>Object</literal>.</para>
          <para> Note that we can identify a specialization relation ship as a is a special kind of
            relationship and this should <informalequation>
              <graphic fileref="cpp91x.gif"/>
            </informalequation> be the criterion for deciding on subclassing.</para>
          <para> Subclassing is achieved in via the following syntax:</para>

          <para/><![CDATA[
 class Manager: public Employee {...};
 
 class Employee: public Person {...};
 
 class Person {...};
]]><para>
            Here <literal>Manager</literal> is a subclass of <literal>Employee</literal> which is a
            subclass of <literal>Person</literal>. Conversely, <literal>Person</literal> is the
            superclass of <literal>Employee</literal> which is the superclass of
            <literal>Manager</literal>. Note that we did not have to specify that
            <literal>Person</literal> extends Object.</para>
          <para> I want to stress that the language relies on you to design your class hierarchies
            in such a way that the subclass is a specialization of the superclass. This is best
            illustrated by the following simple statements:</para>
          <para/><![CDATA[
 Employee* employee;
 
 employee = new Manager();
]]><para> We first
            declare a pointer to an <literal>Employee</literal>. This pointer can refer to any
            object which is an <literal>Employee</literal>. In the second statement we create a
            <literal>Manager</literal> and assign the<literal>Employee</literal>-pointer to refer to
            the manager. The compiler is quite happy because <literal>Manager</literal> is a
            subclass of <literal>Employee</literal> and he/she trusts you in having applied the is a
            criterion for subclassing.</para>
          <para> Quite generally the following rule should hold. Everywhere where an
            <literal>Employee</literal> is required you should be able to supply any
            <literal>Employee</literal>, whether it is a vanilla <literal>Employee</literal> or a
            specialized <literal>Employee</literal> like <literal>Manager</literal> or
            <literal>Programmer</literal>. We can thus work with employees at various levels of
            abstraction. Let us have a look at the intestines of a simple <literal>Person</literal> class.</para>
          <para/>
          <section>
            <title> The Person Header</title>
            <para> The <literal>Person</literal> class has no surprises with the exception of a
              <literal>toString()</literal> method which has been declared virtual. We shall discuss
              this method in section ??.</para>
            <para/><![CDATA[
 #ifndef Person_H
 #define Person_H
 
 #include <iostream>
 #include <string>
 
 using namespace std;
 
 class Person
 {
   public:
     Person(const string&amp; name, const string&amp; idNo);
 
     string name() const;
 
     string idNo() const;
 
     virtual string toString() const;
 
   //friends:
     friend ostream&amp; operator<<(ostream&amp; os, const Person&amp;);
 
   private:
     string _name;
     string _idNo;
 };
 #endif
]]><para/>
          </section>
          <section>
            <title> The Person Implementation</title>
            <para> The implementation class is similarly straight-forward:</para>
            <para/><![CDATA[
 #include "Person.h"
 
 #include <string.h>
 
 Person::Person(const string&amp; name, const string&amp; idNo)
          : _name(name), _idNo(idNo) {}
 
 string Person::name() const {return _name;}
 
 string Person::idNo() const {return _idNo;}
 
 string Person::toString() const
 {
   return _name + ": " + _idNo;
 }
 
 // Implementation of friend functions:
 
 ostream&amp; operator<< (ostream&amp; os, const Person&amp; p)
 {
   os << p._name << ": " << p._idNo;
   return os;
 }
]]><para/>
          </section>
          <section>
            <title> The Header for the Employee Sub-Class</title>
            <para> The <literal>Employee</literal> class is declared a subclass of the
              <literal>Person</literal> class via</para>
            <para/><![CDATA[
 class Employee: public Person {...};
]]><para> The subclass inherits
              all instance members -- not the class (<literal>static</literal>) members from the
              superclass. Hence, we do not define data fields for the name and id number. Note that
              these fields were declared <literal>private</literal> in the <literal>Person</literal>
              class and that they thus cannot be directly accessed from the subclass. They are still
              inherited, though. If we want to acces them from the subclass, we have to use the same
              public interface as everybody else.</para>
            <para> With the name and id number inherited, we only have to define a data field with
              corresponding query and set methods for the additional <literal>salary</literal> field:</para>
            <para/><![CDATA[
 #ifndef Employee1_H
 #define Employee1_H
 
 #include <iostream>
 
 #include "Person.h"
 
 using namespace std;
 
 class Employee1: public Person
 {
   public:
     Employee1(const string&amp; name, const string&amp; idNo,
               const double&amp; salary);
 
     double salary() const;
 
     void salary(const double&amp; newSalary);
 
     string toString() const;
 
   //friends:
     friend ostream&amp; operator<< (ostream&amp; os, const Employee1&amp; e);
 
   private:
     double _salary;
 };
 #endif
]]><para/>
          </section>
          <section>
            <title> The Implementation File for the Employee Sub-Class</title>
            <para> When instantiating a class, one always instantiates all its superclasses. For
              example, everytime an instance of the <literal>Employee</literal> class is created, an
              instance of the <literal>Person</literal> class which lives inside the
              <literal>Employee</literal> class is created too. Otherwise, where would a person get
              its name and id number from.</para>
            <para> Objects are created via constructors. So, within the constructors of the subclass
              we have to somehow specify how the superclass is instantiated. This is done in C++ via
              the parameter list:</para>

            <para/><![CDATA[
 Employee::Employee(const string&amp; name, const string&amp; idNo,
                    const double&amp; salary)
   :Person(name, idNo), _salary(salary){}
]]><para>
              Should we omit to specify which constructor should be used to instantiate the
              superclass, the compiler will do the default this -- i.e. try and instantiate the
              superclass via the default constructor. The complete listing of the
              <literal>Employee</literal> implementation is shown below:</para>
            <para/><![CDATA[
 #include "Employee1.h"
 #include <stdlib.h>
 
 Employee1::Employee1(const string&amp; name, const string&amp; idNo,
                      const double&amp; salary)
   :Person(name, idNo), _salary(salary){}
 
 double Employee1::salary() const {return _salary;}
 
 void Employee1::salary(const double&amp; newSalary)
 {
   _salary = newSalary;
 }
 
 string Employee1::toString() const
 {
   char* s_salary = new char[24];
   sprintf(s_salary, "%f", _salary);
   return Person::toString() + " (salary = " + s_salary + ")";
 }
 
 ostream&amp; operator<< (ostream&amp; os, const Employee1&amp; e)
 {
   os << e.name() << ": " << e.idNo() << "(salary = "
      << e._salary << ")";
   return os;
 }
]]><para/>
          </section>
        </section>
        <section>
          <title> Inheritance</title>
          <para> Instances of the subclass inherit the services offered by instances of the
            superclass. Hence, we can directly ask an employee for his/her name, even though the
            <literal>Employee</literal> class itself does not define a <literal>name()</literal> service:</para>

          <para/><![CDATA[
 #include <iostream>
 
 #include "Person.h"
 #include "Employee1.h"
 
 using namespace std;
 
 //---------------------------------------------------------------------------
 int main()
 {
   Person* p1 = new Person("Jack", "6811125657102");
   Employee1 * e1 = new Employee1("Jill", "6910825655105", 210000);
 
   cout << "p1's name: " << p1->name() << endl;
   cout << "e1's name: " << e1->name() << endl;
   cout << "e1's salary: " << e1->salary() << endl;
 
   Person* p2 = e1;
 
   cout << "p2's name: " << p2->name() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para>
            The output of the program is quite predictably:</para>
          <para/><![CDATA[
 p1's name: Jack
 e1's name: Jill
 e1's salary: 210000
 p2's name: Jill
]]><para/>
        </section>
        <section>
          <title> Access Levels</title>
          <para> C++ defines 3 access levels: private: Elements which have been declared
            <literal>private</literal> can be accessed from within any instance of the class. Note
            that access is not restricted to within an object but to within any mamber of the same
            class. public: Public members are generally accessible from anywhere where there is a
            handle (pointer or reference) available to the object hosting the member. protected:
            Protected members can be accessed from within the class in which they are defined as
            well as from within subclasses of the class.</para>
          <para/>
          <section>
            <title> Should you Declare Data Fields Protected?</title>
            <para> Declaring data fields protected gives subclasses direct access to them. This, is
              argued, is often desirable -- after all, an instance of the subclass is also an
              instance of the superclass. It also provides the performance benefit that subclasses
              do not have to use the public access methods to access the data fields.</para>
            <para> Howeer, <literal>protected</literal> data fields aren't (protected). Try and
              resist any warm feelings which the word, <literal>protected</literal>, may arouse in
              you. They are not protected from corruption by code defined in any of the subclasses
              because they bypass the access methods which were designed to provide controlled
              access to them. Furthermore, if a less respectable member of society ends up
              subclassing your class, they could make your so-called protected data field public.
              This is illustrated in the following block of code:</para>

            <para/><![CDATA[
 #include <iostream>
 
 using namespace std;
 
 class A
 {
   public:
     A() : secretCode(1234) {}
 
   protected:
     int secretCode;
 
   friend ostream&amp; operator<< (ostream&amp; os, const A&amp; a);
 };
 
 ostream&amp; operator<< (ostream&amp; os, const A&amp; a)
 {
   os << "I am an A. My secret is " << a.secretCode;
 
   return os;
 }
 
 class B: public A
 {
   public:
     int&amp; publishAsSecret()
     {
       return secretCode;
     }
 };
 
 int main()
 {
   B* b = new B();
   A* a = b;
 
   cout << "a = " << (*a) << endl;
 
   int&amp; theSecret = b->publishAsSecret();
   theSecret = 666;
 
   cout << "a = " << (*a) << endl;
 
   char c; cin >> c;
 
   return 0;

 }
]]><para/><![CDATA[
 a = I am an A. My secret is 1234
 a = I am an A. My secret is 666
]]><para>
              Finally, declaring data dields protected may also introduce high maintenance costs.
              When the implementation of a class is changed (e.g. the data fields which store
              internally the state information of instances of that class), then one has to search
              for all subclasses in order to check if they require corresponding changes.</para>
            <para/>
          </section>
        </section>
        <section>
          <title> Public, Protected and Private Subclassing</title>
          <para> The <literal>Employee</literal> class was publicly derived from the
            <literal>Person</literal> class:</para>
          <para/><![CDATA[
 class Employee: public Person {...};
]]><para> During public subclassing
            the access levels of the superclass members are not modified: </para>
          <itemizedlist>
            <listitem>
              <para>
                <literal>public</literal> members of the superclass are also
                <literal>public</literal> members of the subclass. </para>
            </listitem>
            <listitem>
              <para>
                <literal>protected</literal> members of the superclass are also
                <literal>protected</literal> members of the subclass. </para>
            </listitem>
            <listitem>
              <para>
                <literal>private</literal> members of the superclass remain private to that class.</para>
            </listitem>
          </itemizedlist>
          <para> C++ provides no way of making <literal>private</literal> or
            <literal>protected</literal> members of the superclass<literal>public</literal> members
            of the subclass -- i.e. it is not possible to increase access to the superclass members
            during subclasses.</para>
          <para> On the other hand, C++ does provide mechanisms to reduce the access level during
            subclassing. This is achieved via <literal>protected</literal> or
            <literal>private</literal> subclassing. The former reduces<literal>public</literal>
            members of the superclass to <literal>protected</literal> members of the subclass. The
            latter reduces the access level of all superclass members to <literal>private</literal>
            within the subclass.</para>
          <para> For example, had we used <literal>private</literal> or <literal>protected</literal>
            subclassing when deriving the <literal>Employee</literal> class from the
            <literal>Person</literal> class, e.g.</para>
          <para/><![CDATA[
 class Employee: protected Person {...};
]]><para>then the following code
            would result in compilation errors:</para>
          <para/><![CDATA[
 Employee employee("Peter", "7011115353100");
 
 cout << employee.name(); // name() not accessible for employees.
]]><para/>
          <section>
            <title> Should you Actually use Private or Protected Subclassing?</title>
            <para> Private and protected subclassing actually violate the core principal behind
              subclassing, substitutability: If anybody requires, say, a <literal>Person</literal>
              you should be able to provide them with any object which is a
              <literal>Person</literal>, i.e. with any instance of any subclass.</para>
            <para> For example, I may use a primitive authentication routine which authenticates a
              <literal>Person</literal> by matching name and id number. The method header could look
              something like this:</para>
            <para/><![CDATA[
 void authenticate(const Person&amp; person);
]]><para> The method
              could use the <literal>name()</literal> and <literal>idNo()</literal> services to do
              the simple authentication. But <literal>authenticate()</literal> can be called
              providing anything which is a <literal>Person</literal> as argument, for example, an
              <literal>Employee</literal>. This can only work if the public members of
              <literal>Person</literal> are also public members of <literal>Employee</literal> --
              i.e. if <literal>Employee</literal> is publicly derives from <literal>Person</literal>.</para>
            <para> Java and UML only cater for public subclassing --it is the only form of
              subclassing which is compatible with the logical framework of object-orientation.</para>
            <para/>
          </section>
        </section>
        <section>
          <title> Overriding Methods</title>
          <para> Note that the <literal>Person</literal> class has a method,
            <literal>toString</literal>, allowing the user to obtain a string representation of the
            class. The <literal>Employee</literal> class would inherit this functionality. The
            developers have, however, chosen to supply a separate <literal>toString()</literal>
            method for the <literal>Employee</literal> class which overrides the
            <literal>Person</literal>'s <literal>toString()</literal> method. In its function body
            it first calls<literal>Person</literal>'s <literal>toString()</literal> method via
            <literal>Person::toString()</literal> and adds its own information to the string
            representation of the <literal>Person</literal> class.</para>
          <para/>
        </section>
        <section>
          <title> Polymorphism and Virtual Methods</title>
          <para> Polymorphism can be seen as message abstraction. You send an abstract message to an
            object and the recipient of the message interprets the message within its own context.</para>
          <para> A very simple illustration of polymorphism at work is shown below:</para>

          <para/><![CDATA[
 Person* person = NULL;  // Initializing reference to null reference
 
 person = new Person("Peter Smith", "631112 5225 087");
 string str = person->toString();
 cout << str << endl;
 
 person = new Employee("Tandi Ndlovu", "732232 1121 087", 8000.00);
 str = person->toString();
 cout << str << endl;
]]><para>
            In both cases we say <literal>person-&gt;toString()</literal>, but in the first case the
            recipient of the<literal>toString()</literal> message is a vanilla
            <literal>Person</literal>, while in the second case the recipient is a
            <literal>Employee</literal>. The recipient of the message interprets within its own
            context. Thus the <literal>Person::toString()</literal> method will be called in the
            first instance, while the <literal>Employee::toString()</literal> method will be called
            in the second.</para>
          <para> Note that a language which supports polymorphism must allow for dynamic binding
            (run-time linking). Take the above example. We could have asked the user at run-time
            whether he/she wants to create a <literal>Person</literal> or a
            <literal>Employee</literal>. Hence, only at run-time would it be known whether the
            <literal>toString()</literal> method of <literal>Person</literal> or
            <literal>Employee</literal> should be called. Run-time linking is requested in C++ by
            declaring a method<literal>virtual</literal>:</para>

          <para/><![CDATA[
 class Person
 {
   public:
     ...
 
     virtual string toString() const;
 
     ...
 };
]]><para>
            This implies that any request for the <literal>toString()</literal> service offered by
            any type of person (e.g. an instance of the <literal>Person</literal> or the
            <literal>Employee</literal> class) which is sent through a pointer will be resolved at run-time:</para>
          <para/><![CDATA[
 #include <iostream.h>
 
 #include "Person.h"
 #include "Employee1.h"
 
 #include <condefs.h>
 USEUNIT("Person.cpp");
 USEUNIT("Employee1.cpp");
 
 void printPersonA(Person* person)
 {
   cout << "printPersonA: " << person->toString() << endl;
 }
 
 void printPersonB(Person person)
 {
   cout << "printPersonB: " << person.toString() << endl;
 }
 
 void main()
 {
   Person* p1 = new Person("Jack", "6811125657102");
   Person* p2 = new Employee1("Jill", "6910825655105", 210000);
 
   printPersonA(p1);    printPersonA(p2);
   printPersonB(*p1);   printPersonB(*p2);
 
   cout << (*p1) << endl;
   cout << (*p2) << endl;
 
   char c; cin >> c;
 }
]]><para/>
        </section>
        <section>
          <title> Polymorphic Collections</title>
          <para> Let us further illustrate polymorphism via a simple polymorphic collections. We
            shall use a primitive array for this. Collection classes are supplied with the Standard
            Template Library (STL) which is part of the ANSI/C++ specification. We shall discuss
            these classes in chapter ??.</para>

          <para/><![CDATA[
 #include <iostream>
 
 #include "Person.h"
 #include "Employee.h"
 
 using namespace std;
 
 //---------------------------------------------------------------------------
 int main()
 {
   const int numPersons = 3;
   Person** persons = new Person*[numPersons];
   persons[0] = new Person("Alfred", "588753287");
   persons[1] = new Employee("Pieter", "618732987", 196000);
   persons[2] = new Person("Petra", "8109894542424");
 
   for (int i=0; i<numPersons; ++i)
     cout << persons[i]->toString() << endl;
 
   for (int i=0; i<numPersons; ++i)
     delete persons[i];
   delete[] persons;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para>
            In the above program we add persons and employees to our polymorphic collection of
            persons. Then we print out the string representation of each person. The
            <literal>toString()</literal> method is resolved polymorphically (via dynamic binding at
            run-time), i.e. at run-time the message is sent to the object and the object uses its
            own <literal>toString()</literal> method. If it does not have
            a<literal>toString()</literal> method the corresponding method of its superclass is
            used. The output of the program is listed below:</para>
          <para/><![CDATA[
 Alfred: 588753287
 Pieter: 618732987 (salary = 196000.000000)
 Petra: 8109894542424
]]><para/>
        </section>
      </section>
      <section>
        <title> Multiple Inheritance</title>
        <para> At times a class can be naturally viewed as a specialization of more than one class.
          For example, en <literal>EmployedClient</literal> class could be viewed as a
          specialization of both, the <literal>Employee</literal> and the <literal>Client</literal>
          class (see figure <ulink url="#x1-1200011">
            <!--ref: figEmployedClient-->
          </ulink>). </para>
        <figure>
          <title/>
          <blockquote>
            <para/>
            <section role="center">
              <title/>
              <para>
                <graphic width="72.26999pt" fileref="Abstraction/EmployedClient.pdf"/>
              </para>
            </section>
            <blockquote role="caption">
              <title role="caption"> Figure 4.1</title>
              <para>An employed client is a client and an employee.</para>
            </blockquote>
          </blockquote>
        </figure>
        <para> Indeed, the is a test is satisfied along both legs, an
          <literal>EmployedClient</literal> is an <literal>Employee</literal> and is a client.
          Hence, if somebody expects an <literal>Employee</literal>
        </para>

        <para/><![CDATA[
 double restructureSalary(Employee&amp; employee)
 {
   ...
 }
]]><para>you
          should be able to pass any <literal>Person</literal> which is an
          <literal>Employee</literal>, i.e. an instance of <literal>Employee</literal> or an
          instance of the <literal>EmployedClient</literal> class.</para>
        <para> Similarly, if somebody expects a <literal>Client</literal>
        </para>

        <para/><![CDATA[
 void debitMonthlyServiceFees(Client&amp; client)
 {
   ...
 }
]]><para>
          Unlike Java, C++ does support multiple inheritance of classes, i.e. a class can be a
          subclass of more than one class. </para>
        <section>
          <title> Simplistic Multiple Inheritance and its Problems</title>
          <para> Let us simplistically define a <literal>Client</literal> class as follows:</para>

          <para/><![CDATA[
 #ifndef Client_H
 #define Client_H
 
 #include "Person.h"
 #include "Account.h"
 
 class Client1: public Person
 {
   public:
     Client1(const string&amp; name, const string&amp; idNo, Account&amp; account);
 
     Account&amp; account() const;
 
   private:
     Account&amp; _account;
 };
 #endif
]]><para>
            We provide a trivial implementation of this class in:</para>

          <para/><![CDATA[
 #include "Client1.h"
 
 Client1::Client1(const string&amp; name, const string&amp; idNo, Account&amp; account)
          : Person(name, idNo), _account(account) {}
 
 Account&amp; Client1::account() const {return _account;}
]]><para>
            Now we are in a position to define an <literal>EmployedClient</literal> class. Let us
            simply define a join class which adds no new services above those inherited from the
            <literal>Employee</literal> and <literal>Client</literal> superclasses:</para>

          <para/><![CDATA[
 #ifndef EmployedClient1_H
 #define EmployedClient1_H
 
 #include "Client1.h"
 #include "Employee1.h"
 
 class EmployedClient1: public Employee1, public Client1
 {
   public:
     EmployedClient1(const string&amp; name, const string&amp; idNo,
                     const double&amp; salary, Account&amp; account);
 };
 #endif
]]><para>
            We provide a trivial implementation of this class in:</para>

          <para/><![CDATA[
 #include "EmployedClient1.h"
 
 EmployedClient1::EmployedClient1(const string&amp; name, const string&amp; idNo,
                                  const double&amp; salary, Account&amp; account)
   : Employee1(name, idNo, salary), Client1(name, idNo, account) {}
]]><para>
            Now, when we use instances of the the <literal>EmployedClient</literal> class, we can
            directly ask them for their salary or their account:</para>

          <para/><![CDATA[
 #include <iostream>
 
 #include "Account.h"
 #include "Person.h"
 #include "Client1.h"
 #include "Employee1.h"
 #include "Manager.h"
 #include "EmployedClient1.h"
 
 using namespace std;
 
 //---------------------------------------------------------------------------
 int main()
 {
   Account account;
   EmployedClient1* employedClient
     = new EmployedClient1("Peter", "546464389672", 190000, account);
 
   cout << employedClient->salary() << endl;
   Account&amp; acc = employedClient->account();
   acc.credit(700);
   cout << acc.balance() << endl;
 
   Employee1* e = employedClient;
 
 /*
   Person* p = employedClient;  // Compiler error: cannot convert
                                // EmployedClient* to Person*
 */
 
 /*
   cout << employedClient->name(); // Compiler error: Person::name
                                   // and Person::name ambiguous
 */
 
   Manager* manager = new Manager("Charles", "5753223678", 300000, "BMW 740");
 
   Person* p = manager;
 
   cout << manager->name() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para>
            There are, however, a number of severe problems: </para>
          <itemizedlist>
            <listitem>
              <para>Firstly, our employed client is an <literal>Employee</literal>, but somehow
                he/she is not a Person??? This manifests itself in that we are able to have an
                <literal>Employee</literal> pointer point to an employed client (he/she is, after
                all, an <literal>Employee</literal>), but when we try and assign a
                <literal>Person</literal> pointer to the employed client we are told that it is not
                a <literal>Person</literal>. </para>
            </listitem>
            <listitem>
              <para>Secondly, though we can make use of the inherited <literal>salary()</literal>
                and <literal>account()</literal> services we somehow do not inherit
                <literal>name()</literal> and <literal>idNo()</literal>.</para>
            </listitem>
          </itemizedlist>
          <para> But things get even stranger. Let us define anothe subclass of
            <literal>Employee</literal>, a <literal>Manager</literal> class:</para>

          <para/><![CDATA[
 #ifndef Manager_H
 #define Manager_H
 
 #include "Employee1.h"
 
 class Manager: public Employee1
 {
   public:
     Manager(const string&amp; name, const string&amp; idNo, const double&amp; salary,
             const string&amp; statusSymbol);
 
     string statusSymbol();
 
   private:
     string _statusSymbol;
 };
 #endif
]]><para>
            with implementation</para>

          <para/><![CDATA[
 #include "Manager.h"
 
 Manager::Manager(const string&amp; name, const string&amp; idNo, const double&amp; salary,
                  const string&amp; statusSymbol)
   : Employee1(name, idNo, salary), _statusSymbol(statusSymbol) {}
 
 string Manager::statusSymbol() {return _statusSymbol;}
]]><para>
            If we create an instance of this class then we can assign a <literal>Person</literal>
            pointer to it and we can request the <literal>name()</literal> and
            <literal>idNo()</literal> services. So why could we not do it for<literal>Employee</literal>s.</para>
          <para> The answer lies in the way we derived <literal>Employee1</literal> and
            <literal>Client1</literal> from <literal>Person</literal>. The default thing C++ does
            is, from an object-oriented perspective, incorrect.</para>
          <para> Recall that when we instantiate a class, all its superclasses are instantiated too.
            So, when we create an <literal>Employee</literal> we create a <literal>Person</literal>,
            and similarly, creating a <literal>Manager_</literal>creates
            an<literal>Employee</literal> which creates a <literal>Person</literal>. So far, no
            problem -- and indeed, the <literal>Manager</literal> class behaved correctly.</para>
          <para> Lets look wha<span class="accentudot">h</span>appens in the
            <literal>EmployedClient</literal> case. Creating an <literal>EmployedClient</literal>
            creates both, an <literal>Employee</literal> as well as a <literal>Client</literal>.
            Each of these, in turn, creates a <literal>Person</literal>.
            Our<literal>EmployedClient</literal> class is thus two persons and not a single person.
            That is why we could not assign a <literal>Person</literal> pointer to the
            <literal>EmployedClient</literal>. Also, when we requested the<literal>name()</literal>
            service the compiler did not know which person's name he/she/it should choose.</para>
          <para> This is, of course, nonsensical. An employed client is of course an employee, as
            well as a client and a single person. Any other scenario does not make logical sense.
            This is, however, not the way it is seen by default in C++. So how do we fix it?</para>
          <para/>
        </section>
        <section>
          <title> Virtual Specialization</title>
          <para> We want to specify that every client and every employee is a single
            <literal>Person</literal>. This is specified by inserting the <literal>virtual</literal>
            keyword in the inheritance link. This has to be done when deriving both,
            <literal>Client</literal> class</para>

          <para/><![CDATA[
 #ifndef Client_H
 #define Client_H
 
 #include "Person.h"
 #include "Account.h"
 
 class Client: public virtual Person
 {
   public:
     Client(const string&amp; name, const string&amp; idNo, Account&amp; account);
 
     Account&amp; account() const;
 
   private:
     Account&amp; _account;
 };
 #endif
]]><para>
            and the employee class</para>

          <para/><![CDATA[
 #ifndef Employee_H
 #define Employee_H
 
 #include <iostream>
 
 #include "Person.h"
 
 using namespace std;
 
 class Employee: public virtual Person
 {
   public:
     Employee(const string&amp; name, const string&amp; idNo,
              const double&amp; salary);
 
     double salary() const;
 
     void salary(const double&amp; newSalary);
 
     string toString() const;
 
   //friends:
     friend ostream&amp; operator<< (ostream&amp; os, const Employee&amp; e);
 
   private:
     double _salary;
 };
 #endif
]]><para>
            from the verb+Person+ class. The implementations of these classes are identical to the
            implementations of the <literal>Employee1</literal> and <literal>Client</literal>
            classes shown above.</para>
          <para> The header of the <literal>EmployedClient</literal> class could remain as above,
            though we do change the inheritance links to virtual for reasons discussed below.</para>

          <para/><![CDATA[
 #ifndef EmployedClient_H
 #define EmployedClient_H
 
 #include "Client.h"
 #include "Employee.h"
 
 class EmployedClient: public virtual Employee, public virtual Client
 {
   public:
     EmployedClient(const string&amp; name, const string&amp; idNo,
                    const double&amp; salary, Account&amp; account);
 };
 
 #endif
]]><para>
            We have to modify the implementation of the constructor, though. Not only do we have to
            specify how the direct subclasses are isntantiated, but we also have to specify how the
            one and only instance of the <literal>Person</literal> class is created:</para>

          <para/><![CDATA[
 #include "EmployedClient.h"
 
 EmployedClient::EmployedClient(const string&amp; name, const string&amp; idNo,
                                const double&amp; salary, Account&amp; account)
   : Employee(name, idNo, salary), Client(name, idNo, account),
     Person(name, idNo) {}
]]><para>
            Now things do behave correctly as illustrated in the code below:</para>

          <para/><![CDATA[
 #include <iostream>
 
 #include "Account.h"
 #include "Person.h"
 #include "Client.h"
 #include "Employee.h"
 #include "EmployedClient.h"
 
 using namespace std;
 
 int main()
 {
   Account account;
   EmployedClient* employedClient
     = new EmployedClient("Peter", "546464389672", 190000, account);
 
   cout << employedClient->salary() << endl;
   Account&amp; acc = employedClient->account();
   acc.credit(700);
   cout << acc.balance() << endl;
 
   cout << employedClient->name() << endl;
 
   Person* p = employedClient;
   cout << p->idNo() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para>
            Note that we had to realize the potential problem early, i.e. when we defined
            the<literal>Client</literal> and <literal>Employee</literal> subclasses -- not when we
            did our multiple inheritance thing. At that stage it may not have dawned on us that we
            will one day have employed clients which are both employees and clients. One ust has to
            have this mystical feeling.</para>
          <para> No, more seriously, specialization should, from an object-oriented perspective,
            allways be<literal>virtual</literal>. If you define a non-virtual subclass, then you are
            specifying what is known in UML as a <literal>{disjoint}</literal> constraint -- i.e.
            that all subclasses of that class may not multply inherit from any classes within that
            particular class hierarchy.</para>
          <para/>
        </section>
      </section>
      <section>
        <title> Abstract Classes</title>
        <para> So far all our classes were concrete, i.e. we were able to create instances of them.
          At times one wants to introduce classes without having the intention of actually
          instantiating them. The reasoning may be that one still wants to encapsulate some
          commonalities accross classes within a single superclass, but that the class which
          encapsulates these commonalities by itself. Such a class would be an abstract class.</para>
        <para> For example, all assets have, say an id. Specialized assets like properties,
          vehicles, government or corporate bonds, ..., can be created, but one would never create
          just simply an asset. Still, one would want to define a <literal>Asset</literal> class
          encapsulating all the commonalities among all assets (the asset id in our case). The asset
          class would be, conceptually, an abstract class.</para>
        <para/>
        <section>
          <title> How to Declare a Class with Concrete Methods Abstract</title>
          <para> C++, unlike Java, does not have a mechanism for declaring a class directly
            abstract. What we need to achieve is that the class can only be instantiated from within
            the context of one of its subclasses. But this can be done simply by declaring its
            constructors with<literal>protected</literal> access level:</para>

          <para/><![CDATA[
 class Asset
 {
   public:
     string id() const {return _id;}
 
   protected:
     Asset(const string&amp; id) _id(id) {}
 
   private:
     string _id;
 };
]]><para>
            Abstract classes usually have at least one concrete subclass, i.e. one which can be
            instantiated. For example</para>
          <para/><![CDATA[
 class Bond: public Asset
 {
   public:
     Bond(string id, Date maturity, double notional, ...);
     ...
 }
]]><para/>
        </section>
        <section>
          <title> Abstract Methods for Interface Definition</title>
          <para> One of the main advantages of abstract classes is that they can incorporate
            interface specifications via abstract methods. Assume, for example, that all assets can
            be queried for their value on a specific date. How the value of an asset is calculated
            depends on the type of asset. We want to specify, however, that all assets have a
            service for querying the value, i.e. that they all must be able to process a
            <literal>getValue(Date)</literal> message. This is donme in C++ by adding an abstract
            method -- i.e. a method for which there is no implementation -- to the class:</para>
          <para/><![CDATA[
 virtual Tender value(const Date&amp; date) = 0;
]]><para>Of course,
            we do not know how to value an abstract asset. An abstract method is one which has no
            method body. A class which has one or more abstract methods is implicitly an abstract
            class and can hence not be instantiated.</para>
          <para/>
        </section>
        <section>
          <title> SubClassing Abstract Classes</title>
          <para> Subclasses of abstract classes must either comply to the specifications laid down
            in the abstract superclass (i.e. provide implementations for the abstract methods of the
            superclass) or they must be declared abstract themselves.</para>
          <para> For example, subclasses of the abstract <literal>Asset</literal> class must provide
            an implementation for the <literal>value(Date)</literal> service. If they don't, the
            compiler will regard the subclass itself still as abstract. The reason for this is that
            the subclass does not fulfill the requirements laid down in the superclass. Since an
            abstract class cannot be instantiated, the compiler ensures that there will be no
            <literal>Asset</literal> objects (instances of the <literal>Asset</literal> class) which
            cannot be valued.</para>
          <para/>
        </section>
        <section>
          <title> Abstract, Virtual and Non-Virtual Methods</title>
          <para> There are three types of service specifications you can define in a class which may
            be subclassed: </para>
          <itemizedlist>
            <listitem>
              <para>Pure specifications for services which must be supplied by concrete subclasses. </para>
            </listitem>
            <listitem>
              <para>Services with default implementations which may be overridden. </para>
            </listitem>
            <listitem>
              <para>Services with a fixed implementation which you should NOT override.</para>
            </listitem>
          </itemizedlist>
          <para>Each of these is dicussed seperately below.</para>
          <para/>
          <section>
            <title> Abstract or pure virtual methods</title>
            <para> Abstract methods lay down specifications for services which must be supplied by
              concrete subclasses. No implementation (body) is supplied for abstract methods -- the
              implementation must be supplied by the concrete subclasses. In this case one inherits
              only a requirements specification.</para>
            <para> An abstract method must be declared <literal>virtual</literal> and is specified
              by an <literal> = 0 </literal> behind the message header:</para>
            <para/><![CDATA[
 virtual Tender value(const Date&amp; date) = 0;
]]><para> Abstract
              or pure virtual methods are allways hosted by abstract classes.</para>
            <para/>
          </section>
          <section>
            <title> Concrete virtual methods</title>
            <para> Non-abstract virtual methods still require subclasses to provide the specified
              service, but if they do not supply their own implementation, a default implementation
              is provided by the superclass. This default implementation may, but need not, be
              overridden in the subclass.</para>
            <para> A concrete virtual method is thus specified with an implementation. For example,
              an account class may have a virtual <literal>debit</literal> method specifying that
              all accounts must supply such a service and providing a default implementation in
              which the balance is simply adjusted with the debit amount.</para>
            <para> Specialized subclasses like <literal>CreditCard</literal>,
              <literal>ChequeAccount</literal> or <literal>HomeLoan</literal> may override this
              method with their specialized implementation (for example, subtracting a transaction
              fee), but they may also choose to simply inherit the default implementation.</para>
            <para> A concrete virtual method is simply a <literal>virtual</literal> method with a
              supplied function body:</para>
            <para/><![CDATA[
 virtual void debit(double amount) { _balance -= amount;}
]]><para/>
          </section>
          <section>
            <title> Non-virtual methods</title>
            <para> Non-virtual methods should be regarded as methods with a fixed implementation
              which subclasses should NOT override. C++ does not prevent the method from being
              overridden, but if you do, you may get unexpected behaviour. They are specified as
              methods without the<literal>virtual</literal> keyword.</para>
            <para> For example, we might want to specify that the <literal>authenticate</literal>
              method should not be overridden in specialized <literal>User</literal> classes, i.e.
              no matter how special the user, when he is authenticated the block of code specified
              in the <literal>User</literal> class should be executed:</para>

            <para/><![CDATA[
 class User
 {
   public:
     ...
     void authenticate() { ... }
     ...
 };
]]><para>
              Non-virtual methods are linked statically (i.e. at compile time). They do not support
              polymorphism and should only be used if you want to specify that that particular
              method may not be overridden. By default, you should define your methods<literal>virtual</literal>.</para>
            <para> So, why is it so bad to override non-virtual methods. Simply because your system
              may exhibit strange, unexpected behaviour. The problem is illustrated in the following
              little program where we have an instance of a class <literal>A</literal> providing a
              virtual method<literal>f()</literal> and a non-virtual method, <literal>g()</literal>.
              Both methods are overridden in a subclass,<literal>B</literal>.</para>

            <para/><![CDATA[
 #include <iostream.h>
 
 class A
 {
   public:
     void virtual f()
     {
       cout << "Requested virtual service f() from an instance of A."
            << endl;
     }
     void g()
     {
       cout << "Requested non-virtual service g() from an instance of A."
            << endl;
     }
 };
 
 class B: public virtual A
 {
   public:
     void virtual f()
     {
       cout << "Requested virtual service f() from an instance of B."
            << endl;
     }
     void g()
     {
       cout << "Requested non-virtual service g() from an instance of B."
            << endl;
     }
 };
 
 void main()
 {
   B* b = new B();
 
   A* a = b;   // legal because a B is an A.
   // We have 2 pointers to the same object, an instance of B.
 
   cout << "Requesting virtual service f():" << endl;
   cout << "  We request the same service from the same object through" << endl;
   cout << "  two different message paths (two different pointers."
        << endl << endl;
 
   a->f();
   b->f();

 
   cout << endl << "Behaved as expected. Now requesting non-virtual service g():"
        << endl;
   cout << "  Once again we request the same service from the same object" << endl
        << "  through two different message paths (two different pointers."
        << endl << endl;
           date
   a->g();
   b->g();
 
   cout << endl << "This time the object behaved differently, depending on the"
        << endl
        << "message path (pointer) used to deliver the service request message."
        << endl;
 
   char c; cin >> c;
 }
]]><para>
              The poutput of the application is</para>

            <para/><![CDATA[
 Requesting virtual service f():
   We request the same service from the same object through
   two different message paths (two different pointers.
 
 Requested virtual service f() from an instance of B.
 Requested virtual service f() from an instance of B.
 
 Behaved as expected. Now requesting non-virtual service g():
   Once again we request the same service from the same object
   through two different message paths (two different pointers.
 
 Requested non-virtual service g() from an instance of A.
 Requested non-virtual service g() from an instance of B.
 
 This time the object behaved differently, depending on the
 message path (pointer) used to deliver the service request message.
]]><para>
              Note that we create an instance of <literal>B</literal> and have an
              <literal>B*</literal> and and <literal>A*</literal> pointing to this one and only
              object. We then request the service <literal>f()</literal> through both of these
              pointers, and, as expected, <literal>B::f()</literal> is called in both cases. After
              all, we only have a<literal>B</literal>.</para>
            <para> We then request the non-virtual service <literal>g()</literal> through both of
              these pointers, but now <literal>B</literal>'s service <literal>g()</literal> is
              supplied when we request the service through the <literal>B*</literal> and A's
              <literal>g()</literal> when the service is requested through the
              <literal>A*</literal>. We never requested the service from an <literal>A</literal>
              though -- there isn't even an <literal>A</literal>. We requested the same service from
              the same object and it does different things. This is not behaviour we want to see in
              clean object-oriented systems, and hence a non-virtual method should not be overridden.</para>
            <para/>
          </section>
        </section>
      </section>
      <section>
        <title> C++ and Interfaces</title>
        <para> Interfaces have become a very important concept in the software world. Not only do
          the Unified Modeling Language (UML) and Java directly support the concept of an interface,
          but a lot of the progress in the software development industry has been around interfaces.</para>
        <para> For example, the entire CORBA specification published by the OMG is only an interface
          specification. So is the EJB framework published by Sun. Most new class libraries are
          designed around interfaces. These include the Standard Template Library of C++, the Java
          Messaging, Transaction and Services (JMS and JTS) and many others.</para>
        <para> An interface simply specifies a set of services which classes which implement the
          interface must supply. As such an interface is like an abstract class with only abstract
          methods -- and, yes, this is the way you implement interfaces in C++.</para>
        <para> For example, you may specify that any class which claims to be a source of interest
          rates should implement an <literal>InterestRateSource</literal> interface which requires
          the implementing classes to supply two services:</para>

        <para/><![CDATA[
 class InterestRateSource
 {
   public:
 
     virtual InterestRate getRate(const Date&amp; date1, const Date&amp; date2) const = 0;
 
     virtual double getDiscountFactor(const Date&amp; date1, const Date&amp; date2) const = 0;
 };
]]><para>
          A wide range of classes could potentially supply these services. Here we list a few in
          order to illustrate how totally different their implementations can be: ReutersRateSource
          which reports the current market rates as perceived by Reuters. ZeroCurve which stores
          spot interest rates for investements of different durations made at the spot date. This
          class would calculate interest rates over periods covered by the curve from the spot
          rates. DealerWindow which pops up on the terminal of a dealer on the interest rate desk.
          He/she is expected to know the market and would be in a position to supply the interest
          rate for a supplied period. BondPortfolio which contains a collection of priced Bonds.
          Interest rates for a given period can be calculated from the bond prices.</para>
        <para> These different implementation have virtually nothing in common, except, that they
          all can provide the service. But why should you lock within your code into a specific
          service provider. If your code couples to the interface instead, you will be able to plug
          in any implementation of an interest rate source. You are thus decoupling from specific
          implementations and have the basics of plug-and-play programming.</para>
        <para/>
      </section>
      <section>
        <title> Exercises</title>
        <para/>
        <orderedlist>
          <listitem>
            <para>Define an interface <literal>Asset</literal> as an abstract class. One should be
              able to query the value of an asset for a supplied <literal>Date</literal>. Define the
              concrete assets, <literal>Vehicle</literal> and <literal>Property</literal>. When
              creating a <literal>Vehicle</literal> one should specify the purchase price and date
              as well as the write-off period in years. Assume the vehicle is written off linearly
              over the write-off period. Properties also have a purchase price and date. Assume, for
              sake of simplicity, that properties neither loose nor gain value. Define further a
              portfolio class to which you can add assets. The portfolio itself is, also an asset.
              Now create two portfolios, each with a property and a vehicle and add the one
              portfolio to the other (after all, a portfolio is an asset too). Query todays value of
              the portfolio. To help you work with dates look at the following functions defined in
              <literal>time.h</literal>: difftime which calculates the time in milliseconds between
              two times. mktime which makes a <literal>time_t</literal> from a <literal>tm</literal>
              structure. localtime which creates a <literal>time_t</literal> representing the
              current date/time. </para>
            <para>For simplicity, assume each year has 365 days.</para>
          </listitem>
        </orderedlist>
        <para/>
      </section>
    </section>
    <!--end chapter-->
    <section role="chapter">
      <title> Classes using Dynamic Memory: Vectors and Matrices </title>
      <section>
        <title> Introduction</title>
        <para> Among the most important data types in science and engineering are vectors and
          matrices. Traditionally one defined an array of floating point or complex numbers and
          separately a set of subroutines or functions which manipulate these arrays. In this
          chapter we build complete abstract data types for vectors and matrices which allow us to
          simplify our programs considerably. Consider, for example, the following code extract:
          </para><![CDATA[
 void main()
 {
   Matrix<double> A(3,4), B(4,3), C(3,3);  // defining 3 matrices of differing dimensions
   Vector<double> v1(3);
   ...
   Vector<double> v2 = (A*B-3*C)*v1;
   cout << "resultant vector = " << v2 << endl;
 }
]]><para>
          will be legal code once we have defined our vector and matrix classes. We shall also see
          how the various data types interlink. For example, we shall use our vector class to define
          vectors of rational numbers which we can add, multiply, ....</para>
        <para> Naturally, we would like our vectors and matrices to use dynamic memory. We want to
          be able to define vectors and matrices of any size (within the hardware limits) and we
          want to be able to release this memory as soon as we no longer need these data structures.</para>
        <para/>
      </section>
      <section>
        <title> The Vector Class</title>
        <para/>
        <section>
          <title> Introduction</title>
          <para> We shall develop a vector class which supports (among other things) all the
            standard vector operations like vector addition, dot products, Kronecker and Hadamard
            products, normalization and the calculation of various vector norms.</para>
          <para/>
        </section>
        <section>
          <title> Static Members of a Class </title>
          <para> Usually we want to encapsulate variables within an object. For example, each
            instance of the class <literal>Rational</literal> has a numerator and a denominator.
            These data members are encapsulated within an object by declaring them private data members.</para>
          <para> Sometimes we want to have all instances of a certain class share a single class
            constant or class variable. We want to encapsulate such data members within a class --
            we do not want to use global variables or constants.</para>
          <para> For example, one might want to know how many instances of a certain class (e.g. the
            number of clients a bank) exist at certain instant during program execution. In such a
            case one could define a static class variable:
            </para><![CDATA[
 class Client
 {
   public:
     ...
     static long numberofinstances() const;
 
   private:
     static long _numberofinstances;
 }
]]><para>
            Here <literal>_numberofinstances</literal> is a static class variable -- there exists
            only one such variable shared by all instances of the class. Of course we cannot
            initialize static variables in the constructors of the class -- the variable would be
            initialized every time we create a new instance of that class. The initialization can be
            in the implementation file, say VECTOR.CPP, as a free-standing declaration
            </para><![CDATA[
 template<class T> const int Vector<T>::_defaultprecision = 4;
 template<class T> const int Vector<T>::_defaultwidth     = 7;
]]><para>
            If we had declared the static variable public, we could have accessed it either via an
            instance of the class or directly, i.e. the following code would be legal:
            </para><![CDATA[
 void main()
 {
   cout << "Currently there are " << Vector<double>::_numberofinstances
        << "instances of the Vector<double> class." << endl;
 
   Vector<double> v1;
 
   cout << "Currently there are " << v1._numberofinstances
        << "instances of the Vector<double> class." << endl;
 }
]]><para>
            For obvious reasons of encapsulation we have declared this static variable private
            instead -- otherwise we could not really be sure that it holds the value of the number
            of instances of that class (user-code could have modified it directly). Instead we give
            access via a public static function <literal>numberofinstances()</literal>. Again, we
            can call this function even if there does not exist an instance of the class as is shown
            in the code below
            </para><![CDATA[
 void main()
 {
   cout << "Currently there are " << Vector<double>::numberofinstances()
        << "instances of the Vector<double> class." << endl;
 
   Vector<double> v1;
 
   cout << "Currently there are " << v1.numberofinstances()
        << "instances of the Vector<double> class." << endl;
 }
]]><para>
            In the case of the vector and especially the matrix class, we want the user to be able
            to control the precision and width with which the elements are written onto an output
            stream. We thus include methods which allow the user to query or set the
            output-precision and output-width. We define class constants
            <literal>_defaultprecision</literal> and <literal>_defaultwidth</literal> for the
            default output format. If we had not declared these class constants as static members of
            the class, every instance of that class would have a copy of these constants and we
            would initialize these class constants via the parameter list. It is, however, very
            wasteful that each instance of the class contains a copy of the identical constants.
            Instead we declare them as static class constants
            </para><![CDATA[
 template <class T> class Vector
 {
   public:
     ...
     int  outputprecision    () const;  // returns output precision
     int  outputwidth        () const;  // returns output width
     void setoutputprecision (const int precisn);
     void setoutputwidth     (const int wdth);
 
   private:
     ...
     T* _v;
     long _length;
     int _precision, _width;
     static const int _defaultprecision;
     static const int _defaultwidth;
 }
]]><para>
            and we initialize them with free-standing declarations in the file VECTOR.CPP:
            </para><![CDATA[
 //=========================================================
 // Initializing Static Class Constants
 //------------------------------------
 template<class T> const int Vector<T>::_defaultprecision = 4;
 template<class T> const int Vector<T>::_defaultwidth     = 7;
 //=========================================================
 // CONSTRUCTORS and DESTRUCTOR
 //----------------------------
 template <class T> Vector<T>::Vector ()
   : _v(NULL), _length(0),
     _precision(_defaultprecision), _width(_defaultwidth) {}
 ...
]]><para>
            Note that each objects own output precision and width (which can be altered by the user)
            are initialized to their default values in the parameter list of the constructors.</para>
          <para> Any member of a class can be declared a static member, i.e. we can have static data
            members, static member functions and even static member objects.</para>
          <para/>
        </section>
        <section>
          <title> Constructors, Destructor, Assignment Operator</title>
          <para> For classes using dynamic memory one must be particularly careful when developing
            constructors and assignment operators. One can no longer rely on the compiler to write
            these functions -- the compiler supplied versions will lead to catastrophe.</para>
          <para> Furthermore, once an instance of such a class goes out of scope, the memory which
            has been claimed by the constructors and assignment operators must be released. This is
            done by defining a destructor for the class. Again, the compiler supplied version will
            only lead to grief.</para>
          <para> In the previous section we saw that the default constructor of the vector class
            initializes the</para>
          <para/>
          <section>
            <title> Constructors</title>
            <para> From the excerpt of the class interface shown in section ?? we see that the
              vector class has a pointer <literal>v</literal> to the template type and a long
              integer <literal>_length</literal> as private variables of the class. We also showed
              in the previous section that the default constructor initializes the pointer variable
              to the <literal>NULL</literal> pointer and <literal>_length</literal> to zero. Below
              we give the implementation details for the remaining two constructors of the vector
              class:
              </para><![CDATA[
 template <class T> Vector<T>::Vector (const Vector<T>&amp; v)
   : _v(NULL), _length(0),_precision(_defaultprecision),
     _width(_defaultwidth)  {*this=v;}
 
 template <class T> Vector<T>::Vector (const long lngth)
   : _precision(_defaultprecision), _width(_defaultwidth)
 {
   #if EXCEPTIONHANDLING
     if (lngth<0) throw Exception("Vector(lngth) => lngth<0");
   #endif
   _v = new T[lngth];
   _length=lngth;
 }
]]><para>
              Note that the copy constructor is used every time you pass or return a vector by
              value. Should you omit to define one yourself, your C++ compiler will write one for
              you. The compiler-supplied version makes a byte-for-byte copy of the data members of
              the class. Thus the value of the pointer variable would simply be copied, without
              reserving separate memory for the new vector. Both vectors would use the same memory
              area with obvious catastrophical consequences. The reservation of new memory and the
              copying of the vector elements is done correctly in the assignment operator defined in
              the following section. The copy constructor simply calls our assignment operator.</para>
            <para> In the final constructor we first check that it is called with legal arguments,
              i.e. that the requested length of the vector is equal to or greater than zero. If that
              is not the case we throw an exception. This sanity checking is only done if the global
              variable <literal>EXCEPTIONHANDLING</literal> is on (=1). We use conditional
              compilation for this purpose. (See chapter ?? for a detailed discussion of exception handling).</para>
            <para> We then reserve enough memory of <literal>lngth</literal> variables of the
              template type <literal>T</literal> and set the private variable
              <literal>_length</literal> to the length of the vector.</para>
            <para/>
          </section>
          <section>
            <title> The Assignment Operator</title>
            <para> As for the copy constructor, if you omit to define an assignment operator for
              your class, your compiler will write one for you. The compiler-version will simply
              make a byte-for-byte copy of the vector fields and thus of the pointers
              <literal>_v</literal>. Consequently the two vectors would point to the same memory
              area and setting an element of the one vector would also change the relevant element
              of the second vector. If one vector goes out of scope, its memory is released, and the
              second vector will use illegal memory.</para>
            <para> Our vector class allows assigning one vector to another of different length. In
              this case we first release the memory of the first vector, grab enough memory from the
              heap for a copy of the second vector and only then we copy the vector elements. The
              resizing of the vector is done by a private member function <literal>resize</literal>

            </para><![CDATA[
 template <class T> void Vector<T>::resize (const long lngth)
 {
   #if EXCEPTIONHANDLING
     if (lngth<0)
       throw IllegalArguments("Vector::resize(lngth) => lngth<0");
   #endif
   delete[] _v;
   if (lngth>0)
    {
      _v = new T[lngth];
      _length = lngth;
    }
   else
   {
    _v = NULL;
    _length = 0;
   }
 }
]]><para>
              If the requested vector length is negative we throw and exception. Otherwise we
              release the heap-memory currently occupied by the vector and reserve enough memory for
              a vector of length <literal>lngth</literal>.</para>
            <para> Below we give the implementation details of our assignment operator:
              </para><![CDATA[
 template <class T>      // assignment operator
 Vector<T>&amp; Vector<T>::operator= (const Vector<T>&amp; v)
 {
   if (this != &amp;M)
   {
     if (_length != v._length)
       resize(v._length);
     for (long i=0; i<_length; i++)
       _v[i] = v._v[i];
   }
   return *this;
 }
]]><para>
              It is critical to check for self-assignment. Self-assignment can be more subtle than
              simply<literal>v1=v1</literal>. For example, <literal>v2</literal> could be a
              reference variable which has been set equal to <literal>v1</literal> and at a later
              stage one could have a camouflaged self-assignment of the for
              <literal>v1=v2</literal>. The check for self-assignment is not only recommended for
              reasons of effciency. If we wouldn't check whether the two vectors are of the same
              length, we would first release the memory, of the vector, then grab new memory and
              finally copy the value of the elements from memory which no longer belongs to the
              vector and which quite possibly is used elsewhere. In the case of self-assignment we
              simply return the object itself by reference (allowing concatenations of assignment
              statements). If the lengths of the two vectors differ, we resize the first vector and
              then we copy the actual vector elements.</para>
            <para/>
          </section>
          <section>
            <title> The Destructor</title>
            <para> The destructor of a class is called automatically as soon as an instance of that
              class goes out of scope. For example, if one declares a vector locally in a function,
              then as soon as one returns from the function, the destructor is called for that
              object. The function of a destructor is to perform any clean-up operation like
              releasing memory which was grabbed by the object from the heap.</para>
            <para> In the constructors and the assignment operator we reserve memory from the heap
              for our vector. As soon as an instance of <literal>Vector</literal> goes out of scope
              this memory should be released again. If one does not define a destructor, your
              overly-eager C++ compiler will go ahead and write one with an empty body for you. This
              is of course no good if your class allocates memory dynamically from the heap. In this
              case you will have to supply your own constructor. In the body for the destructor for
              the vector class we simply release the memory allocated in the constructor or the
              assignment operator
              </para><![CDATA[
 inline template <class T> Vector<T>::~Vector ()
 {delete[] _v;}
]]><para>
              Note that destructors are methods which have no arguments and no return values and
              which carry the name of the class preceded by a tilda.</para>
            <para> Destructors can be called manually: </para><![CDATA[
 Vector<double> v(100);
 ...
 delete v;
]]><para/>
          </section>
        </section>
        <section>
          <title> Element Access</title>
          <para> In standard C and C++ arrays, elements of an array are accessed via the
            subscription operator <literal>[]</literal>. We define the subscription operator for the
            vector class to do the same:
            </para><![CDATA[
 template <class T>
 inline T&amp; Vector<T>::operator[] (const long i) const
 {
   #if EXCEPTIONHANDLING
     if ((i<0) || (i>=_length))
       throw Range("Vector::operator[]:");
   #endif
   return _v[i];
 }
]]><para>
            If exception handling is switched on (see chapter ?? for a detailed discussion on
            exception handling) we perform range checking and throw the relevant exception if the
            check fails. Otherwise we return the relevant element by reference. This is a very
            important point. If we had returned the element by value we would not be able to assign
            an element to a value, i.e. the following code would not compile
            </para><![CDATA[
 Vector<double> v(3);
 ...
 double x = v[0];    // no problem
 v[0] = 1.3;         // compiler error if not returned by reference
]]><para>
            If the template type is a huge data type (we could, for example, have a vector of
            matrices) returning the element by reference has the further advantage of effciency.</para>
          <para/>
        </section>
        <section>
          <title> User's Guide to the Vector Class</title>
          <para> Below we discuss some useful methods we included in the vector class. For most of
            these methods we do not discuss the implementation details. These can be found in
            section ?? where we give a complete listing of the vector class.</para>
          <para/>
          <section>
            <title> Arithmetic Operations</title>
            <para> Vector addition and subtraction, together with the related operators
              <literal>+=</literal>, <literal>-=</literal>, are defined in a standard fashion. We
              use the multiplication operator <literal>*</literal> to denote the vector dot product
              (scalar or inner product)</para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp92x.gif" role="math-display"/>
              </informalequation> and the modulo or remainder operator <literal>%</literal> to
              denote the Kronecker product</para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp93x.gif" role="math-display"/>
              </informalequation> -- the result of the Kronecker product between two vectors is a
              matrix whose <informalequation>
                <graphic fileref="cpp94x.gif"/>
              </informalequation>'th element is equal to <informalequation>
                <graphic fileref="cpp95x.gif"/>
              </informalequation>. Recall that C++ restricts us to overloading only the built-in
              operators (used for the standard data types like <literal>float</literal> or
              <literal>int</literal>) and that we cannot alter the precedence level or the syntax of
              these operators. This does not leave us much choice when searching for an operator for
              the Kronecker product. The only operator available with the correct syntax and
              precedence level (same precedence level as multiplication) is the modulo operator --
              see table<ulink url="#x1-150031">
                <!--ref: basiccppCppops-->
              </ulink>.</para>
            <para> For element-for-element multiplication of two vectors we use the function<literal>hadamardproduct</literal>
            </para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp96x.gif" role="math-display"/>
              </informalequation> We have no suitable operators left to choose from and hence we use
              a member function instead. We have defined the arithmetic operations such that we
              maximize consistence between the vector and matrix classes.</para>
            <para> We also support mixed-type arithmetic, allowing the user to add a scalar to a
              vector or a vector to a scalar. The same holds for subtraction, multiplication or
              division of a vector by a scalar.</para>
            <para/>
          </section>
          <section>
            <title> Vector functions</title>
            <para> Our class supports vector functions. For example <literal>v1.func(exp)</literal>
              returns a vector where each element is the exponent of the relevant element in
              <literal>v1</literal>. we define two version of the func method
              </para><![CDATA[
 template <class T> class Vector
 {
   public:
     ...
     Vector<T> func (T (*f)(const T&amp;)) const;  // returns f(vec)
     Vector<T> func (T (*f)(T)) const;  // returns f(vec)
 }
]]><para>
              one of which the argument of the function is declared constant. The implementation
              details are quite simple: </para><![CDATA[
 template <class T>            // returns f(vec)
 Vector<T> Vector<T>::func (T (*f)(const T&amp;)) const
 {
   Vector<T> result(_length);
   for (long i=0; i<_length; i++)
     result._v[i] = f(_v[i]);
   return result;
 }
]]><para/>
          </section>
        </section>
        <section>
          <title> Vector Norms, Normalization, Mean, ...</title>
          <para> We define two methods <literal>norm</literal>, one for the euclidean norm</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp97x.gif" role="math-display"/>
            </informalequation> (which returns the length of a vector in euclidean space) and a
            generalized norm called the<informalequation>
              <graphic fileref="cpp98x.gif"/>
            </informalequation>-norm</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp99x.gif" role="math-display"/>
            </informalequation> Naturally the euclidean norm is a special case of the <informalequation>
              <graphic fileref="cpp100x.gif"/>
            </informalequation>-norm. The reason for supplying two methods, instead of a single
            method with default value 2 for <informalequation>
              <graphic fileref="cpp101x.gif"/>
            </informalequation> is that we can implement the euclidean norm with more effciency than
            the <informalequation>
              <graphic fileref="cpp102x.gif"/>
            </informalequation>-norm with <informalequation>
              <graphic fileref="cpp103x.gif"/>
            </informalequation>. Below we give the signatures of the two <literal>norm</literal>
            methods
            </para><![CDATA[
 template <class T> class Vector
 {
   public:
     ...
     T    norm      () const;       // Euclidean norm
     T    norm      (const double&amp; p) const;  // p-norm => (sum(|v_i|&#x02C6;p))&#x02C6;(1/p)
 }
]]><para>
            The implementations are very simple and can be found in the program listing in section
            ??. The method <literal>normalize()</literal> divides the vector elements by the
            euclidean norm of the vector resulting in a normalized vector -- a vector with unit length.</para>
          <para> The arithmetic mean of the elements of a vector</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp104x.gif" role="math-display"/>
            </informalequation> is returned by the method <literal>mean()</literal> and the sum of
            all vector elements by the method<literal>sumels()</literal>. The largest, smallest,
            largest absolute and smallest absolute element is returned by the methods
            <literal>maxel()</literal>, <literal>minel()</literal>, <literal>maxabsel()</literal>
            and <literal>minabsel()</literal> respectively. Alternatively one can obtain the index
            of the largest, smallest, largest absolute and smallest absolute element via the methods
            <literal>maxindx()</literal>, <literal>minindx()</literal>,
            <literal>maxabsindx()</literal> and <literal>minabsindx()</literal> respectively.</para>
          <para/>
          <section>
            <title> Stream Access</title>
            <para> The input and output stream operators which take a stream as first argument and a
              vector as second argument are declared friends of the class -- hence they have direct
              access to the private members of the vector class. The function uses a chaotic mapping
              with uniform density.</para>
            <para> The method
              <literal><![CDATA[insert(const Vector<T>&amp; v, const long before)]]></literal>
              returns a vector where the vector <literal>v</literal> is inserted before element no
              <literal>before</literal>. Consider the statement
              </para><![CDATA[
 Vector<double> v3 = v1.insert(v2,n);
]]><para>If
              <literal>n=0</literal> then v2 is inserted in front of v2. If
              <literal>n=v1.length()</literal>, then <literal>v2</literal> is appended to
              <literal>v1</literal>. The member function
              </para><![CDATA[
 Vector<T> Vector<T>::slice (const long istart, const long noelements,
                             const long stride=1);
]]><para>
              extracts <literal>noelements</literal> elements from the vector, starting from element
              no <literal>istart</literal>, selecting every <literal>stride</literal> elements. If
              the argument <literal>stride</literal> is not supplied, it is set equal to its default
              value <informalequation>
                <graphic fileref="cpp105x.gif"/>
              </informalequation>. Consider for example the vector <informalequation>
                <graphic fileref="cpp106x.gif"/>
              </informalequation>. Then<literal>v.slice(5,6)</literal> returns the vector <informalequation>
                <graphic fileref="cpp107x.gif"/>
              </informalequation> and <literal>v.slice(3,4,2)</literal> returns the vector<informalequation>
                <graphic fileref="cpp108x.gif"/>
              </informalequation>.</para>
            <para> As we discussed before, the member function <literal>resize(const long
              lngth)</literal> resizes the vector to the required length. Note that all elements
              will be lost. The main purpose for <literal>resize()</literal> was to allow the user
              to create an array of vectors using the default constructor and then to resize each
              vector to the required size. This will be discussed further in the matrix class. If
              the user wants to resize a vector without losing the elements he could for example use
              the following statement
              </para><![CDATA[
 v1 = v1.insert(Vector<double>(3),v1.length());
]]><para> This will
              increase the size of <literal>v1</literal>by 3 elements, keeping the the old elements
              of <literal>v1</literal> unchanged.</para>
            <para> Finally we supply a function <literal>swap(const long i, const long j)</literal>
              which simply swaps elements <literal>i</literal> and <literal>j</literal>.</para>
            <para/>
          </section>
          <section>
            <title> Vectors of user-defined data types</title>
            <para> Note that the vector class is defined on a template. Hence we define one class
              for any underlying data type and the compiler will generate the relevant type-specific
              classes himself. For example, in the following listing we define 3 vectors
              </para><![CDATA[
 Vector<int> vi(5);
 Vector<double> vd;
 Vector<Rational<long> > vr1, vr2;
 Vector<Rational<long> > vr3 = vr1 + vr2;
]]><para>
              Note that one of the vectors is a vector of rational numbers -- a user defined data
              type (see previous chapter). When adding two vectors of rational numbers the
              appropriate addition operator of the <literal>Rational</literal> class is used when
              adding elements. Similarly,when sending a vector of rational numbers to an output
              stream, the relevant output stream operator for rational numbers is automatically used
              for sending the individual elements to the output stream.</para>
            <para/>
          </section>
          <section>
            <title> The Demonstration Program</title>
            <para> On the disk accompanying this book we supply the following demonstration program
              TVECTOR.CPP which illustrates the usage and power of the vector class: </para><![CDATA[
 #include <iostream>
 #include <math.h>
 
 #include "Vector.h"
 #include "Rational.h"
 
 #include "Vector.cpp"
 #include "Rational.cpp"
 
 using namespace std;
 
 int main()
 {
   Vector<double> v1(4);
   v1[0]=-1;  v1[1]=-4;  v1[2]=3; v1[3]=0.1;
           // using element access operator
   cout << "v1 = " << v1 << endl;  // using output stream operator
 
   Vector<double> v2 = v1.func(exp);
   v2.setoutputprecision(8); v2.setoutputwidth(10);
   cout << "v2 = exp(v1) = " << v2 << endl;
 
   Vector<double> v3 = v1 + v2;     // vector addition and assignment
   cout << "v1+v2 = " << v3 << endl;
   cout << "v1*v2 = " << v1*v2 << endl;   // dot product
   cout << "v1*2  = " << v1*2 << endl;     // using member function
   cout << "2.0-v1  = " << 2.0-v1 << endl;     // using global function
 
   cout << "v1.insert(v2,2)" << v1.insert(v2,2) << endl;
 
   cout << v1.maxel() << " " << v1.minel() << " "
        << v1.maxabsel() << " " << v1.minabsel() << endl;
 
   v1.normalize();
   cout << "v1 = " << v1 << " => " << v1.norm() << endl;
 
   v1.unit(2);
   cout << "v1.unit(2) = e3 = " << v1 << endl;
 
   Vector<int> v4(20);
   for (int i=0; i<20; i++)
     v4[i] = i;
   cout << "v4 = " << v4 << endl;
   cout << "v4.slice(5,6) = " << v4.slice(5,6) << endl;
   cout << "v4.slice(3,4,2) = " << v4.slice(3,4,2) << endl;
 
   cout << "-v4 = " << -v4 << endl;  // unary minus
 
   Vector<Rational<long> > vr1(3), vr2(3);
   vr1[0] = Rational<long>(1,1);    vr2[0] = Rational<long>(17,2);

   vr1[1] = Rational<long>(1,2);    vr2[1] = Rational<long>(-21,4);
   vr1[2] = Rational<long>(1,3);    vr2[2] = Rational<long>(3,7);
 
   vr1.setoutputwidth(4);  vr2.setoutputwidth(4);
   cout << "vr1 =" << vr1 << "     vr2=" << vr2 << endl;
   cout << "(2*vr1+vr2)*vr1 = " << (*(new Rational<long>(2))*vr1+vr2)*vr1
        << "  (dot product)" << endl;
 
   try
   {
     Vector<int> v5(-1);
   }
   catch (Exception error)
   {
     cout << "*** ERROR ***: " << error.source << endl;
   }
 
   v1.random(29);
   cout << "v1 = " << v1 << endl;
   cout << "Enter vector v1: ";  cin >> v1;
   cout << "v1 = " << v1 << endl;
 
   Vector<double> vlong(100);
   vlong.random();
   cout << "long vector before sorting: " << vlong << endl;
   vlong.quickSort();
   cout << "long vector after sorting: " << vlong << endl;
 
   return 0;
 }
]]><para/>
          </section>
        </section>
        <section>
          <title> Listing of the Vector Class </title>
          <para> The interface for the vector class is defined in the header file VECTOR.H:
            </para><![CDATA[
 #include <iostream>
 #include <cstdlib>  // for srand()
 #include <assert.h>
 #include <math.h>
 
 #include "ErrHandl.h"
 
 using namespace std;
 
 #ifndef __VECTOR_H
 #define __VECTOR_H
 
 
 template <class T> class Vector
 {
   public:
     Vector ();
     Vector (const Vector<T>&amp; v);
     Vector (const long lngth);
    ~Vector ();
 
     void resize (const long lngth);
 
     T&amp; operator[] (const long i) const;  // element access
 
     long length    () const;  // returns length of vector
 
     int  outputprecision    () const;  // returns output precision
     int  outputwidth        () const;  // returns output width
     void setoutputprecision (const int precisn);
     void setoutputwidth     (const int wdth);
 
     void fill      (const T&amp; x);   // set all v_i=x
     void unit      (const long i); // set to unit vector e_i
 
     void random (const T&amp; upper=1, const T&amp; lower=0);
 
     Vector<T> insert (const Vector<T>&amp; v, const long before) const;
     Vector<T> slice  (const long istart, const long noelements,
                       const long stride=1) const;
 
     Vector<T> func (T (*f)(const T&amp;)) const;  // returns f(vec)
     Vector<T> func (T (*f)(T)) const;  // returns f(vec)
 
     T    sumels    () const;       // sum of all elements
     T    mean      () const;       // arithmetic
     T    norm      () const;       // Euclidean norm
     T    norm      (const double&amp; p) const;  // p-norm => (sum(|v_i|&#x02C6;p))&#x02C6;(1/p)
     T    maxel      () const;      // largest element
     T    minel      () const;      // smallest element

     T    maxabsel   () const;      // largest abs(element)
     T    minabsel   () const;      // smallest abs(element)
     long maxindx    () const;      // index of largest element
     long minindx    () const;      // index of smallest element
     long maxabsindx () const;      // index of largest abs
     long minabsindx () const;      // index of smallest abs
     void normalize  ();            // so that vec*vec=1
     void swap       (const long i, const long j);
     void quickSort  (long low=0, long high=-1);
 
     Vector<T> hadamardproduct (const Vector<T>&amp; v) const;
                             // element for element multiplication
 
     Vector<T>&amp; operator= (const Vector<T>&amp; v);
     Vector<T>  operator+ (const Vector<T>&amp; v) const;
     Vector<T>  operator- (const Vector<T>&amp; v) const;
     T          operator* (const Vector<T>&amp; v) const; // dot product
     Vector<T>  operator+ (const T&amp; x) const;
     Vector<T>  operator- (const T&amp; x) const;
     Vector<T>  operator* (const T&amp; x) const;
     Vector<T>  operator/ (const T&amp; x) const;
 
     void operator+= (const Vector<T>&amp; v);
     void operator-= (const Vector<T>&amp; v);
     void operator+= (const T&amp; x);
     void operator-= (const T&amp; x);
     void operator*= (const T&amp; x);
     void operator/= (const T&amp; x);
 
     Vector<T> operator+ () const;   // unary +
     Vector<T> operator- ();         // unary -
 /*
     friend ostream&amp;  operator<< (ostream&amp; os, const Vector<T>&amp; v);
     friend istream&amp;  operator>> (istream&amp; is,       Vector<T>&amp; v);
     friend Vector<T> operator*  (const T&amp; x,  const Vector<T>&amp; v);
     friend Vector<T> operator+  (const T&amp; x,  const Vector<T>&amp; v);
     friend Vector<T> operator-  (const T&amp; x,  const Vector<T>&amp; v);
 */
   private:
     T* _v;
     long _length;
     int _precision, _width;
     static const int _defaultprecision;
     static const int _defaultwidth;
 
     long partitionSmallerLarger (long low, long high, long ipivot);
 };
 
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Vector<T>&amp; v);
 
 template <class T>
 istream&amp; operator>> (istream&amp; is, Vector<T>&amp; v);
 

 template <class T>
 Vector<T> operator* (const T&amp; x, const Vector<T>&amp; v);
 
 template <class T>
 Vector<T> operator+ (const T&amp; x, const Vector<T>&amp; v);
 
 template <class T>
 Vector<T> operator- (const T&amp; x, const Vector<T>&amp; v);
 
 
 // With the Matrix class we define a global operator
 /*     Matrix<T> operator% (const Vector<T>&amp;, const Vector<T>&amp;);  */
 // which computes the Kronecker product between 2 vectors
 // and returns the result as a matrix.
 
 #endif
]]><para>
            The implementation details are given in the file VECTOR.CPP </para><![CDATA[
 #include "Vector.h"
 
 //=========================================================
 // Initializing Static Class Constants
 //------------------------------------
 template<class T> const int Vector<T>::_defaultprecision = 4;
 template<class T> const int Vector<T>::_defaultwidth     = 7;
 //=========================================================
 // CONSTRUCTORS and DESTRUCTOR
 //----------------------------
 template <class T> Vector<T>::Vector ()
   : _v(NULL), _length(0),
     _precision(_defaultprecision), _width(_defaultwidth) {}
 //---------------------------------------------------------
 template <class T> Vector<T>::Vector (const Vector<T>&amp; v)
   : _v(NULL), _length(0),_precision(_defaultprecision),
     _width(_defaultwidth)  {*this=v;}
 //---------------------------------------------------------
 template <class T> Vector<T>::Vector (const long lngth)
   : _precision(_defaultprecision), _width(_defaultwidth)
 {
   #if EXCEPTIONHANDLING
     if (lngth<0) throw Exception("Vector(lngth) => lngth<0");
   #endif
   _v = new T[lngth];
   _length=lngth;
 }
 //---------------------------------------------------------
 template <class T> inline Vector<T>::~Vector ()
 {delete[] _v;}
 //---------------------------------------------------------
 template <class T> inline long Vector<T>::length () const
 {return _length;}
 //---------------------------------------------------------
 template <class T> inline int Vector<T>::outputprecision () const
 {return _precision;}
 //---------------------------------------------------------
 template <class T> inline int Vector<T>::outputwidth () const
 {return _width;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::setoutputwidth (const int wdth)
 {
   #if EXCEPTIONHANDLING
     if (wdth<=0)
       throw IllegalArguments("Vector::setoutputwidth(wdth)");
   #endif
   _width = wdth;
 }
 //---------------------------------------------------------

 template <class T>
 inline void Vector<T>::setoutputprecision (const int precisn)
 {
   #if EXCEPTIONHANDLING
     if (precisn<=0)
       throw IllegalArguments("Vector::setoutputwidth(precisn)");
   #endif
   _precision = precisn;
 }
 //=========================================================
 // ELEMENT ACCESS
 //---------------
 template <class T>
 inline T&amp; Vector<T>::operator[] (const long i) const
 {
   #if EXCEPTIONHANDLING
     if ((i<0) || (i>=_length))
       throw Range("Vector::operator[]:");
   #endif
   return _v[i];
 }
 //=========================================================
 // USEFUL METHODS
 //---------------
 template <class T>
 void Vector<T>::fill (const T&amp; x)
 {for (long i=0; i<_length; i++) _v[i]=x;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::unit (const long i)
 {
   #if EXCEPTIONHANDLING
     if ((i<0) || (i>=_length))
       throw Range("Vector::unit(i)");
   #endif
   fill(0);  _v[i]=1;
 }
 //---------------------------------------------------------
 
 template <class T>
 void Vector<T>::random (const T&amp; upper, const T&amp; lower)
 {
   for (long i=0; i<_length; i++)
     _v[i] = (T)rand();
 }
 
 //---------------------------------------------------------
 template <class T>    // inserts vector v into *this before element no before
 Vector<T> Vector<T>::insert (const Vector<T>&amp; v,
                              const long before) const
 {
   #if EXCEPTIONHANDLING
     if ((before<0) || (before>_length))
       throw Range("Vector::insert(v,before)");

   #endif
 
   Vector<T> result(_length+v._length);
 
   for (long i=0; i<before; i++)
     result._v[i] = _v[i];
   for (long i=0; i<v._length; i++)
     result._v[before+i] = v._v[i];
   for (long i=before; i<_length; i++)
     result._v[v._length+i] = _v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Vector<T>::slice  (const long istart,
      const long noelements, const long stride) const
 {
   long last = istart+(noelements-1)*stride;
   if ((istart<0) || (istart>=_length) || (last<0) ||
       (last>=_length)) throw Range("Vector::slice");
 
   Vector<T> result(noelements);
   long i=istart;
   for (long j=0; j<noelements; j++)
   {
     result._v[j] = _v[i];
     i += stride;
   }
   return result;
 }
 //---------------------------------------------------------
 template <class T>            // returns f(vec)
 Vector<T> Vector<T>::func (T (*f)(const T&amp;)) const
 {
   Vector<T> result(_length);
   for (long i=0; i<_length; i++)
     result._v[i] = f(_v[i]);
   return result;
 }
 //---------------------------------------------------------
 template <class T>            // returns f(vec)
 Vector<T> Vector<T>::func (T (*f)(T)) const
 {
   Vector<T> result(_length);
   for (long i=0; i<_length; i++)
     result._v[i] = f(_v[i]);
   return result;
 }
 //---------------------------------------------------------
 template <class T>            // sum of all elements
 T Vector<T>::sumels () const
 {
   T sum = 0;
   for (long i=0; i<_length; i++)

     sum += _v[i];
   return sum;
 }
 //---------------------------------------------------------
 template <class T>           // arithmetic mean of elements
 inline T Vector<T>::mean () const
 {return sumels()/_length;}
 //---------------------------------------------------------
 template <class T>           // Euclidean norm
 T Vector<T>::norm () const
 {
   T sum=0;
   for (long i=0; i<_length; i++)
   {
     T x = _v[i];
     sum += x*x;
   }
   return sqrt(sum);
 }
 //---------------------------------------------------------
 template <class T>          // so that vec*vec=1;
 void Vector<T>::normalize ()
 {
   T fact = norm();
   if (fact==(double)0)
     throw DivideByZero("Vector::normalize");
   for (long i=0; i<_length; i++)
     _v[i] /= fact;
 }
 //---------------------------------------------------------
 template <class T>        // (sum(|v_i|&#x02C6;p))&#x02C6;(1/p)
 T Vector<T>::norm (const double&amp; p) const
 {
   T sum=0;
   for (long i=0; i<_length; i++)
   {
     sum += pow(fabs(_v[i]),p);
   }
   return pow(sum,(double)1/p);
 }
 //---------------------------------------------------------
 template <class T>     // returns index of largest element
 long Vector<T>::maxindx () const
 {
   #if EXCEPTIONHANDLING
     if (_v == NULL)
       throw IllegalCall("Vector::maxindx => NULL vector");
   #endif
   long indx=0;
   T max = _v[0];
   for (int i=1; i<_length; i++)
   {
     if (max < _v[i])
     {

       indx = i;
       max  = _v[i];
     }
   }
   return indx;
 }
 //---------------------------------------------------------
 template <class T>     // returns index of smallest element
 long Vector<T>::minindx () const
 {
   #if EXCEPTIONHANDLING
     if (_v == NULL)
       throw IllegalCall("Vector::minindx => NULL vector");
   #endif
   long indx=0;
   T min = _v[0];
   for (int i=1; i<_length; i++)
   {
     if (min > _v[i])
     {
       indx = i;
       min  = _v[i];
     }
   }
   return indx;
 }
 //---------------------------------------------------------
 template <class T>   // returns index of largest abs element
 long Vector<T>::maxabsindx () const
 {
   #if EXCEPTIONHANDLING
     if (_v == NULL)
       throw IllegalCall("Vector::maxabsindx => NULL vector");
   #endif
   long indx=0;
   T max = fabs(_v[0]), x;
   for (int i=1; i<_length; i++)
   {
     if (max < (x=fabs(_v[i])))
     {
       indx = i;
       max  = x;
     }
   }
   return indx;
 }
 //---------------------------------------------------------
 template <class T> // returns index of smallest abs element
 long Vector<T>::minabsindx () const
 {
   #if EXCEPTIONHANDLING
     if (_v == NULL)
       throw IllegalCall("Vector::minabsindx => NULL vector");
   #endif

   long indx=0;
   T min = fabs(_v[0]), x;
   for (int i=1; i<_length; i++)
   {
     if (min > (x=fabs(_v[i])))
     {
       indx = i;
       min  = x;
     }
   }
   return indx;
 }
 //---------------------------------------------------------
 template <class T>        // returns largest element
 inline T Vector<T>::maxel () const
 {return _v[maxindx()];}
 //---------------------------------------------------------
 template <class T>        // returns smallest element
 inline T Vector<T>::minel () const
 {return _v[minindx()];}
 //---------------------------------------------------------
 template <class T>        // returns largest abs element
 inline T Vector<T>::maxabsel () const
 {return fabs(_v[maxabsindx()]);}
 //---------------------------------------------------------
 template <class T>        // returns smallest abs element
 inline T Vector<T>::minabsel () const
 {return fabs(_v[minabsindx()]);}
 //---------------------------------------------------------
 template <class T>        // swaps elements i and j
 inline void Vector<T>::swap (const long i, const long j)
 {
   if (i!=j)
   {
     #if EXCEPTIONHANDLING
       if ((i<0) || (j<0) || (i>=_length) || (j>=_length))
         throw Range("Vector::swap");
     #endif
     T dummy = _v[i];
     _v[i]   = _v[j];
     _v[j]   = dummy;
   }
 }
 //---------------------------------------------------------
 template <class T>
 void Vector<T>::quickSort (long low, long high)
 {
   if (high==-1)
     high=_length-1;
   if (low >= high)
     return;  // nothing to sort
 
   long ipivot = (low+high)/2;
   ipivot = partitionSmallerLarger (low,high,ipivot);

   if (low < ipivot)
     quickSort(low,ipivot-1);
   if (ipivot < high)
     quickSort(ipivot+1,high);
 }
 //---------------------------------------------------------
 template <class T>
 long Vector<T>::partitionSmallerLarger (long low, long high,
 long ipivot)
 {
   if (ipivot != low)
     swap(low,ipivot);
   ipivot = low;
   low++;
 
   while (low <= high)
   {
     if (_v[low] <= _v[ipivot])
       ++low;
     else if (_v[high] > _v[ipivot])
            --high;
          else
            swap(low,high);
   }
 
   if (high != ipivot)
     swap(ipivot,high);
   return high;
 }
 //---------------------------------------------------------
 template <class T>    // element for element multiplication
 Vector<T> Vector<T>::hadamardproduct (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if (_length != v._length)
       throw IllegalOperation("Vector::hadamardproduct");
   #endif
   Vector<T> result(v);
   for (long i=0; i<_length; i++)
     result._v[i] *= _v[i];
 
   return result;
 }
 //=========================================================
 // Class Operators
 //----------------
 template <class T>      // assignment operator
 Vector<T>&amp; Vector<T>::operator= (const Vector<T>&amp; v)
 {
   if (this != &amp;v)
    {
        if (_length != v._length)
          resize(v._length);
        for (long i=0; i<_length; i++)

         _v[i] = v._v[i];
    }
   return *this;
 }
 //---------------------------------------------------------
 template <class T>      // vector addition
 Vector<T> Vector<T>::operator+ (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if (_length != v._length)
       throw IllegalOperation("Vector::operator+");
   #endif
   Vector<T> result(*this);
   for (long i=0; i<_length; i++)
     result._v[i] += v._v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>      // vector subtraction
 Vector<T> Vector<T>::operator- (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if (_length != v._length)
       throw IllegalOperation("Vector::operator-");
   #endif
   Vector<T> result(*this);
   for (long i=0; i<_length; i++)
     result._v[i] -= v._v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>      // Dot product
 T Vector<T>::operator* (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if (_length != v._length)
       throw IllegalOperation("Vector::operator*");
   #endif
   T result=0;
   for (long i=0; i<_length; i++)
     result += _v[i]*v._v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Vector<T>::operator+ (const T&amp; x) const
 {
   Vector<T> result(*this);
   for (long i=0; i<_length; i++)
     result._v[i] += x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>

 Vector<T> Vector<T>::operator- (const T&amp; x) const
 {
   Vector<T> result(*this);
   for (long i=0; i<_length; i++)
     result._v[i] -= x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Vector<T>::operator* (const T&amp; x) const
 {
   Vector<T> result(*this);
   for (long i=0; i<_length; i++)
     result._v[i] *= x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Vector<T>::operator/ (const T&amp; x) const
 {
   Vector<T> result(*this);
   for (long i=0; i<_length; i++)
     result._v[i] /= x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::operator+= (const Vector<T>&amp; v)
 {*this = *this + v;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::operator-= (const Vector<T>&amp; v)
 {*this = *this - v;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::operator+= (const T&amp; x)
 {*this = *this + x;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::operator-= (const T&amp; x)
 {*this = *this - x;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::operator*= (const T&amp; x)
 {*this = *this * x;}
 //---------------------------------------------------------
 template <class T>
 inline void Vector<T>::operator/= (const T&amp; x)
 {*this = *this / x;}
 //---------------------------------------------------------
 template <class T>       // unary +
 inline Vector<T> Vector<T>::operator+ () const
 {return (*this);}
 //---------------------------------------------------------

 template <class T>       // unary -
 Vector<T> Vector<T>::operator- ()
 {
   Vector<T> result(_length);
   for (long i=0; i<_length; i++)
     result._v[i] = -_v[i];
   return result;
 }
 //=========================================================
 // PRIVATE MEMBER FUNCTIONS
 //-------------------------
 template <class T> void Vector<T>::resize (const long lngth)
 {
   #if EXCEPTIONHANDLING
     if (lngth<0)
       throw IllegalArguments("Vector::resize(lngth) => lngth<0");
   #endif
   delete[] _v;
   if (lngth>0)
    {
      _v = new T[lngth];
      _length = lngth;
    }
   else
    {
      _v = NULL;
      _length = 0;
    }
 }
 /*
 //=========================================================
 // FRIENDS OF VECTOR
 //------------------
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Vector<T>&amp; v)
 {
   os << "[ ";
   for (long i=0; i<v._length; i++)
   {
     os.precision(v._precision); os.width(v._width);
     os << v._v[i] << ' ';
   }
   return os << "]";
 }
 //---------------------------------------------------------
 template <class T>
 istream&amp; operator>> (istream&amp; is, Vector<T>&amp; v)
 {
   for (long i=0; i<v._length; i++)
     is >> v._v[i];
   return is;
 }
 //=========================================================
 // Global Operators

 //-----------------
 template <class T>
 Vector<T> operator* (const T&amp; x, const Vector<T>&amp; v)
 {
   Vector<T>  result(v._length);
   for (long i=0; i<v._length; i++)
     result._v[i] = x*v._v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> operator+ (const T&amp; x, const Vector<T>&amp; v)
 {
   Vector<T>  result(v._length);
   for (long i=0; i<v._length; i++)
     result._v[i] = x+v._v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> operator- (const T&amp; x, const Vector<T>&amp; v)
 {
   Vector<T>  result(v._length);
   for (long i=0; i<v._length; i++)
     result._v[i] = x-v._v[i];
   return result;
 }
 */
 //=========================================================
 
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Vector<T>&amp; v)
 {
   os << "[ ";
   for (long i=0; i<v.length(); i++)
   {
     os.precision(v.outputprecision()); os.width(v.outputwidth());
     os << v[i] << ' ';
   }
   return os << "]";
 }
 //---------------------------------------------------------
 template <class T>
 istream&amp; operator>> (istream&amp; is, Vector<T>&amp; v)
 {
   for (long i=0; i<v.length(); i++)
     is >> v[i];
   return is;
 }
 //=========================================================
 // Global Operators
 //-----------------
 template <class T>
 Vector<T> operator* (const T&amp; x, const Vector<T>&amp; v)

 {
   Vector<T>  result(v.length());
   for (long i=0; i<v.length(); i++)
     result[i] = x*v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> operator+ (const T&amp; x, const Vector<T>&amp; v)
 {
   Vector<T>  result(v.length());
   for (long i=0; i<v.length(); i++)
     result[i] = x+v[i];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> operator- (const T&amp; x, const Vector<T>&amp; v)
 {
   Vector<T>  result(v.length());
   for (long i=0; i<v.length(); i++)
     result[i] = x-v[i];
   return result;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Matrix Class</title>
        <para/>
        <section>
          <title> Introduction</title>
          <para/>
        </section>
        <section>
          <title> Arrays of Objects</title>
          <para> The underlying data structure for the matrix is an array of vectors. Below we show
            the private data members of the class: </para><![CDATA[
 template <class T> class Matrix
 {
     ...
   private:
     Vector<T>*       _M;
     long             _nrows, _ncols;
     int              _precision, _width;
     static const int _defaultprecision;
     static const int _defaultwidth;
 };
]]><para>
            <literal>_M</literal> is the array of vectors which holds the actual matrix elements,
            <literal>_nrows</literal> and<literal>_ncols</literal> hold the dimension of the matrix
            and the remaining data members are identical to those used in the vector class for
            setting the output format of a matrix object.</para>
          <para> When declaring an array of objects C++ always uses the default constructor of the
            class -- it is thus recommended that you always define a default constructor for your
            class except if you have good reasons to disallow the user to define an array of a
            certain class.</para>
          <para> We define three constructor for the matrix class, the default constructor, the copy
            constructor and a constructor allowing the user to declare a matrix of a certain size.
            The first two of these are virtually identical to their counterparts in the vector class
            and the reader can look at their implementation in the class listing given in section
            ??. The implementation details of the third constructor are given below:
            </para><![CDATA[
 template <class T>
 Matrix<T>::Matrix (const long nrows, const long ncols)
   : _precision(_defaultprecision), _width(_defaultwidth)
 {
   #if EXCEPTIONHANDLING
     if ((nrows<0) || (ncols<0))
       throw InvalidArguments("Matrix(nrows,ncols) => nrows<0 or ncols<0");
   #endf
   _M = new Vector<T>[nrows];
   for (long nr=0; nr<nrows; nr++)
     _M[nr].resize(ncols);
   _nrows = nrows;  _ncols = ncols;
 }
]]><para>
            First we perform sanity-checking on the required size of the matrix. Then we reserve
            memory for <literal>nrows</literal> vectors of the template type via the
            <literal>new</literal> operator and we set the pointer variable <literal>_M</literal>
            equal to the start of this memory area. It is at this point where C++ calls the default
            constructor of the vector class for each of the array elements. Consequently the vectors
            (the rows of the matrix) have all zero length. To set the size of these vectors equal to
            the number of columns, we use the <literal>resize</literal> method of the vector class.
            Finally we set the private data fields for the number of rows and number of columns of
            the matrix.</para>
          <para/>
        </section>
        <section>
          <title> Using the Functionality of the Underlying Vector Class</title>
          <para> Many methods of the matrix class look particularly simple because we use the
            functionality of the underlying vector class. Consider, for example, matrix addition:
            </para><![CDATA[
 template <class T>
 Matrix<T> Matrix<T>::operator+ (const Matrix<T>&amp; M) const
 {
   #if EXCEPTIONHANDLING
     if ((_nrows!=M._nrows) || (_ncols!=M._ncols))
       throw InvalidOperation("Matrix::operator+(Matrix)");
   #endif
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr] += M._M[nr];
   return result;
 }
]]><para>
            If the matrices are of different sizes, we throw an <literal>InvalidOperation</literal>
            exception. Otherwise we make a local copy of the matrix itself (using the copy
            constructor) and use vector addition to add the matrices row-for-row.</para>
          <para> Similarly, the method random which fills the matrix with random numbers chosen
            between<literal>upper</literal> and <literal>lower</literal> limits requests each of its
            rows (each of its vectors) to fill itself with random numbers: </para><![CDATA[
 template <class T>
 void Matrix<T>::random (const T&amp; upper=1, const T&amp; lower=0)
 {
   for (long nr=0; nr<_nrows; nr++)
     _M[nr].random(lower,upper);
 }
]]><para/>
        </section>
        <section>
          <title> Matrix Multiplication, Kronecker and Hadamard Products </title>
          <para> As for vectors, we define three different types of products for matrices. For
            standard matrix multiplication we use the multiplication operator <literal>*</literal>.
            The Kronecker product (also known as direct product) is defined by</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp109x.gif" role="math-display"/>
            </informalequation> It will be used extensively in the sections on neural networks and
            on non-linear programming.</para>
          <para> Unlike for normal matrix multiplication where we have a reversal of order upon
            taking the transpose of a an ordinary product</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp110x.gif" role="math-display"/>
            </informalequation> we have no such reversal when taking the transpose of a Kronecker
            product of matrices</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp111x.gif" role="math-display"/>
            </informalequation> It can also be shown (see exercise ??) that the Kronecker product is distributive</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp112x.gif" role="math-display"/>
            </informalequation> and associative</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp113x.gif" role="math-display"/>
            </informalequation> Neither the ordinary nor the Kronecker product are commutative</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp114x.gif" role="math-display"/>
            </informalequation> The implementation of the Kronecker product ( <ulink url="#x1-155001r5.7">
              <!--ref: mat_kronprod-->
            </ulink>) is given below
            </para><![CDATA[
 template <class T>     // Kroneckerproduct
 Matrix<T> Matrix<T>::operator% (const Matrix<T>&amp; M) const
 {
   Matrix<T> result(_nrows*M._nrows,_ncols*M._ncols);
 
   for (long nr1=0; nr1<_nrows; nr1++)
     for (long nc1=0; nc1<_ncols; nc1++)
       for (long nr2=0; nr2<M._nrows; nr2++)
         for (long nc2=0; nc2<M._ncols; nc2++)
           result._M[nr1*M._nrows+nr2][nc1*M._ncols+nc2]
             = _M[nr1][nc1]*M._M[nr2][nc2];
   return result;
 }
]]><para>
            The second special product which is particularly useful in statistics is the Hadamard or
            Schur product. If two matrices, <informalequation>
              <graphic fileref="cpp115x.gif"/>
            </informalequation> and <informalequation>
              <graphic fileref="cpp116x.gif"/>
            </informalequation>, both have dimension <informalequation>
              <graphic fileref="cpp117x.gif"/>
            </informalequation>, then <informalequation>
              <graphic fileref="cpp118x.gif"/>
            </informalequation> yields a<informalequation>
              <graphic fileref="cpp119x.gif"/>
            </informalequation> matrix whose elements are simply the product of the corresponding
            elements in <informalequation>
              <graphic fileref="cpp120x.gif"/>
            </informalequation> and <informalequation>
              <graphic fileref="cpp121x.gif"/>
            </informalequation>:</para>
          <para>
            <informalequation role="math-display">
              <graphic fileref="cpp122x.gif" role="math-display"/>
            </informalequation> The Hadamard product is distributive and associative. The
            implementation of the Hadamard product is trivial and can be found in the program
            listing (see section ??).</para>
          <para/>
        </section>
        <section>
          <title> Users Guide to the Matrix Class</title>
          <para> Besides the assignment operator, the destructor, default constructor, copy
            constructor and a constructor allowing the user to create a matrix of specific
            dimensions via for example </para><![CDATA[
 Matrix<double> M(3,4));
]]><para> we supply
            a wide range of operators, query and manipulation functions with the matrix class.</para>
          <para/>
          <section>
            <title> Element, Row and Column Access</title>
            <para> Row access is provided via the subscription operator <literal>[]</literal>. Hence
              <literal>M[0]</literal> returns the first row of the matrix as a vector. The access is
              very fast (especially when exception handling is switched off) -- this inline function
              simply returns the relevant row by reference:
              </para><![CDATA[
 template <class T>
 inline Vector<T>&amp; Matrix<T>::operator[] (const long&amp; nrow) const
 {
   #if EXCEPTIONHANDLING
     if ((nrow<0) || (nrow >= _nrows))
       throw Range("Matrix::operator[] (nrow)");
   #endif
   return _M[nrow];
 }
]]><para>
              Concatenating subscription operators gives matrix elements access. Hence
              <literal>M[0][0]</literal> returns the 1-1-element of the matrix. The first
              subscription operator acts on the matrix <literal>M</literal> returning a vector. The
              second subscription operator now acts on a vector object (the subscription operator of
              the vector class is called) returning the 0'th element of the vector representing the
              0'th row.</para>
            <para> Column access carries significantly higher computational overheads. We use the
              function call operator <literal>()</literal>. Hence <literal>M(1)</literal> returns
              the second column as a vector. The implementation details are given below:
              </para><![CDATA[
 Vector<T> Matrix<T>::operator() (const long ncol) const
 {
   #if EXCEPTIONHANDLING
     if ((ncol<0) || (ncol >= _ncols))
       throw Range("Matrix::operator() (ncol)");
   #endif
   Vector<T> result(_nrows);
   for (long nr=0; nr<_nrows; nr++)
      result[nr] = _M[nr][ncol];
   return result;
 }
]]><para>
              After range checking we create a local vector <literal>result</literal> into which we
              copy the matrix elements of the relevant column. The vector is a local variable and
              has to be returned by reference.</para>
            <para/>
          </section>
          <section>
            <title> Query Functions</title>
            <para> The member functions <literal>rows()</literal> and <literal>cols()</literal>
              return the number of rows and columns of the matrix, <literal>diag()</literal> returns
              the diagonal elements as a vector and <literal>trace()</literal> returns the trace of
              the matrix -- the sum of the diagonal elements. The query functions
              <literal>outputwidth()</literal> and <literal>outputprecision()</literal> return the
              current choice of output format for the matrix elements.</para>
            <para/>
          </section>
          <section>
            <title> Arithmetic Operators</title>
            <para> Support for matrix addition, subtraction and multiplication is provided by the
              relevant operators, <literal>+</literal>, <literal>-</literal> and
              <literal>*</literal>. Hence all of the following statements are legal
              </para><![CDATA[
 Matrix<double> A(4,4), B(4,4), C(4,4);
 A = B+C;     // matrix addition
 A = B-C;     // matrix subtraction
 A = B*C;     // matrix product
 A = B%C;     // Kronecker product
]]><para>
              We use the modulo operator <literal>%</literal> for the Kronecker product and we
              define a member function
              <literal><![CDATA[hadamardproduct(const Matrix<T>&amp; M)]]></literal> for the
              Hadamard-product between two matrices. The different matrix products are discussed in
              more detail in section ??.</para>
            <para> Our matrix class supports mixed type arithmetic. The user can add/subtract a
              vector to/from a matrix or a matrix to/from a vector (in the second case the friend
              operator is used). The operators are implemented such that a diagonal matrix with the
              vector elements on the diagonal is added or subtracted from the matrix.</para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp123x.gif" role="math-display"/>
              </informalequation>
            </para>
            <para> We also allow the user to add a scalar to a matrix. In this case a diagonal
              matrix with the scalar value n the diagonal is added to the matrix.</para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp124x.gif" role="math-display"/>
              </informalequation> The same holds for subtraction, multiplication and division of a
              matrix by a scalar.</para>
            <para> The corresponding assignment operators, <literal>+=</literal>,
              <literal>-=</literal>, ...are also defined for the matrix class.</para>
            <para/>
          </section>
          <section>
            <title> Matrix Manipulation Functions</title>
            <para> The method <literal>unit()</literal> sets a square matrix to a unit matrix. The
              method <literal>fill(const T&amp; x)</literal> sets all elements of the matrix
              equal to x. The method <literal>random(const T&amp; upper=1, const T&amp;
              lower=0)</literal> fills the matrix with random numbers between
              <literal>lower</literal> and <literal>upper</literal>. The method is very similar to
              the corresponding method of the vector class. The following two methods
              </para><![CDATA[
 template <class T> class Matrix
 {
   public:
     ...
     void setcol    (const long ncol, const Vector<T>&amp; v);
     void setrow    (const long nrow, const Vector<T>&amp; v);
 }
]]><para>
              allow the user to set a certain row or column to the values contained in the vector
              <literal>v</literal>. The method
              <literal><![CDATA[setdiag(const Vector<T>&amp; v)]]></literal> sets the diagonal
              elements equal to the elements of the vector, while the method <literal>setdiag(const
                T&amp; x)</literal> sets all diagonal elements equal to<literal>x</literal>.</para>
            <para> The method <literal>transpose()</literal> returns a matrix which is the transpose
              of the matrix itself. Hence <literal>A = B.transpose</literal> sets the elements of
              <literal>A</literal> such that <literal>A[i][j]</literal> is equal to<literal>B[j][i]</literal>.</para>
            <para/>
          </section>
          <section>
            <title> Inserting and Removing Rows and Columns</title>
            <para> The methods <literal>removerow(const long nrow)</literal> and
                <literal>removecol(const long ncol)</literal> allow the user to remove a specific
              row or column of a matrix. For example <literal>A.removerow(1)</literal> removes the
              second row from the matrix <literal>a</literal>.</para>
            <para> The following two methods allow the user to insert a row or column before a
              certain row or column:
              </para><![CDATA[
 template <class T> class Matrix
 {
   public:
     ...
     void insertrow (const long beforerow, const Vector<T>&amp; v);
     void insertcol (const long beforecol, const Vector<T>&amp; v);
 }
]]><para>
              For example </para><![CDATA[
 A.insertcol(A.cols(),v);
]]><para> appends a column
              vector <literal>v</literal> to the matrix <literal>a</literal>.</para>
            <para/>
          </section>
          <section>
            <title> Stream Access</title>
            <para> We provide input and output stream access via the standard stream extraction and
              stream output operators, <literal><![CDATA[>>]]></literal> and
              <literal><![CDATA[<<]]></literal>. The two operators can be used as follows:
              </para><![CDATA[
 void main()
 {
   Matrix<int> M(2,3);
   cin >> M;
   M.setoutputprecision(2);
   M.setoutputwidth(3);
   cout << "You have just read in the following matrix:" << endl << M;
 }
]]><para>
              After declaring a <informalequation>
                <graphic fileref="cpp125x.gif"/>
              </informalequation> matrix of integers, <literal>M</literal> we extract the matrix
              from the standard input stream. The stream extraction operator simply extract 6
              integers from the stream and reads them row-for-row into the matrix.</para>
            <para> We then set the output format for the matrix elements and send the matrix to the
              standard output stream via the operator <literal>&gt;&gt;</literal>. Both, the stream
              extraction and stream output operators are declared friends of the class and hence
              they do have access to the private data members of the class. The implementation
              details for the output stream operator are given below:
              </para><![CDATA[
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Matrix<T>&amp; M)
 {
   for (long nr=0; nr<M._nrows; nr++)
   {
     os << "| ";
     for (long nc=0; nc<M._ncols; nc++)
     {
       os.precision(M._precision); os.width(M._width);
       os << M._M[nr][nc] << ' ';
     }
     os << "|" << endl;
   }
   return os;
 }
]]><para>
              and the resultant output for the matrix <literal>M</literal> could be </para><![CDATA[
 |  1  2  3 |
 |  4  5  6 |
]]><para/>
          </section>
          <section>
            <title> The Demonstration Program</title>
            <para> On the disk accompanying this book we supply the following demonstration program
              TMATRIX.CPP which illustrates the usage and power of the matrix class:
              </para><![CDATA[
 #include <iostream>
 
 #include "Matrix.h"
 #include "Vector.h"
 #include "Rational.h"
 
 #include "Vector.cpp"
 #include "Matrix.cpp"
 #include "Rational.cpp"
 
 using namespace std;
 
 int main()
 {
   try
   {
     Matrix<double> A(4,4);
     A.random();
     Matrix<double> B = A;
     B.setoutputwidth(6); B.setoutputprecision(2);
     cout << "B = " << endl << B;
 
     Vector<double> v1(4); v1.fill(1.7);
     B.insertrow(1,v1);
     cout << "Inserted row 1: B = " << endl << B;
     B.removecol(2);
     cout << "Removed column 2: B = " << endl << B;
     B.swaprows(0,3);
     cout << "swapped rows 0 and 3: B = " << endl << B;
     A.fill(2);
     A=B.transpose();
     Matrix<double> I1(2,2); I1.setoutputwidth(3); I1.setoutputprecision(2);
     I1.random(8,-2);
     cout << "I1 = " << endl << I1;
     Matrix<double> I2=200.0 + 2.0*I1 / 10;
     cout << "I2 = " << endl << I2 << endl;
 
     Vector<double> v2(7);
     v1.random(); v2.random();
     cout << "v1 = " << v1 << endl;
     cout << "v2 = " << v2 << endl;
     cout << "Kronecker product: v1%v2 = " << endl << v1%v2;
 
     Rational<long> r(1,3);
     Matrix<Rational<long> > Mr1(3,3);
     for (long nr=0; nr<3; nr++)
       for (long nc=0; nc<3; nc++)
         Mr1[nr][nc] = r+(nr+1L)*Rational<long>(5,nc+1);
     cout << "Mr1 = " << endl << Mr1;
     Matrix<Rational<long> > Mr2 = Mr1*Mr1-Mr1/2;

     cout << "Mr2 = Mr1*Mr1-Mr1/2 = " << endl << Mr2;
 
   }
   catch (Exception error)
   {
     cout << "*** ERROR ***: " << error.source << endl;
   }
   return 0;
 }
]]><para>Again,
              we recommend that the reader runs this program.</para>
            <para/>
          </section>
        </section>
        <section>
          <title> Listing of the Matrix Class </title>
          <para> The interface for the matrix class is defined in the header file MATRIX.H:
            </para><![CDATA[
 #ifndef __MATRIX_H
 #define __MATRIX_H
 
 #include <math.h>
 #include <iostream>
 #include <cstdlib>
 
 #include "Vector.h"
 #include "ErrHandl.h"
 
 using namespace std;
 
 template <class T> class Matrix
 {
   public:
     Matrix ();
     Matrix (const Matrix<T>&amp; M);
     Matrix (const long nrows, const long ncols);
    ~Matrix ();
 
     long rows         () const;
     long cols         () const;
 
     int  outputwidth        () const;
     int  outputprecision    () const;
     void setoutputwidth     (const int precisn);
     void setoutputprecision (const int wdth);
 
     void random (const T&amp; upper=1, const T&amp; lower=0);
     void fill   (const T&amp; x);
     void unit   ();
 
     void setcol    (const long ncol, const Vector<T>&amp; v);
     void setrow    (const long nrow, const Vector<T>&amp; v);
     void insertrow (const long beforerow, const Vector<T>&amp; v);
     void insertcol (const long beforecol, const Vector<T>&amp; v);
     void removerow (const long nrow);
     void removecol (const long ncol);
     void swaprows  (const long r1, const long r2);
     void swapcols  (const long c1, const long c2);
     void setdiag   (const Vector<T>&amp; v);
     void setdiag   (const T&amp; x);
 
     Vector<T> diag  () const;
     T         trace () const;
 
     Matrix<T> transpose () const;
     Matrix<T> hadamamardproduct (const Matrix<T>&amp; M) const;
 
     Matrix<T>&amp; operator=  (const Matrix<T>&amp; M);

     Vector<T>&amp; operator[] (const long nrow)    const;
     Vector<T>  operator() (const long ncol)    const;
 
     Matrix<T>  operator+  (const Matrix<T>&amp; M) const;
     Matrix<T>  operator-  (const Matrix<T>&amp; M) const;
     Matrix<T>  operator*  (const Matrix<T>&amp; M) const;
     Matrix<T>  operator%  (const Matrix<T>&amp; M) const;
     Matrix<T>  operator+  (const Vector<T>&amp; v) const;
     Matrix<T>  operator-  (const Vector<T>&amp; v) const;
     Matrix<T>  operator+  (const T&amp; x)         const;
     Matrix<T>  operator-  (const T&amp; x)         const;
     Matrix<T>  operator*  (const T&amp; x)         const;
     Matrix<T>  operator/  (const T&amp; x)         const;
     Vector<T>  operator*  (const Vector<T>&amp; v) const;
     void       operator+= (const Matrix<T>&amp; M);
     void       operator-= (const Matrix<T>&amp; M);
     void       operator*= (const Matrix<T>&amp; M);
     void       operator%= (const Matrix<T>&amp; M);
     void       operator+= (const Vector<T>&amp; v);
     void       operator-= (const Vector<T>&amp; v);
     void       operator+= (const T&amp; x)        ;
     void       operator-= (const T&amp; x)        ;
     void       operator*= (const T&amp; x)        ;
     void       operator/= (const T&amp; x)        ;
 /*
     friend Matrix<T> operator% (const Vector<T>&amp;,const Vector<T>&amp;);
     friend Matrix<T> operator+ (const T&amp; x,const Matrix<T>&amp; M);
     friend Matrix<T> operator- (const T&amp; x,const Matrix<T>&amp; M);
     friend Matrix<T> operator* (const T&amp; x,const Matrix<T>&amp; M);
     friend Vector<T> operator* (const Vector<T>&amp; v, Matrix<T> M);
 
     friend istream&amp; operator>> (istream&amp; is,       Matrix<T>&amp; M);
     friend ostream&amp; operator<< (ostream&amp; os, const Matrix<T>&amp; M);
 */
   private:
     Vector<T>*       _M;
     long             _nrows, _ncols;
     int              _precision, _width;
     static const int _defaultprecision;
     static const int _defaultwidth;
 
 };
 
 // Initializing Static Class Constants
 template<class T> const int Matrix<T>::_defaultprecision = 3;
 template<class T> const int Matrix<T>::_defaultwidth     = 9;
 
 template <class T>
 Matrix<T> operator% (const Vector<T>&amp; v1,const Vector<T>&amp; v2);
 
 template <class T>
 inline Matrix<T> operator+ (const T&amp; x,const Matrix<T>&amp; M);
 
 template <class T>

 Matrix<T> operator- (const T&amp; x,const Matrix<T>&amp; M);
 
 template <class T>
 inline Matrix<T> operator* (const T&amp; x,const Matrix<T>&amp; M);
 
 template <class T>
 Vector<T> operator* (const Vector<T>&amp; v,const Matrix<T>&amp; M);
 
 template <class T>
 istream&amp; operator>> (istream&amp; is, Matrix<T>&amp; M);
 
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Matrix<T>&amp; M);
 
 #endif
]]><para>
            The implementation details are given in the file MATRIX.CPP </para><![CDATA[
 #include "Matrix.h"
 
 //=========================================================
 // CONSTRUCTORS and DESTRUCTOR
 // ---------------------------
 template <class T>
 Matrix<T>::Matrix (): _M(NULL), _nrows(0), _ncols(0),
   _precision(_defaultprecision), _width(_defaultwidth) {}
 //---------------------------------------------------------
 template <class T>
 Matrix<T>::Matrix (const Matrix<T>&amp; M): _M(NULL),
     _nrows(0), _ncols(0), _precision(_defaultprecision),
     _width(_defaultwidth)  {*this=M;}
 //---------------------------------------------------------
 template <class T>
 Matrix<T>::Matrix (const long nrows, const long ncols)
   : _precision(_defaultprecision), _width(_defaultwidth)
 {
   #if EXCEPTIONHANDLING
     if ((nrows<0) || (ncols<0))
       throw IllegalArguments("Matrix(nrows,ncols) => nrows<0 or ncols<0");
   #endif
   _M = new Vector<T>[nrows];
   for (long nr=0; nr<nrows; nr++)
     _M[nr].resize(ncols);
   _nrows = nrows;  _ncols = ncols;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T>::~Matrix () {delete[] _M;}
 //=========================================================
 // QUERY FUNCTIONS
 // ---------------
 template <class T>
 long Matrix<T>::rows () const {return _nrows;}
 //---------------------------------------------------------
 template <class T>
 long Matrix<T>::cols () const {return _ncols;}
 //---------------------------------------------------------
 template <class T>
 int Matrix<T>::outputwidth () const {return _width;}
 //---------------------------------------------------------
 template <class T>
 int Matrix<T>::outputprecision () const {return _precision;}
 //=========================================================
 // OTHER MEMBER FUNCTIONS
 // ----------------------
 template <class T>
 void Matrix<T>::setoutputwidth (const int wdth)
 {_width=wdth;}

 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::setoutputprecision (const int precisn)
 {_precision = precisn;}
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::random (const T&amp; upper, const T&amp; lower)
 {
   for (long nr=0; nr<_nrows; nr++)
     _M[nr].random(lower,upper);
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::fill (const T&amp; x)
 {
   for (long nr=0; nr<_nrows; nr++)
     _M[nr].fill(x);
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::unit ()
 {
   #if EXCEPTIONHANDLING
     if (_nrows != _ncols)
       throw IllegalOperation("Matrix::unit() => Matrix not square");
   #endif
   for (long nr=0; nr<_nrows; nr++)
     _M[nr].unit(nr);
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::setcol (const long ncol, const Vector<T>&amp; v)
 {
   #if EXCEPTIONHANDLING
     if ((ncol<0) || (ncol>=_ncols))
       throw Range("Matrix::setcol(ncol)");
   #endif
   for (long nr=0; nr<_nrows; nr++)
     _M[nr][ncol] = v[nr];
 }
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::setrow  (const long nrow, const Vector<T>&amp; v)
 {
   #if EXCEPTIONHANDLING
     if ((nrow<0) || (nrow>=_nrows))
       throw Range("Matrix::setrow(nrow)");
   #endif
   _M[nrow]=v;
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::insertrow (const long beforerow, const Vector<T>&amp; v)
 {

   #if EXCEPTIONHANDLING
     if ((beforerow<0) || (beforerow>_nrows))
       throw Range("Matrix::insertrow(beforerow,v)");
   #endif
   Matrix<T> dummy(_nrows+1,_ncols);
   for (long nr=0; nr<beforerow; nr++)
     dummy._M[nr] = _M[nr];
   dummy._M[beforerow] = v;
   for (long nr=beforerow+1; nr<=_nrows; nr++)
     dummy._M[nr] = _M[nr-1];
   *this = dummy;
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::insertcol (const long beforecol, const Vector<T>&amp; v)
 {
   #if EXCEPTIONHANDLING
     if ((beforecol<0) || (beforecol>_ncols))
       throw Range("Matrix::insertcol(beforecol,v)");
   #endif
   Matrix<T> dummy(_nrows,_ncols+1);
   for (long nc=0; nc<beforecol; nc++)
     for (long nr=0; nr<_nrows; nr++)
       dummy._M[nr][nc] = _M[nr][nc];
   for (long nr=0; nr<_nrows; nr++)
     dummy._M[nr][beforecol] = v[nr];
   for (long nc=beforecol+1; nc<=_ncols; nc++)
     for (long nr=0; nr<_nrows; nr++)
       dummy._M[nr][nc] = _M[nr][nc-1];
   *this = dummy;
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::removerow (const long nrow)
 {
   #if EXCEPTIONHANDLING
     if ((nrow<0) || (nrow>=_nrows))
       throw Range("Matrix::removerow(nrow)");
   #endif
   Matrix<T> dummy(_nrows-1,_ncols);
   for (long nr=0; nr<nrow; nr++)
     dummy._M[nr] = _M[nr];
   for (long nr=nrow+1; nr<_nrows; nr++)
     dummy._M[nr-1] = _M[nr];
   *this = dummy;
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::removecol (const long ncol)
 {
   #if EXCEPTIONHANDLING
     if ((ncol<0) || (ncol>_ncols))
       throw Range("Matrix::removecol(ncol)");
   #endif

   Matrix<T> dummy(_nrows,_ncols-1);
   for (long nc=0; nc<ncol; nc++)
     for (long nr=0; nr<_nrows; nr++)
       dummy._M[nr][nc] = _M[nr][nc];
   for (long nc=ncol+1; nc<_ncols; nc++)
     for (long nr=0; nr<_nrows; nr++)
       dummy._M[nr][nc-1] = _M[nr][nc];
   *this = dummy;
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::setdiag (const Vector<T>&amp; v)
 {
   #if EXCEPTIONHANDLING
     if (_nrows != _ncols)
       throw IllegalOperation("Matrix::setdiag() => Matrix not square");
   #endif
   for (long nr=0; nr<_nrows; nr++)
     _M[nr][nr] = v[nr];
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::setdiag (const T&amp; x)
 {
   #if EXCEPTIONHANDLING
     if (_nrows != _ncols)
       throw IllegalOperation("Matrix::setdiag() => Matrix not square");
   #endif
   for (long nr=0; nr<_nrows; nr++)
     _M[nr][nr] = x;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Matrix<T>::diag () const
 {
   #if EXCEPTIONHANDLING
     if (_nrows != _ncols)
       throw IllegalOperation("Matrix::diag() => Matrix not square");
   #endif
   Vector<T> vdiag(_nrows);
   for (long nr=0; nr<_nrows; nr++)
     vdiag[nr] = _M[nr][nr];
   return vdiag;
 }
 //---------------------------------------------------------
 template <class T>
 T Matrix<T>::trace () const
 {
   #if EXCEPTIONHANDLING
     if (_nrows != _ncols)
       throw IllegalOperation("Matrix::diag() => Matrix not square");
   #endif
   T sum=0;
   for (long nr=0; nr<_nrows; nr++)

     sum += _M[nr][nr];
   return sum;
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::swaprows (const long r1, const long r2)
 {
   if (r1 != r2)
   {
     #if EXCEPTIONHANDLING
       if ((r1<0) || (r1>=_nrows) || (r2<0) || (r2>=_nrows))
         throw Range("Matrix::swaprows(r1,r2)");
     #endif
     Vector<T> dummy = _M[r1];
     _M[r1] = _M[r2];
     _M[r2] = dummy;
   }
 }
 //---------------------------------------------------------
 template <class T>
 void Matrix<T>::swapcols (const long c1, const long c2)
 {
   if (c1 != c2)
   {
     #if EXCEPTIONHANDLING
       if ((c1<0) || (c1>=_ncols) || (c2<0) || (c2>=_ncols))
         throw Range("Matrix::swapcols(c1,c2)");
     #endif
     for (long nr=0; nr<_nrows; nr++)
     {
       T dummy = _M[nr][c1];
       _M[nr][c1] = _M[nr][c2];
       _M[nr][c2] = dummy;
     }
   }
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::transpose () const
 {
   Matrix<T> result(_ncols,_nrows);
   for (long nr=0; nr<_nrows; nr++)
     for (long nc=0; nc<_ncols; nc++)
       result._M[nc][nr] = _M[nr][nc];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::hadamamardproduct (const Matrix<T>&amp; M) const
 {
   Matrix<T> result(M);
   for (long nr=0; nr<_nrows; nr++)
     for (long nc=0; nc<_ncols; nc++)
       result._M[nr][nc] *= _M[nr][nc];

   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline Vector<T>&amp; Matrix<T>::operator[] (const long nrow) const
 {
   #if EXCEPTIONHANDLING
     if ((nrow<0) || (nrow >= _nrows))
       throw Range("Matrix::operator[] (nrow)");
   #endif
   return _M[nrow];
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Matrix<T>::operator() (const long ncol) const
 {
   #if EXCEPTIONHANDLING
     if ((ncol<0) || (ncol >= _ncols))
       throw Range("Matrix::operator() (ncol)");
   #endif
   Vector<T> result(_nrows);
   for (long nr=0; nr<_nrows; nr++)
      result[nr] = _M[nr][ncol];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T>&amp; Matrix<T>::operator= (const Matrix<T>&amp; M)
 {
   if (this != &amp;M)
   {
     if (_nrows!=M._nrows)
     {
       delete[] _M;
       _M = new Vector<T>[M._nrows];
       _nrows = M._nrows;
     }
     for (long nr=0; nr<M._nrows; nr++)
       _M[nr] = M._M[nr];
     _ncols = M._ncols;
   }
   return *this;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator+ (const Matrix<T>&amp; M) const
 {
   #if EXCEPTIONHANDLING
     if ((_nrows!=M._nrows) || (_ncols!=M._ncols))
       throw IllegalOperation("Matrix::operator+(Matrix)");
   #endif
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr] += M._M[nr];

   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator- (const Matrix<T>&amp; M) const
 {
   #if EXCEPTIONHANDLING
     if ((_nrows!=M._nrows) || (_ncols!=M._ncols))
       throw IllegalOperation("Matrix::operator-(Matrix)");
   #endif
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr] -= M._M[nr];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator* (const Matrix<T>&amp; M) const
 {
   #if EXCEPTIONHANDLING
     if (_ncols!=M._nrows)
       throw IllegalOperation("Matrix::operator*(Matrix)");
   #endif
   Matrix<T> result(_nrows,M._ncols);
   for (long nr1=0; nr1<_nrows; nr1++)
     for (long nc2=0; nc2<M._ncols; nc2++)
     {
       T sum=0;
       for (long nc1=0; nc1<_ncols; nc1++)
         sum += _M[nr1][nc1]*M._M[nc1][nc2];
       result._M[nr1][nc2]=sum;
     }
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Vector<T> Matrix<T>::operator* (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if (_ncols!=v.length())
       throw IllegalOperation("Matrix::operator*(Vector)");
   #endif
   Vector<T> result(_nrows);
   for (long nr=0; nr<_nrows; nr++)
   {
     T sum=0;
     for (long nc=0; nc<_ncols; nc++)
       sum += _M[nr][nc]*v[nc];
     result[nr]=sum;
   }
   return result;
 }
 //---------------------------------------------------------
 template <class T>     // Kroneckerproduct

 Matrix<T> Matrix<T>::operator% (const Matrix<T>&amp; M) const
 {
   Matrix<T> result(_nrows*M._nrows,_ncols*M._ncols);
 
   for (long nr1=0; nr1<_nrows; nr1++)
     for (long nc1=0; nc1<_ncols; nc1++)
       for (long nr2=0; nr2<M._nrows; nr2++)
         for (long nc2=0; nc2<M._ncols; nc2++)
           result._M[nr1*M._nrows+nr2][nc1*M._ncols+nc2]
             = _M[nr1][nc1]*M._M[nr2][nc2];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator+ (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if ((_nrows==_ncols) &amp;&amp; (_nrows==v.length()))
       throw IllegalOperation("Matrix::operator+(Vector)");
   #endif
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr][nr] += v[nr];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator- (const Vector<T>&amp; v) const
 {
   #if EXCEPTIONHANDLING
     if ((_nrows==_ncols) &amp;&amp; (_nrows==v.length()))
       throw IllegalOperation("Matrix::operator-(Vector)");
   #endif
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr][nr] -= v[nr];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator+ (const T&amp; x) const
 {
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr][nr] += x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator- (const T&amp; x) const
 {
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     result._M[nr][nr] -= x;

   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator* (const T&amp; x) const
 {
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     for (long nc=0; nc<_ncols; nc++)
       result._M[nr][nc] *= x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 Matrix<T> Matrix<T>::operator/ (const T&amp; x) const
 {
   Matrix<T> result(*this);
   for (long nr=0; nr<_nrows; nr++)
     for (long nc=0; nc<_ncols; nc++)
       result._M[nr][nc] /= x;
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator+= (const Matrix<T>&amp; M)
 {*this = *this+M;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator-= (const Matrix<T>&amp; M)
 {*this = *this-M;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator*= (const Matrix<T>&amp; M)
 {*this = *this*M;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator%= (const Matrix<T>&amp; M)
 {*this = *this%M;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator+= (const Vector<T>&amp; v)
 {*this = *this+v;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator-= (const Vector<T>&amp; v)
 {*this = *this-v;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator+= (const T&amp; x)
 {*this = *this+x;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator-= (const T&amp; x)
 {*this = *this+x;}

 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator*= (const T&amp; x)
 {*this = *this+x;}
 //---------------------------------------------------------
 template <class T>
 inline void Matrix<T>::operator/= (const T&amp; x)
 {*this = *this+x;}
 //---------------------------------------------------------
 // Friend operators
 /*
 template <class T>
 Matrix<T> operator% (const Vector<T>&amp; v1,const Vector<T>&amp; v2)
 {
   long lv1=v1.length();
   long lv2=v2.length();
 
   Matrix<T> result(lv1,lv2);
   for (long nr=0; nr<lv1; nr++)
     for (long nc=0; nc<lv2; nc++)
       result._M[nr][nc] = v1[nr]*v2[nc];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline Matrix<T> operator+ (const T&amp; x,const Matrix<T>&amp; M)
 {return M+x;}
 //---------------------------------------------------------
 template <class T>
 Matrix<T> operator- (const T&amp; x,const Matrix<T>&amp; M)
 {
   Matrix<T> result(M._nrows,M._ncols);
   for (long nr=0; nr<M._nrows; nr++)
     for (long nc=0; nc<M._ncols; nc++)
       result.M[nr][nc] = x - M._M[nr][nc];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline Matrix<T> operator* (const T&amp; x,const Matrix<T>&amp; M)
 {return M*x;}
 //---------------------------------------------------------
 template <class T>
 Vector<T> operator* (const Vector<T>&amp; v,const Matrix<T>&amp; M)
 {
   #if EXCEPTIONHANDLING
     if (M._nrows!=v.length())
       throw IllegalOperation("operator*(Vector,Matrix)");
   #endif
   Vector<T> result(_ncols);
   for (long nc=0; nc<_ncols; nc++)
   {
     T sum=0;
     for (long nr=0; nr<_nrows; nr++)

       sum += v[nr]*M[nr][nc];
     result[nc]=sum;
   }
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 istream&amp; operator>> (istream&amp; is, Matrix<T>&amp; M)
 {
   for  (long nr=0; nr<M._nrows; nr++)
     for (long nc=0; nc<M._ncols; nc++)
        is >> M[nr][nc];
   return is;
 }
 //---------------------------------------------------------
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Matrix<T>&amp; M)
 {
   for (long nr=0; nr<M._nrows; nr++)
   {
     os << "| ";
     for (long nc=0; nc<M._ncols; nc++)
     {
       os.precision(M._precision); os.width(M._width);
       os << M._M[nr][nc] << ' ';
     }
     os << "|" << endl;
   }
   return os;
 }
 */
 template <class T>
 Matrix<T> operator% (const Vector<T>&amp; v1,const Vector<T>&amp; v2)
 {
   long lv1=v1.length();
   long lv2=v2.length();
 
   Matrix<T> result(lv1,lv2);
   for (long nr=0; nr<lv1; nr++)
     for (long nc=0; nc<lv2; nc++)
       result[nr][nc] = v1[nr]*v2[nc];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline Matrix<T> operator+ (const T&amp; x,const Matrix<T>&amp; M)
 {return M+x;}
 //---------------------------------------------------------
 template <class T>
 Matrix<T> operator- (const T&amp; x,const Matrix<T>&amp; M)
 {
   Matrix<T> result(M._nrows,M._ncols);
   for (long nr=0; nr<M._nrows; nr++)
     for (long nc=0; nc<M._ncols; nc++)

       result[nr][nc] = x - M[nr][nc];
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 inline Matrix<T> operator* (const T&amp; x,const Matrix<T>&amp; M)
 {return M*x;}
 //---------------------------------------------------------
 template <class T>
 Vector<T> operator* (const Vector<T>&amp; v,const Matrix<T>&amp; M)
 {
   #if EXCEPTIONHANDLING
     if (M._nrows!=v.length())
       throw IllegalOperation("operator*(Vector,Matrix)");
   #endif
   Vector<T> result(_ncols);
   for (long nc=0; nc<_ncols; nc++)
   {
     T sum=0;
     for (long nr=0; nr<_nrows; nr++)
       sum += v[nr]*M[nr][nc];
     result[nc]=sum;
   }
   return result;
 }
 //---------------------------------------------------------
 template <class T>
 istream&amp; operator>> (istream&amp; is, Matrix<T>&amp; M)
 {
   for  (long nr=0; nr<M._nrows; nr++)
     for (long nc=0; nc<M._ncols; nc++)
        is >> M[nr][nc];
   return is;
 }
 //---------------------------------------------------------
 template <class T>
 ostream&amp; operator<< (ostream&amp; os, const Matrix<T>&amp; M)
 {
   for (long nr=0; nr<M.rows(); nr++)
   {
     os << "| ";
     for (long nc=0; nc<M.cols(); nc++)
     {
       os.precision(M.outputprecision()); os.width(M.outputwidth());
       os << M[nr][nc] << ' ';
     }
     os << "|" << endl;
   }
   return os;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Exercises</title>
        <para/>
        <orderedlist>
          <listitem>
            <para>Write a linear regression program (linear least squares fit) which fits a straight
              line through a set of data points. Use the vector class where appropriate. </para>
          </listitem>
          <listitem>
            <para>Show that the Kronecker product ( <ulink url="#x1-155001r5.7">
                <!--ref: mat_kronprod-->
              </ulink>) obeys equations ( <ulink url="#x1-155003r5.9">
                <!--ref: mat_krontransp-->
              </ulink>), ( <ulink url="#x1-155004r5.10">
                <!--ref: mat_krondistr-->
              </ulink>) and ( <ulink url="#x1-155005r5.11">
                <!--ref: mat_kronassoc-->
              </ulink>). Show further that </para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp126x.gif" role="math-display"/>
              </informalequation> by comparing both sides of the equation. What are the required
              relationships between the dimensions of the matrices? </para>
          </listitem>
          <listitem>
            <para>Add a method <literal>kroneckerpower(n)</literal> to the matrix class which
              returns the <informalequation>
                <graphic fileref="cpp127x.gif"/>
              </informalequation>'th Kronecker power of the matrix. The 2'nd and 3'rd Kronecker
              powers are for example given by </para>
            <para>
              <informalequation role="math-display">
                <graphic fileref="cpp128x.gif" role="math-display"/>
              </informalequation> and prove that <informalequation>
                <graphic fileref="cpp129x.gif"/>
              </informalequation>. </para>
          </listitem>
        </orderedlist>
        <para/>
        <para/>
      </section>
    </section>
    <!--end chapter-->
    <section role="chapter">
      <title> Packaging via Namespaces </title>
      <para> Namespaces in C++ perrform the same function as packages in UML or Java and modules in
        CORBA. They provide a mechanism for hierachical naming. But why do we need this? </para>
      <section>
        <title> NameSpace Pollution</title>
        <para> So far we declared all our classes and functions within global scope. One can also
          define objects and variables at global scope, though we have refrained from doing this.</para>
        <para> One of the problems with declaring elements at global scope is that one has to
          somehow ensure that eac name is globally unique. If one used two libraries which both
          define a verb+Date+ class at global scope -- this would not be that unlikely -- then the
          compiler could not distinguish between the two <literal>Date</literal> classes if both
          libraries were used simultaneously.</para>
        <para/>
        <section>
          <title> Unique Naming</title>
          <para> Prior to the ANSI/C++ standard which introduced the concept of namespaces, the
            approach was to insert a prefix (or append a postfix) into each name, hoping that this
            aproach would result in unique names and avoid the polution of the global namespace. For
            example, if we defined a <literal>Date</literal> class, we could have called the class</para>
          <para/><![CDATA[
 class SolmsTraining_Date
 {
   ...
 };
]]><para> But this may not be
            enough to avoid name clashes. Particularly in large organizations, where there are
            multiple development teams, one might want to define further nested scopes for the
            individual development teams.</para>
          <para> For example, both, the front-end and back-end development teams may define their
            own date/time class, <literal>Date</literal>. In this case one may ant to introduce a
            further level in the naming:</para>

          <para/><![CDATA[
 class OrganizationName_FrontEnd_Date
 {
   ...
 };
]]><para/><![CDATA[
 class OrganizationName_BackEnd_SolmsTraining_Date
 {
   ...
 };
]]><para>
            The resultant names become very long and the code becomes less and less readable.</para>
          <para/>
        </section>
      </section>
      <section>
        <title> Defining NameSpaces</title>
        <para> A namespace is in C++ a conceptual organization of the global namespace into a
          hierachical structure which is conceptually very similar to UML or Java packages. As with
          Java, one should always put ones classes and functions into namespaces.</para>
        <para> To put a elements into a namespace one uses the <literal>namespace</literal> keyword:</para>
        <para/><![CDATA[
 namespace SolmsTraining
 {
   const double PI = 3.14159265359;
 
 template <class T> bubbleSort(T array[], const int length) { ... }
 
 template <class T> class Matrix
 {
    ...
 };
 }
]]><para/>
        <section>
          <title> Namespaces are Cumulative</title>
          <para> If we define the same namespace at different locations, the contents of the
            namespace will be the sum total of all the elements defined at the various locations for
            that namespace. Thus</para>

          <para/><![CDATA[
 namespace SolmsTraining
 {
   const double PI = 3.14159265359;
 }
 
 namespace TimLewis
 {
   void convertGifToJPeg(istraem&amp; gifStream, ostream&amp; jpegStream) {...};
 }
 
 namespace SolmsTraining
 {
 template <class T> bubbleSort(T array[], const int length) { ... }
 
 template <class T> class Matrix
 {
    ...
 };
 }
]]><para>
            would assign the same 3 elements to the <literal>SolmsTraining</literal> namespace as
            the previous example.</para>
          <para/>
        </section>
        <section>
          <title> Namespaces Span Accross Files</title>
          <para> As with Java packages, namespace elements are typically defined in multiple files.
            However, unlike Java's package mechanism, C++ implies no mapping between the namespace
            structure and the directory hierarchy.</para>
          <para> Conversely, a file may contain elements assigned to multiple namespaces.</para>
          <para/>
        </section>
      </section>
      <section>
        <title> Using Elements Defined in Other NameSpaces</title>
        <para> You can either access an element from another name space through a fully qualified
          name or by importing it via a <literal>using</literal> clause. For example, if we wanted
          to refer to a matrix class generated from the <literal>Matrix</literal> template defined
          in the <literal>SolmsTraining</literal> namespace, we could do sovia</para>
        <para/><![CDATA[
 SolmsTraining::Matrix<double> m(20,20);
]]><para>or we could import the
          name into the current name spece via the following using statement:</para>
        <para/><![CDATA[
 using SolmsTraining::Matrix;
 using SolmsTraining::PI;
 
 Matrix<double> m(20,20);
 
 m[0][0]= 2.1*PI;
]]><para/>
        <section>
          <title> Importing Entire Namespaces</title>
          <para> At times you want to have direct access to all elements defined in a namespace
            without importing the elements individually. This is particularly useful when reworking
            existing code which did not make use of namespaces to use elements which have now been
            packaged within namespaces. To import an entire namespace -- i.e. all elements from that
            namespace, one adds the <literal>namespace</literal> keyword after the
            <literal>using</literal> keyword:</para>
          <para/><![CDATA[
 using namespace SolmsTraining;
 
 Matrix<double> m(20,20);
 
 m[0][0]= 2.1*PI;
]]><para/>
        </section>
      </section>
      <section>
        <title> Hierarchical Naming via Nested NameSpaces</title>
        <para> One would typically want to use a hierarchical naming along development team
          boundaries or, more sensibly, along application domain boundaries. Thus, to encourage
          re-use accross projects and accross team boundaries, the packaging should not be done
          along either of these criteria. Instead you would want to have a packaging hierarchy which
          packages related objects together, irrespective of the project they have been developed
          for or the team which developed them.</para>
        <para> An example of elements from a packaging hierarchy which follows the along the lines
          of a clean conceptual structure is shown below:</para>

        <para/><![CDATA[
 SolmsTraining::Maths::LinearAlgebra::Vector<T>;
 SolmsTraining::Maths::LinearAlgebra::Matrix<T>;
 ...
 SolmsTraining::Maths::Numeric::Integrate::SimpsonIntegrator;
 SolmsTraining::Maths::Numeric::Integrate::RombergIntegrator;
 ...
 SolmsTraining::Utils::DateTime::Date;
 SolmsTraining::Utils::DateTime::TimePeriod;
 SolmsTraining::Utils::DateTime::AnchoredTimePeriod;
]]><para>
          Such a hierarchy is conceptually clean and with the support of a decent documentation
          generation tool it can simplify the search for components -- it facilitates a natural
          search guided by once requirements.</para>
        <para> For globally unique naming one may want to prefix the namespace hierarchy with the
          inverted domain name of the organization, e.g. <literal>za::co::SolmsTraining::Maths</literal>.</para>
        <para/>
      </section>
      <section>
        <title> Splitting Implementation from Header</title>
        <para> When splitting the implementation from the header by writing seperate
          <literal>cpp</literal> and <literal>h</literal> files, one should keep in mind that within
          the implementation file one has to do one of the following: </para>
        <itemizedlist>
          <listitem>
            <para>Import the names for the elements whose implementation is specified in the file. </para>
          </listitem>
          <listitem>
            <para>Import the entire namespace(s). </para>
          </listitem>
          <listitem>
            <para>Use fully qualified names.</para>
          </listitem>
        </itemizedlist>
        <para/>
      </section>
      <section>
        <title> Anonymous Namespaces</title>
        <para> At times one wants to hide certain elements within a single file. Such elements are
          used by other elements in the file but should are not generally useful. Furthermore, we
          want to ensure that the name used for these elements is save from name-clashes with
          similarly names elements defined in other files.</para>
        <para> In this case one may want to introduce an anonymous namespace. This is in some ways
          similar to Java's <literal>package</literal> access-level specification, just that here
          the access is restricted to a particular file:</para>
        <para> For example, when writing a collection of sorting routines we may want to define a
          <literal>swap</literal> function and we may want to ensure that the this function is
          distinguished from any other swap function which may defines in another library we are
          using. Furthermore, we do not want to publish this function for general use because we
          want to be at liberty to modify it as required by the sorting algorithms it serves.</para>
        <para> In this case we may want to put our <literal>swap</literal> function into an
          anonymous namespace as follows:</para>
        <para/><![CDATA[
 namespace
 {
   template <class T> void swap (T&amp; x, T&amp; y);
 }
 
 template <class T> void bubbleSort(T* array);
 template <class T> void mergeSort(T* array);
 template <class T> void quickSort(T* array);
]]><para/>
      </section>
      <section>
        <title> An Example</title>
        <para> Let us look at an example where we put an account class and a client class into
          seperate namespaces and at a little example application which uses these two classes.</para>
        <para/>
        <section>
          <title> Account.h</title>
          <para> The account class is put into a nested namespace, <literal>SolmsTraining::finance</literal>:</para>
          <para/><![CDATA[
 #ifndef AccountH
 #define AccountH
 namespace SolmsTraining
 {
  namespace finance
  {
   class Account
   {
     public:
       Account();
       Account(double initialBalance);
 
       ~Account();
 
       void credit(double amount);
       void debit(double amount);
 
       double balance();
 
     private:
       double _balance;
   };
  }
 }
 
 #endif
]]><para/>
        </section>
        <section>
          <title> Account.cpp</title>
          <para> In the implementation file we use fully qualified names to resolve the packaged items:</para>
          <para/><![CDATA[
 #include "Account.h"
 #include <iostream>
 
 using namespace std;
 
 SolmsTraining::finance::Account::Account()
   : _balance(50) {}
 
 SolmsTraining::finance::Account::Account(double initialBalance)
   : _balance(initialBalance) {}
 
 SolmsTraining::finance::Account::~Account()
 {
   cout << "I, " << this << ", am destroyed." << endl;
 }
 
 void SolmsTraining::finance::Account::credit(double amount)
 {
   _balance += amount;
 }
 
 void SolmsTraining::finance::Account::debit(double amount)
 {
   _balance -= amount;
 }
 
 double SolmsTraining::finance::Account::balance() {return _balance;}
]]><para/>
        </section>
        <section>
          <title> Client.h</title>
          <para> Similarly, the client class is put into a nested namespace,
            <literal>SolmsTraining::clients</literal>. It uses the <literal>Account</literal> class
            and avoids having to use fully qualified naming for it by importing it via a
            <literal>using</literal> satement:</para>
          <para/><![CDATA[
 #ifndef Client_H
 #define Client_H
 
 #include "Person.h"
 #include "Account.h"
 
 namespace SolmsTraining
 {
  namespace clients
  {
   using SolmsTraining::finance::Account;
 
   class Client: public virtual Person
   {
     public:
       Client(const string&amp; name, const string&amp; idNo,
              Account&amp; account);
 
       Account&amp; account() const;
 
     private:
       Account&amp; _account;
   };
  }
 }
 #endif
]]><para/>
        </section>
        <section>
          <title> Client.cpp</title>
          <para> In this implementation file we totally avoid using fully qualified names by
            importing both, the <literal>Account</literal> class from the
            <literal>SolmsTraining::finance</literal> namespace and the <literal>Client</literal>
            class from the <literal>SolmsTraining::clients</literal> namespace:</para>
          <para/><![CDATA[
 #include "Client.h"
 
 using SolmsTraining::finance::Account;
 using SolmsTraining::clients::Client;
 
 Client::Client (const string&amp; name, const string&amp; idNo, Account&amp; account)
          : Person(name, idNo), _account(account) {}
 
 Account&amp; Client::account() const
 {
   return _account;
 }
]]><para/>
        </section>
        <section>
          <title> TestNameSpace.cpp</title>
          <para> Finally we use these classes in the following example application:</para>
          <para/><![CDATA[
 #include <iostream>
 
 #include "Client.h"
 #include "Account.h"
 
 using namespace std;
 
 int main()
 {
   using SolmsTraining::clients::Client;
 
   SolmsTraining::finance::Account* acc
     = new SolmsTraining::finance::Account();
 
   acc->credit(380);
 
   Client* client1 = new Client("Abduhl", "6754236754", *acc);
 
   cout << client1->name() << " has a balance of R"
        << client1->account().balance() << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Finding Classes</title>
        <para> Packaging can help significantly in finding classes. One should make some effort in
          simplifying the search process for existing functionality, not only because one can avoid
          the cost of re-developing the functionality, but also because it will help reduce the code
          bulk which has to be maintained over time (as well as the size of executables). Even tasks
          like testing and performance tuning are simpler with less code bulk.</para>
        <para> Packaging can help significantly in simplifying the search for existing
          functionality, especially if the package hierarchy is along the lines of functionality and responsibility.</para>
        <para> Documentation tools may present class documentation along in a hierarchical form
          which mirrors the package structure.</para>
        <para> One may also want to use Java's idea of mapping the package (namespace) hierarchy
          onto a directory hierarchy. This may also help to simply the search for components.</para>
        <para/>
      </section>
      <section>
        <title> Exercises</title>
        <para> Decide on a sensible package hierarchy for the elements of the exercise of chapter ??
          and insert the components into the hierarchy. Test that your application still compiles
          and runs.</para>
        <para/>
      </section>
    </section>
    <!--end chapter-->
    <section role="chapter">
      <title> Error Handling Techniques</title>
      <para>
        <indexterm role="printindex"/>
        <indexterm role="printindex"/>
      </para>
      <section>
        <title> Introduction</title>
        <para> It is a good idea to separate a program into distinct subsystems that either complete
          successfully or fail. Thus, a limited form of local error checking should be implemented
          throughout the system in such a way that the overheads in development time, execution
          time, memory requirements and overall complexity do not become too high. A fault-tolerant
          system should be designed hierarchically, with each <indexterm role="printindex"/> level
          coping with as many errors as it can (without making the system too contorted) and leaving
          the remaining errors to be handled by higher levels of the system.</para>
        <para> One generally has however the problem that the error cannot be handled locally. Note
          that the user of your class library knows what to do when an error occurs, but he does not
          know how to detect an error in your classes. The author of the class library knows how to
          detect errors, but he does not know how the error should be handled. We thus need a global
          error communication system. Typically this would be one of the following: </para>
        <itemizedlist>
          <listitem>
            <para>Error state <informalequation>
                <graphic fileref="cpp130x.gif"/>
              </informalequation> return value of functions and object services. </para>
          </listitem>
          <listitem>
            <para>Classes with error state variables. </para>
          </listitem>
          <listitem>
            <para>Exception handling.</para>
          </listitem>
        </itemizedlist>
        <para/>
      </section>
      <section>
        <title> Error Communication via Return Values</title>
        <para> In the past it was commmon to communicate that the requested service could not be
          supplied by a return value returned by the service. Typically this was an integer which
          may have been zero if the service was supplied as requested and some other value
          otherwise. The value would supply some information about the source of the problem.</para>
        <para> This scenario may be ok if your direct client (i.e. the object from which the service
          was requested) is the one who always takes over the responsibility of handling the
          situation. Often this is, however, not the case. In many cases the error information has
          to be propagated up several layers in the calling hierarchy.</para>
        <para> In such situations the return-value mechanism becomes very diffcult to manage. Any of
          these services may generate its own code and to keep track of where the error originated
          from becomes virtually impossible when error codes are returned.</para>
        <para> This can be partially addressed by returning errfor reporting objects instead of
          simple error codes. These objects could contain the information about the source of the
          problem and any other relevant information.</para>
        <para> But even this can become a little burdensome. The error reporting objects have to be
          passed manually up the calling hierarchy and error checking must be done manually after
          each service request.</para>
        <para/>
      </section>
      <section>
        <title> Error Communication via Error States</title>
        <para> Sometimes the information about the problem is stored within the service provider
          object itself. This is typically done via instance members which can be queried by the
          client after the return from the service. If an error occurs the error state variable set
          to a value indicating error type.</para>
        <para> For example, the standard IOstream library of C++ has integer state variable state.
          The different bits of this state variable indicate different error states. The error state
          is queried via the class methods bad(), eof(), fail(). The user can query the error state
          and implement his own error handling mechanism.</para>
        <para> This mechanism does not scale well at all. Firstly, the same object may provide
          services to a wide range of clients and typically it would only keep track of the last
          error state. Personally I prefer even the return value mechanism to the error state mechanism.</para>
        <para/>
      </section>
      <section>
        <title> Error Communication via Exceptions</title>
        <para>
          <indexterm role="printindex"/>
        </para>
        <para> A more sophisticated method facilitating the split in responsibilities between error
          detection and error handling is provided by C++'s support for exception handling.
          Exceptions handling mechanisms are non-local. They provide a means of communicating the
          reason for not supplying a service oor the fact that a problem has been encountered while
          providing the service to the client who requested the service.</para>
        <para/>
        <section>
          <title> What is an Exceptional Situation?</title>
          <para> A server encouters an exceptional situation when it does not know when it cannot
            supply the requested service. For example, if you want to withdraw funds from an account
            and your account cannot provide the service because there are insuffcient funds in the
            account or because it has been frozen due to some legal dispute, then the account object
            would throw an exception, notifying you as client that it cannot supply the service.</para>
          <para/>
        </section>
        <section>
          <title> What does a client do with an Exception?</title>
          <para> Assume you requested a withdrawel from your account and that the account did not
            oblige, but threw an exception instead.</para>
          <para> If you ignore the exception, the person who asked you for the cash (you client)
            will be notified. In other words exceptions are passed up the client-server hierarchy
            (or the call-hierarchy).</para>
          <para> On the other hand you could decide to catch the exeption. When you catch an
            exception you have to provide the exception handling code. Here you could specify that
            if your withdrawel from account A failed that you will try and withdraw from account B
            or that it is time to visit your father in law or whatever.</para>
          <para/>
        </section>
        <section>
          <title> Throwing and Catching Exceptions</title>
          <para> We shall first look at the problem detection which occors at the server side and
            then we shall focus on the exception handling on the client side.</para>
          <para/>
        </section>
        <section>
          <title> Creating Exception Classes</title>
          <para> In C++ you can throw an instance of any class when an exceptional situation arises.
            Typically you would define a simple class exception class which may, at times, carry no
            information beyond the information conveyed through its identity. Such a class would
            simply be defined as an empty class (of course the compiler will provide default and
            copy constructors as well as an assignment operator and a <literal>this</literal> pointer).</para>
          <para> For example, we could define an <literal>InsufficientFunds</literal> exception
            simply as follows:</para>
          <para/><![CDATA[
 class InsufficientFunds {};
]]><para/>
          <section>
            <title> Exceptions which carry additional information</title>
            <para> Often one would like to add further information to an exception class. Since any
              class can be used for exceptions, one can add any attributes as well as any services.
              One should however refrain from adding any attributes or services which are unrelated
              to the core purpose of exceptions, that of conveying information about the reasons why
              the requested service could not be supplied.</para>
            <para> For example, we could define an insuffcient funds exception which carries
              information about the account which raised the exception as well as the funds
              available in that account:</para>
            <para/><![CDATA[
   class InsufficientFunds
   {
     public:
       InsufficientFunds(Account* const source,
                         const double availableFunds)
          : _source(source), _availableFunds(availableFunds) {}
 
       Account* const getSource() const {return _source;}
 
       double availableFunds() {return _availableFunds;}
 
     private:
       Account* const _source;
       const double _availableFunds;
   };
]]><para/>
          </section>
        </section>
        <section>
          <title> The Server Side: Throwing Exceptions</title>
          <para> The server detects a situation where it cannot complete the requested service and
            throws an exception. For example, in the <literal>debit()</literal> method of our
            <literal>Account</literal> class we check for suffcient funds.</para>

          <para/><![CDATA[
 class Account
 {
   public:
   ...
   void debit(double amount)
   {
     if (amount > balance)
       throw InsufficientFunds(this, _balance);
     else
       balance -= amount;
   }
   ...
 }
]]><para>
            When the problem is detected we instantiate the relevant Exception class and throw the
            exception via java's <literal>throw</literal> keyword. Note that the function announces
            that it may throw an<literal>IllegalArgumentException</literal>. This is done with a
            <literal>throws</literal> clause in the method header.</para>
          <para> This is all the server does. What could he do more anyway? The control is
            transferred at the <literal>throw</literal> clause from the server to the client -- the
            remainder of the method body is skipped.</para>
          <para> Note that when the exception is thrown the server code is exited, i.e. the
            remaining statements are skipped.</para>
          <para/>
          <section>
            <title> Exception Notification</title>
            <para> C++ also has support for exception notification. For example, if you want to
              notify the clients of the <literal>Account</literal> class that the debit service is
              not provided unconditionally, i.e. that under certain circumstances it throws an
              <literal>InsufficientFunds</literal> exception, then you add a<literal>throw</literal>
              clause to the method header:</para>

            <para/><![CDATA[
 class Account
 {
   public:
    ...
     void debit(double amount) throw (InsufficientFunds);
   ...
 }
]]><para>
              In the above listing we declare that the <literal>Account</literal> class may raise an
              <literal>InsufficientFunds</literal> exception. In other words, that the
              <literal>debit</literal> service is not supplied unconditionally. We are also saying
              that this service will NOT raise any other exception.</para>
            <para> If a service raises multiple exceptions, these are simply inserted into the
              brackets. For example, if we constrain the amount which may be withdrawn on a single
              day from an account, we may specify the <literal>throw</literal> clause of the
              <literal>debit</literal> service as follows:</para>

            <para/><![CDATA[
 class Account
 {
   public:
    ...
     void debit(double amount) throw (InsufficientFunds, DailyLimitExceeded);
   ...
 }
]]><para>
              We may also want to explicitly promise that a particular service is provided
              unconditionally. In this case the <literal>throw</literal> clause is followed by an
              empty bracket:</para>
            <para/><![CDATA[
 class Account
 {
   public:
    ...
     void credit(double amount) throw ();
   ...
 }
]]><para/>
          </section>
          <section>
            <title> Exception Notification Violations</title>
            <para> Assume a method or function promises in a <literal>throw</literal> clause not to
              throw any exceptions or only to throw certain exceptions. What happens if it in
              practice does throw another exception. This will only be known at run-time. The
              function <literal>unexpected()</literal> defined in the C++ standard library which, by
              default, will terminate the application.</para>
            <para/>
          </section>
        </section>
        <section>
          <title> The Client Side: Catching Exceptions</title>
          <para> The client makes use of the services offered by the server by sending messages to
            it. The service may complete successfully or the server may throw an exception.</para>
          <para> The client may or may not be able to handle the exception. If the client is not
            able to handle the exception it will be passed up the client server hierarchy (calling
            hierarchy) until, hopefully, there is a point where there is enough information to
            handle the problem.</para>
          <para> If a client is willing to catch an exception, it puts the service request message
            within a <literal>try</literal> block:</para>

          <para/><![CDATA[
 class TheClientClass
 {
   public;
     ...
     void aClientMethod()
   {
     ...
     try
     {
       account.debit(amount);  // this service may throw an exception
       ...
     }
     catch (InsufficientFunds e)
     {
       /* Exception handling code comes here.
          Sorry, this is still your baby. */
     }
     ...
   }
 };
]]><para>
            If an exception is thrown control is transferred from the service-request statement to
            the corresponding catch clause and, depending on the content of the catch clause,
            execution continuous with the statements following the catch clause.</para>
          <para> Note that if the client makes use of services which may through an exception, and
            if the client does not catch the exception, the client's method must notify users that
            it may thow that exception, even though it does not do so explicitly:</para>
          <para/><![CDATA[
 class TheClientClass
 {
   public:
     ...
     void aClientMethod() throw (InsufficientFunds)
   {
     ...
     account.debit(amount);  // this service may throw the exception
     ...
   }
 }
]]><para/>
        </section>
        <section>
          <title> A Complete Example</title>
          <para> Let us now look at the complete code for the <literal>Account</literal> example:</para>
          <para/>
          <section>
            <title> Account.h</title>
            <para/><![CDATA[
 #ifndef AccountH
 #define AccountH
 namespace SolmsTraining
 {
  namespace finance
  {
   class Account; // Forward declaration of Account
 
   class InsufficientFunds
   {
     public:
       InsufficientFunds(Account* const source,
                         const double availableFunds)
          : _source(source), _availableFunds(availableFunds) {}
 
       Account* const getSource() const {return _source;}
 
       double availableFunds() {return _availableFunds;}
 
     private:
       Account* const _source;
       const double _availableFunds;
   };
 
   class Account
   {
     public:
       Account();
       Account(double initialBalance);
 
       ~Account();
 
       void credit(double amount);
       void debit(double amount) throw (InsufficientFunds);
 
       double balance();
 
     private:
       double _balance;
   };
  }
 }
 
 #endif
]]><para/>
          </section>
          <section>
            <title> Account.cpp</title>
            <para/><![CDATA[
 #include "Account.h"
 #include <iostream>
 
 using namespace SolmsTraining::finance;
 
 using namespace std;
 
 Account::Account(): _balance(50) {}
 
 Account::Account(double initialBalance): _balance(initialBalance) {}
 
 Account::~Account()
 {
   cout << "I, " << this << ", am destroyed." << endl;
 }
 
 void Account::credit(double amount)
 {
   _balance += amount;
 }
 
 void Account::debit(double amount)
           throw (InsufficientFunds)
 {
   if (amount > _balance)
     throw InsufficientFunds(this, _balance);
   _balance -= amount;
 }
 
 double Account::balance() {return _balance;}
]]><para/>
          </section>
          <section>
            <title> TestException1.cpp</title>

            <para/><![CDATA[
 #include <iostream>
 #include "Account.h"
 
 using namespace SolmsTraining::finance;
 
 using namespace std;
 
 int main()
 {
   Account* myAccount = new Account();
   myAccount->credit(2000);
 
   Account* myUnclesAccount = new Account(3000);
 
   while (true)
   {
     try
     {
       myAccount->debit(350);
       cout << "Debited my account. Balance: " << myAccount->balance() << endl;
     }
     catch (InsufficientFunds exception)
     {
       cout << "my Account only has R"
            << exception.availableFunds() << " left."
            << " Debited uncle instead." << endl;
       try
       {
         myUnclesAccount->debit(350);
       }
       catch (InsufficientFunds e)
       {
         cout << "Out of luck. Uncle broke too." << endl;
         return -1;
       }
     }
   }
 }
]]><para>
              Running the application yields the following ouput:</para>
            <para/><![CDATA[
 Debited my account. Balance: 1700
 Debited my account. Balance: 1350
 Debited my account. Balance: 1000
 Debited my account. Balance: 650
 Debited my account. Balance: 300
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 my Account only has R300 left. Debited uncle instead.
 Out of luck. Uncle broke too.
]]><para/>
          </section>
        </section>
        <section>
          <title> Catching Exceptions at various levels of Abstraction</title>
          <para> In order to be able to handle exceptions at different levels of abstraction we have
            to introduce a class hierarchy for exceptions. For example, we may feel want to
            introduce the concept of an exception through a base class <literal>Exception</literal>.
            We could then define a specialized<literal>TransactionFailed</literal> exception with
            further specializetions like <literal>InsufficientFunds</literal>
            and<literal>DailyLimitExceeded</literal> exceptions:</para>

          <para/><![CDATA[
 class Exception {};
 
 namespace finance
 {
   class TransactionFailed: public Exception {};
 
   class InsufficientFunds: public TransactionFailed {};
 
   class DailyLimitExceeded: public TransactionFailed {};
 
   class AuthorizationFailed: public TransactionFailed {};
 }
]]><para>
            Once we have done this we can handle exceptions at different levels of abstraction.
            Consider, for example, the following code:</para>
          <para/><![CDATA[
 try
 {
   account.debit(amount);
 }
 catch (InsufficientFunds)
 {
   /* handle this problem one way */
 }
 catch (TransactionFailed)
 {
   /* Handle all other TransactionFailed exceptions this way */
 }
 catch (Exception)
 {
   /* Handle all other exceptions yet another way. */
 }
]]><para/>
          <section>
            <title> Catching all Exceptions</title>
            <para> C++ also supports a <literal>catch</literal> clause which catches all exceptions
              irrespective of whether they are part of the same class hierarchy or not. To achieve
              this one inserts 3 dots into the arguments brackets of the catch clause:</para>
            <para/><![CDATA[
 try
 {
   account.debit(amount);
 }
 catch (InsufficientFunds)
 {
   /* Handle this problem one way. */
 }
 catch (...)
 {
   /* Catch anything else which is thrown in this way. */
 }
]]><para/>
          </section>
        </section>
        <section>
          <title> Partial Handling of an Exception</title>
          <para> Assume that we want to perform some action upon an exception being thrown by a
            service we requested, but that we cannot handle it completey (i.e. cannot decide how to
            resolve the problem completely). In such a situation we can catch the exception, perform
            some action in the <literal>catch</literal> block and either rethrow the same exception
            or throw another exception from within the catch block. In this way we notify the users
            of our method that we still have not resolved the problem completely.</para>
          <para> C++ has a special syntax for rethrowing the same exception:</para>
          <para/><![CDATA[
 try
 {
   /* do some IO */
 }
 catch (EndOfFile)
 {
   /* Process data. */
 }
 catch (...)
 {
   /* Close files and rethrow. */
 
   ifsteam.close();
 
   throw;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Throwing Type Declarations</title>
        <para> C++ also allows you to throw primitives like enumerated integers:</para>
        <para/><![CDATA[
 class Account
 {
   private:
     enum State {success, noFunds, authorizationFailed, limitExceeded};
     State state = success;
 
   public:
     void debit(amount)
     {
       ...
       if (amount > _balance)
         state = noFunds;
       ...
       if (state != success)
         throw state;
       ...
    }
 };
]]><para/>
        <section>
          <title> Defining Exception Classes as Nested Classes</title>
          <para> It is often a good idea to package the exception class together with the class
            which may raise the exception.</para>
          <para> For example for a Rational class developed may raise a DivideByZero exception if
            the denominator of a Rational object becomes zero and a <literal>OutOfRange</literal>
            exception if the numerator or denominator falls outside the range of the
            <literal>long</literal> data type:</para>

          <para/><![CDATA[
 class Rational
 {
   public:
     Rational (const long int Numer, const long int Denom) ;
     ...
     long int numerator();
     long int denominator();
     ...
     Rational operator + (const Rational&amp; r)
     ...
     class DivideByZero {};     // exception class for /0 error
     class OutOfRange   {};     // exception class for range error
   private:
     long int numer, denom;
 }
]]><para>
            The calling program could catch these exceptions in the following way</para>
          <para/><![CDATA[
 void main()
 {
   ...
   try
   {
     long int a, b, c, d;
     ...
     calc1(a,b);
     calc2(c,d);
     ...
     Rational r1(a,b), r2(c,d);
     Rational r3 = r1+r2;
   }
   catch (Rational::DevideByZero)
   {
      ...       // error handler for /0 errors
   }
   catch (Rational::OutOfRange)
   {
      ...       // error handler for range errors
   }
   ...
 }
]]><para/>
          <para/>
        </section>
      </section>
    </section>
    <!--end chapter-->
    <section role="chapter">
      <title> The Standard Template Library </title>
      <section>
        <title> Introduction and Overview</title>
        <para> The Standard Template Library (STL) is C++'s collection class library. It supports
          most classical data structures like linked lists, maps, queues and automatically resizing arrays.</para>
        <para> The Java 2 Collection Framework itself is largely based on the STL. Though it is in
          some ways more powerful, it is in other ways less general than the STL.</para>
        <para> The library consists of a collection of heavily parametrized classes and functions.
          It is built around 3 core pillars: Containers stores the actual elements and may provide
          methods for accessing elements. Iterators are generalizations of pointers. They can be
          used to step through a collection and to retrieve, modify or insert an element at the
          position they are currently pointing to, Algorithms are general operations which may be
          performed on containers. This includes searching, sorting, copying, filling and more.</para>
        <para/>
        <section>
          <title> Some Core Design Decisions</title>
          <para> A lot of effort has been put into the design of the STL and many of these design
            ideas have since been directly taken over by other collection class libraries like the
            Java 2 Collection Framework.</para>
          <para/>
          <section>
            <title> The design is centered around interfaces</title>
            <para> Like the Java 2 Collection Framework, the STL is designed around interfaces and
              not around the implementation classes.</para>
            <para/>
          </section>
          <section>
            <title> Algorithms are defined seperately from the container classes</title>
            <para> The STL follows an un-usual design from an object-oriented perspective and this
              design has been mirrored in the Java 2 Collection Framework in that the algorithms are
              supplied as stand-alone functions and not as instance methods of the container classes.</para>
            <para/>
          </section>
          <section>
            <title> Iterators are modelled as specializations of pointers</title>
            <para> One of the design decisions made for the STL is to define iterators as
              specializations of pointers, i.e. iterators support dereferencing as well as pointer
              arithmetic. This makes it possible that the algorithms are equally applicable to the
              collection classes and to primitive pointer-based arrays.</para>
            <para/>
          </section>
        </section>
      </section>
      <section>
        <title> Containers</title>
        <para> The Standard Template Library supplies the following container implementations:
          vector -- a random access container based on an automatically resizing array. list -- a
          random access container based on a doubly-linked circular list implementation. hashset --
          a sorted collection guaranteeing that each element is only contained once. It is typically
          based on a balanced binary tree implementation. set -- a sorted collection guaranteeing
          that each element is conly contained once. It is typically based on a balanced binary tree
          implementation. map -- a container which maps keys onto values. A map keeps the keys in
          sorted order. hash-map -- a container which maps keys onto values. The keys are not kept
          in sorted order.</para>
        <para> The STL container hierarchy is quite elaborate. However, looking at the hierarchy for
          collections (vectors, lists and sets) and maps one can clearly see how the Java 2
          Collection Framework is a simplification of the STL. </para>
        <figure>
          <title/>
          <blockquote>
            <para/>
            <section role="center">
              <title/>
              <para>
                <graphic width="72.26999pt" fileref="STL/Containers.pdf"/>
              </para>
            </section>
            <blockquote role="caption">
              <title role="caption"> Figure 8.1</title>
              <para>The class/interface hierarchy leading to the STL collections (sets, list and vector).</para>
            </blockquote>
          </blockquote>
        </figure> All these collection classes are heavily parametrized. We shall discuss a few of
        them below. <figure>
          <title/>
          <blockquote>
            <para/>
            <section role="center">
              <title/>
              <para>
                <graphic width="72.26999pt" fileref="STL/Maps.pdf"/>
              </para>
            </section>
            <blockquote role="caption">
              <title role="caption"> Figure 8.2</title>
              <para>The class/interface hierarchy leading to the STL maps.</para>
            </blockquote>
          </blockquote>
        </figure>
        <section>
          <title> The vector container type</title>
          <para> The vector template class supplied by the STL is not really a true vector in the
            mathematical sense but a automatically resizing array structure.</para>
          <para> It takes one compulsory template argument, the data type, and one optional template
            arguments, an allocator which provides a facility to assign your own low-level mechanism
            for memory allocation and de-allocation.</para>
          <para/><![CDATA[
 template <class T, class Alloc> vector
]]><para> In nearly all practical
            cases the default allocator is used and the second template argument is ommited. This to
            create an empty vector of floating point numbers on the stack you could write the
            following statement:</para>
          <para/><![CDATA[
 vector<double> vec1;
]]><para> If you want to specify an initial size of
            20 elements you could write the following statement:</para>
          <para/><![CDATA[
 vector<double> vec2(20);
]]><para/>
        </section>
        <section>
          <title> An example program using a vector</title>
          <para/><![CDATA[
 #include <vector>
 #include <iostream>
 
 #include "Person.h"
 
 using namespace std;
 
 void print(vector<double>&amp; v)
 {
   cout << "v = [ ";
   for (vector<double>::iterator iter = v.begin();
        iter != v.end(); ++iter)
            cout << (*iter) << " ";
   cout << "]" << endl;
 }
 
 int main()
 {
   vector<double> v(20);
   v[0] = 11.1;   v[10] = 1.2;
   v[1] = 11.5;   v[11] = 2.2;
   v[2] = 8.1;    v[12] = 2.1;
   v[3] = 9.11;   v[13] = 1.3;
   v[4] = 6.35;   v[14] = 4.2;
   v[5] = 11.1;   v[15] = 1.3;
   v[6] = 8.45;   v[16] = 4.1;
   v[7] = 9.67;   v[17] = 1.2;
   v[8] = 9.76;   v[18] = 1.7;
   v[9] = 9.45;   v[19] = 6.3;
 
   cout << "Before sorting: " << endl;
   print(v);
 
   sort(v.begin(), v.end());
 
   cout << "After sorting: " << endl;
   print(v);
 
   v.insert(v.begin(), -999);
 
   v.insert(v.end(), 999);
 
   cout << "After inserting: " << endl;
   print(v);
 
   vector<Person*> persons(3);

   persons[0] = new Person("Jack Hill", "6541654");
   persons[1] = new Person("Jill Crack", "6641654");
   persons[2] = new Person("Jack Jillian", "6741654");
   for (vector<Person*>::iterator iter = persons.begin();
        iter != persons.end(); ++iter)
            cout << (**iter) << " ";
   cout << endl;
 
   double* dvec = new double[3];
   dvec[0] = 2.1;
   dvec[1] = 1.2;
   dvec[2] = 3.1;
 
   double* end = &amp;dvec[2];
 
   sort(dvec, end);
 
   cout << dvec[0] << " " << dvec[1] << " " << dvec[2] << endl;
 
   char c; cin >> c;
 
   return 0;
 }
]]><para/>
        </section>
        <section>
          <title> An example program using a set and a map</title>
          <para/><![CDATA[
 #include <iostream>
 #include <map>
 #include <set>
 #include <string>
 
 #include <stdlib.h>
 
 #include "Account.h"
 #include "Person.h"
 
 using SolmsTraining::finance::Account;
 
 using namespace std;
 
 struct PersonComparator
 {
   bool operator()(const Person * const p1, const Person * p2)
   {
     return p1->name() < p2->name();
   }
 };
 
 int main()
 {
   Person* p = new Person("Jacky de Lill", "6142354");
 
   set<Person*, PersonComparator> persons;
   persons.insert(new Person("Jack Hill", "6541654"));
   persons.insert(p);
   persons.insert(new Person("Jaco Mill", "6323254"));
 
   map<Person*, Account*> clientsAccounts;
 
   int accNo = 101;
   for (set<Person*, PersonComparator>::iterator iter = persons.begin();
        iter != persons.end(); ++iter)
   {
     const string accNo("Acc:");
     cout << "X" << accNo << endl;
     clientsAccounts[*iter] = new Account(accNo, 1000);
   }
 
   clientsAccounts[p]->credit(2000);
 
   for (set<Person*, PersonComparator>::iterator iter = persons.begin();
        iter != persons.end(); ++iter)

           cout << "bal: " << clientsAccounts[*iter]->balance() << endl;
 
   for (map<Person*, Account*>::iterator iter = clientsAccounts.begin();
        iter != clientsAccounts.end(); ++iter)
   {
     Person* p = iter->first;
     Account* acc = iter->second;
     cout << *p << "  =>  " << *acc <<  endl;
   }
   return 0;
 }
]]><para/>
        </section>
      </section>
      <section>
        <title> Iterators</title>
        <para> InputIterator s provide read access to the container elements via <literal>x =
          *iter;</literal> OutputIterator s provide write access to the container elements via
            <literal>*iter = x;</literal> ForwardIterator supports traversal of the container in the
          forward direction via the pointer increment operator, <literal>++</literal>.
          ReverseIterator supports traversal of the container in the reverse direction via the
          pointer decrement operator, <literal>--</literal>. RandomAccessIterator s provide random
          access to containers which support random access (e.g. <literal>list</literal> and
          <literal>vector</literal>) via the element access operator, e.g. <literal>x = iter[index];</literal>
        </para>
        <para/>
      </section>
      <section>
        <title> Algorithms</title>
        <para> The STL defines generic algorithms seperately from the container classes. These
          algorithms are applicable to </para>
        <itemizedlist>
          <listitem>
            <para>the STL container classes themselves, </para>
          </listitem>
          <listitem>
            <para>any other container implementation of the STL interfaces, </para>
          </listitem>
          <listitem>
            <para>primitive pointer-based arrays.</para>
          </listitem>
        </itemizedlist>
        <para> Some of the commonly used algorithms include </para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>copy(InputIterator first, InputIterator last, OutputIterator result)</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>copy(InputIterator first, InputIterator last, OutputIterator result)</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>fill(InputIterator first, InputIterator last, const T&amp; value)</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>find(InputIterator first, const EqualityComparable&amp; value)</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>sort(RandomAccessIterator first, RandomAccessIterator last)</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>stable_sort(RandomAccessIterator first, RandomAccessIterator last)</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>binarySerach(ForwardIterator first, const LessThanComparable&amp; value)</literal>
            </para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <!--end chapter-->
  </section>
  <!--end likechapter-->
</article>
