\contentsline {chapter}{\numberline {1}$C^{++}$-basics }{1}
\contentsline {section}{\numberline {1.1}Structure of a simple program}{1}
\contentsline {subsection}{\numberline {1.1.1}Compiling and running the program}{2}
\contentsline {subsection}{\numberline {1.1.2}Adding comments to your code}{2}
\contentsline {section}{\numberline {1.2}Declarations}{3}
\contentsline {subsection}{\numberline {1.2.1}Type-casting}{4}
\contentsline {subsubsection}{Implicit type-casting}{4}
\contentsline {subsubsection}{Explicit type casting}{5}
\contentsline {subsubsection}{Identifier names}{5}
\contentsline {subsubsection}{Reference types}{5}
\contentsline {subsection}{\numberline {1.2.2}The scope and lifespan of variables}{6}
\contentsline {subsubsection}{Lifespan of static variables}{7}
\contentsline {section}{\numberline {1.3}$C^{++}$ operators}{8}
\contentsline {section}{\numberline {1.4}Control statements}{10}
\contentsline {subsection}{\numberline {1.4.1}Selection statements}{10}
\contentsline {subsubsection}{The if-statement}{10}
\contentsline {subsubsection}{The switch-statement}{11}
\contentsline {subsection}{\numberline {1.4.2}Iterative statements}{11}
\contentsline {subsection}{\numberline {1.4.3}Example program: Celsius $\Leftrightarrow $ Fahrenheit}{12}
\contentsline {subsection}{\numberline {1.4.4}Compound Interest}{15}
\contentsline {section}{\numberline {1.5}Interfacing with functions}{17}
\contentsline {subsection}{\numberline {1.5.1}Passing arguments by value or by reference? }{17}
\contentsline {subsubsection}{Function return values}{18}
\contentsline {subsection}{\numberline {1.5.2}Function overloading}{19}
\contentsline {subsection}{\numberline {1.5.3}Functions matching by type conversion}{20}
\contentsline {subsection}{\numberline {1.5.4}Default Values: Optional Arguments}{20}
\contentsline {subsection}{\numberline {1.5.5}Functions with Variable Number of Arguments}{21}
\contentsline {subsection}{\numberline {1.5.6}Command-line parameters}{22}
\contentsline {section}{\numberline {1.6}Pointers}{25}
\contentsline {subsection}{\numberline {1.6.1}The NULL pointer}{25}
\contentsline {subsection}{\numberline {1.6.2}Pointers and strong typing}{26}
\contentsline {subsection}{\numberline {1.6.3}Constant pointers and pointers to constants}{26}
\contentsline {subsection}{\numberline {1.6.4}Pointer arithmetic}{26}
\contentsline {subsection}{\numberline {1.6.5}Pointers to functions: passing a function as a function argument}{27}
\contentsline {section}{\numberline {1.7}Arrays}{29}
\contentsline {subsection}{\numberline {1.7.1}Arrays in static memory}{29}
\contentsline {subsection}{\numberline {1.7.2}Arrays in dynamic memory}{30}
\contentsline {subsubsection}{Example program: Linear regression}{33}
\contentsline {subsection}{\numberline {1.7.3}Array versus vectors and matrices}{35}
\contentsline {subsection}{\numberline {1.7.4}Character arrays as strings}{36}
\contentsline {section}{\numberline {1.8}Function templates}{37}
\contentsline {subsection}{\numberline {1.8.1}Example program: Bubble-sort}{38}
\contentsline {subsection}{\numberline {1.8.2}Multiple templates}{40}
\contentsline {subsection}{\numberline {1.8.3}Overloading template functions}{40}
\contentsline {section}{\numberline {1.9}Recursion}{41}
\contentsline {section}{\numberline {1.10}Simple file I/O and simple strings}{42}
\contentsline {subsection}{\numberline {1.10.1}Example program: Replacing all occurances of a string in a file}{43}
\contentsline {section}{\numberline {1.11}Constants and inline functions instead of macros}{45}
\contentsline {chapter}{\numberline {2}Introduction to Object-Oriented Programming in C++}{49}
\contentsline {section}{\numberline {2.1}Objects and Classes}{49}
\contentsline {subsection}{\numberline {2.1.1}What is an Object?}{49}
\contentsline {subsection}{\numberline {2.1.2}Identifying Objects}{49}
\contentsline {subsection}{\numberline {2.1.3}Classes as Abstractions of Objects}{50}
\contentsline {section}{\numberline {2.2}Defining Classes}{50}
\contentsline {subsection}{\numberline {2.2.1}A Simple Account Class }{50}
\contentsline {subsection}{\numberline {2.2.2}Methods/Services}{51}
\contentsline {subsubsection}{Method names}{51}
\contentsline {subsection}{\numberline {2.2.3}Access levels}{51}
\contentsline {subsubsection}{Encapsulation}{52}
\contentsline {subsection}{\numberline {2.2.4}Constructors }{53}
\contentsline {subsubsection}{Member Initialization via the Constructor's Parameter List}{54}
\contentsline {subsubsection}{Compiler-Generated Default Constructor}{54}
\contentsline {subsection}{\numberline {2.2.5}The OO Naming Convention}{55}
\contentsline {section}{\numberline {2.3}Requesting services from objects}{55}
\contentsline {section}{\numberline {2.4}The Life-Span of an Object on the Stack}{56}
\contentsline {subsection}{\numberline {2.4.1}Destructors}{56}
\contentsline {section}{\numberline {2.5}Splitting Headers and Implementation}{57}
\contentsline {subsection}{\numberline {2.5.1}The Header File}{57}
\contentsline {subsection}{\numberline {2.5.2}The Implementation File}{58}
\contentsline {subsection}{\numberline {2.5.3}Including Header Files}{59}
\contentsline {section}{\numberline {2.6}Creating Objects on the Heap}{60}
\contentsline {section}{\numberline {2.7}Class Members}{61}
\contentsline {subsection}{\numberline {2.7.1}Constructors are Class Services}{62}
\contentsline {subsection}{\numberline {2.7.2}Destructors are Instance Services}{62}
\contentsline {subsection}{\numberline {2.7.3}Specifying Implementation Details of Class Members}{62}
\contentsline {subsection}{\numberline {2.7.4}Using Class Members}{63}
\contentsline {section}{\numberline {2.8}Exercises}{64}
\contentsline {chapter}{\numberline {3}Abstract Data Types: Rational Numbers }{65}
\contentsline {section}{\numberline {3.1}Private and public data members}{66}
\contentsline {section}{\numberline {3.2}Template classes}{67}
\contentsline {section}{\numberline {3.3}Constructors }{67}
\contentsline {subsection}{\numberline {3.3.1}Specifying Constructors}{68}
\contentsline {subsection}{\numberline {3.3.2}Copy Constructors}{68}
\contentsline {subsection}{\numberline {3.3.3}Other Constructors}{69}
\contentsline {subsection}{\numberline {3.3.4}Implementing Constructors}{69}
\contentsline {section}{\numberline {3.4}Member functions}{71}
\contentsline {subsection}{\numberline {3.4.1}Public versus private member functions}{72}
\contentsline {section}{\numberline {3.5}Class operators}{73}
\contentsline {subsection}{\numberline {3.5.1}Arithmetic operators}{73}
\contentsline {subsection}{\numberline {3.5.2}Friends of a class and globally defined operators}{74}
\contentsline {subsection}{\numberline {3.5.3}Unary Operators and the {\bf this} pointer}{76}
\contentsline {subsection}{\numberline {3.5.4}Type-Conversion Operators }{77}
\contentsline {subsection}{\numberline {3.5.5}Relational Operators}{77}
\contentsline {subsection}{\numberline {3.5.6}The Assignment Operator}{78}
\contentsline {subsection}{\numberline {3.5.7}The Power Method }{79}
\contentsline {section}{\numberline {3.6}Input/Output Stream Access}{80}
\contentsline {section}{\numberline {3.7}User's Guide to the Rational Class }{81}
\contentsline {section}{\numberline {3.8}Listing of the Rational Class }{83}
\contentsline {section}{\numberline {3.9}Listing of the Exception Classes }{92}
\contentsline {section}{\numberline {3.10}Exercises}{94}
\contentsline {chapter}{\numberline {4}Working at Different Levels of Abstraction }{95}
\contentsline {section}{\numberline {4.1}Introduction}{95}
\contentsline {section}{\numberline {4.2}Abstraction via Super-Classes}{95}
\contentsline {subsection}{\numberline {4.2.1}Thinking at Different Levels of Abstraction (Part 1)}{95}
\contentsline {subsection}{\numberline {4.2.2}Specialization through Subclassing }{96}
\contentsline {subsubsection}{The Person Header}{96}
\contentsline {subsubsection}{The Person Implementation}{97}
\contentsline {subsubsection}{The Header for the Employee Sub-Class}{98}
\contentsline {subsubsection}{The Implementation File for the Employee Sub-Class}{98}
\contentsline {subsection}{\numberline {4.2.3}Inheritance}{99}
\contentsline {subsection}{\numberline {4.2.4}Access Levels}{100}
\contentsline {subsubsection}{Should you Declare Data Fields Protected?}{101}
\contentsline {subsection}{\numberline {4.2.5}Public, Protected and Private Subclassing}{102}
\contentsline {subsubsection}{Should you Actually use Private or Protected Subclassing?}{103}
\contentsline {subsection}{\numberline {4.2.6}Overriding Methods}{103}
\contentsline {subsection}{\numberline {4.2.7}Polymorphism and Virtual Methods}{103}
\contentsline {subsection}{\numberline {4.2.8}Polymorphic Collections}{105}
\contentsline {section}{\numberline {4.3}Multiple Inheritance}{106}
\contentsline {subsection}{\numberline {4.3.1}Simplistic Multiple Inheritance and its Problems}{107}
\contentsline {subsection}{\numberline {4.3.2}Virtual Specialization}{110}
\contentsline {section}{\numberline {4.4}Abstract Classes}{112}
\contentsline {subsection}{\numberline {4.4.1}How to Declare a Class with Concrete Methods Abstract}{113}
\contentsline {subsection}{\numberline {4.4.2}Abstract Methods for Interface Definition}{113}
\contentsline {subsection}{\numberline {4.4.3}SubClassing Abstract Classes}{114}
\contentsline {subsection}{\numberline {4.4.4}Abstract, Virtual and Non-Virtual Methods}{114}
\contentsline {subsubsection}{Abstract or pure virtual methods}{114}
\contentsline {subsubsection}{Concrete virtual methods}{114}
\contentsline {subsubsection}{Non-virtual methods}{115}
\contentsline {section}{\numberline {4.5}C++ and Interfaces}{117}
\contentsline {section}{\numberline {4.6}Exercises}{118}
\contentsline {chapter}{\numberline {5}Classes using Dynamic Memory: Vectors and Matrices }{121}
\contentsline {section}{\numberline {5.1}Introduction}{121}
\contentsline {section}{\numberline {5.2}The Vector Class}{121}
\contentsline {subsection}{\numberline {5.2.1}Introduction}{121}
\contentsline {subsection}{\numberline {5.2.2}Static Members of a Class }{122}
\contentsline {subsection}{\numberline {5.2.3}Constructors, Destructor, Assignment Operator}{124}
\contentsline {subsubsection}{Constructors}{124}
\contentsline {subsubsection}{The Assignment Operator}{125}
\contentsline {subsubsection}{The Destructor}{126}
\contentsline {subsection}{\numberline {5.2.4}Element Access}{126}
\contentsline {subsection}{\numberline {5.2.5}User's Guide to the Vector Class}{127}
\contentsline {subsubsection}{Arithmetic Operations}{127}
\contentsline {subsubsection}{Vector functions}{128}
\contentsline {subsection}{\numberline {5.2.6}Vector Norms, Normalization, Mean, \dots }{128}
\contentsline {subsubsection}{Stream Access}{129}
\contentsline {subsubsection}{Vectors of user-defined data types}{130}
\contentsline {subsubsection}{The Demonstration Program}{130}
\contentsline {subsection}{\numberline {5.2.7}Listing of the Vector Class }{132}
\contentsline {section}{\numberline {5.3}Matrix Class}{145}
\contentsline {subsection}{\numberline {5.3.1}Introduction}{145}
\contentsline {subsection}{\numberline {5.3.2}Arrays of Objects}{145}
\contentsline {subsection}{\numberline {5.3.3}Using the Functionality of the Underlying Vector Class}{146}
\contentsline {subsection}{\numberline {5.3.4}Matrix Multiplication, Kronecker and Hadamard Products }{147}
\contentsline {subsection}{\numberline {5.3.5}Users Guide to the Matrix Class}{148}
\contentsline {subsubsection}{Element, Row and Column Access}{149}
\contentsline {subsubsection}{Query Functions}{149}
\contentsline {subsubsection}{Arithmetic Operators}{149}
\contentsline {subsubsection}{Matrix Manipulation Functions}{150}
\contentsline {subsubsection}{Inserting and Removing Rows and Columns}{151}
\contentsline {subsubsection}{Stream Access}{151}
\contentsline {subsubsection}{The Demonstration Program}{152}
\contentsline {subsection}{\numberline {5.3.6}Listing of the Matrix Class }{153}
\contentsline {section}{\numberline {5.4}Exercises}{167}
\contentsline {chapter}{\numberline {6}Packaging via Namespaces }{169}
\contentsline {section}{\numberline {6.1}NameSpace Pollution}{169}
\contentsline {subsection}{\numberline {6.1.1}Unique Naming}{169}
\contentsline {section}{\numberline {6.2}Defining NameSpaces}{170}
\contentsline {subsection}{\numberline {6.2.1}Namespaces are Cumulative}{170}
\contentsline {subsection}{\numberline {6.2.2}Namespaces Span Accross Files}{171}
\contentsline {section}{\numberline {6.3}Using Elements Defined in Other NameSpaces}{171}
\contentsline {subsection}{\numberline {6.3.1}Importing Entire Namespaces}{171}
\contentsline {section}{\numberline {6.4}Hierarchical Naming via Nested NameSpaces}{172}
\contentsline {section}{\numberline {6.5}Splitting Implementation from Header}{172}
\contentsline {section}{\numberline {6.6}Anonymous Namespaces}{173}
\contentsline {section}{\numberline {6.7}An Example}{173}
\contentsline {subsubsection}{Account.h}{173}
\contentsline {subsubsection}{Account.cpp}{174}
\contentsline {subsubsection}{Client.h}{175}
\contentsline {subsubsection}{Client.cpp}{175}
\contentsline {subsubsection}{TestNameSpace.cpp}{176}
\contentsline {section}{\numberline {6.8}Finding Classes}{176}
\contentsline {section}{\numberline {6.9}Exercises}{177}
\contentsline {chapter}{\numberline {7}Error Handling Techniques}{179}
\contentsline {section}{\numberline {7.1}Introduction}{179}
\contentsline {section}{\numberline {7.2}Error Communication via Return Values}{179}
\contentsline {section}{\numberline {7.3}Error Communication via Error States}{180}
\contentsline {section}{\numberline {7.4}Error Communication via Exceptions}{180}
\contentsline {subsection}{\numberline {7.4.1}What is an Exceptional Situation?}{180}
\contentsline {subsection}{\numberline {7.4.2}What does a client do with an Exception?}{181}
\contentsline {subsection}{\numberline {7.4.3}Throwing and Catching Exceptions}{181}
\contentsline {subsection}{\numberline {7.4.4}Creating Exception Classes}{181}
\contentsline {subsubsection}{Exceptions which carry additional information}{181}
\contentsline {subsection}{\numberline {7.4.5}The Server Side: Throwing Exceptions}{182}
\contentsline {subsubsection}{Exception Notification}{182}
\contentsline {subsubsection}{Exception Notification Violations}{183}
\contentsline {subsection}{\numberline {7.4.6}The Client Side: Catching Exceptions}{183}
\contentsline {subsection}{\numberline {7.4.7}A Complete Example}{184}
\contentsline {subsubsection}{Account.h}{184}
\contentsline {subsubsection}{Account.cpp}{185}
\contentsline {subsubsection}{TestException1.cpp}{186}
\contentsline {subsection}{\numberline {7.4.8}Catching Exceptions at various levels of Abstraction}{187}
\contentsline {subsubsection}{Catching all Exceptions}{188}
\contentsline {subsection}{\numberline {7.4.9}Partial Handling of an Exception}{189}
\contentsline {section}{\numberline {7.5}Throwing Type Declarations}{189}
\contentsline {subsection}{\numberline {7.5.1}Defining Exception Classes as Nested Classes}{190}
\contentsline {chapter}{\numberline {8}The Standard Template Library }{191}
\contentsline {section}{\numberline {8.1}Introduction and Overview}{191}
\contentsline {subsection}{\numberline {8.1.1}Some Core Design Decisions}{191}
\contentsline {subsubsection}{The design is centered around interfaces}{191}
\contentsline {subsubsection}{Algorithms are defined seperately from the container classes}{192}
\contentsline {subsubsection}{Iterators are modelled as specializations of pointers}{192}
\contentsline {section}{\numberline {8.2}Containers}{192}
\contentsline {subsection}{\numberline {8.2.1}The vector container type}{192}
\contentsline {subsection}{\numberline {8.2.2}An example program using a vector}{193}
\contentsline {subsection}{\numberline {8.2.3}An example program using a set and a map}{195}
\contentsline {section}{\numberline {8.3}Iterators}{197}
\contentsline {section}{\numberline {8.4}Algorithms}{197}
