<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<part xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Advanced Object-oriented software development with Java SE</title>
  <!-- Alternatives to standard object creation -->
    <!-- The factory design pattern -->
    <!-- When are factories useful ? -->
    <!-- Java implementation (and examples) -->
  

  <!-- Design-by-contract -->
  <xi:include href="../../../../../../resources/information/technologies/java/lang/ooMappings/designByContract/designByContract.docbook"/>
      
  <!-- Summary of UML (relationships) -->
  <chapter>
    <title>UML Relationships and Java</title>
    <xi:include href="../../../../../../resources/information/technologies/uml/classDiagrams/relationshipsSummary/relationshipsSummary.docbook"/>
    <xi:include href="../../../../../../resources/information/technologies/java/lang/ooMappings/ooMappings.docbook"/>
  </chapter>
  
  <!-- More detail: Mapping each of the relationships to Java objects -->
  <!-- Implications of relationships on:
    - Base object services
    - JavaBeans services
  -->  
  
  
  <!-- Contemporary object-orientation with Java -->
    <!-- What exactly is OO? -->
      <!-- The traditional approach -->
      <!-- Other (more modern) methodologies to get ideas from (RDF, SOA) -->
      <!-- Some problems with the traditional OO approach -->
        <!-- Rigidity in class hierarchies -->
          <!-- Solution: contract-based development -->
        <!-- 'intelligent' objects that inflexibly represent
          domain objects and service providers (business processes) -->
          <!-- Solution: Separating services from value objects -->
            <!-- Against typical notion of OO, back to procedural -->
            <!-- But, we still have contracts, polymorphism -->
            <!-- In line with SOA, RDF, etc -->
          <!-- Why static constraints coded into domain objects are bad -->
            <!-- Only make sense in a particular context -->
            <!-- The fallacy of 'validate()' -->
            <!-- Peek at how far RDF takes this concept (no types, no
              constraints) -->
            <!-- Best approach: accept Java as a strongly typed language
              (and its productivity benefits) but keep the lessons form
              more dynamic languages in mind -->
    
</part>